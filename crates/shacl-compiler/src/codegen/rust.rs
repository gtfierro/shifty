use crate::plan::{CompId, ComponentKind, PlanIR, PlanPath, PlanShape, PlanShapeKind, PlanTarget};
use crate::registry::{self, EmitContext, PropertyEmission};
use crate::GeneratedRust;
use oxigraph::model::Term;
use std::collections::HashMap;
use std::fmt::Write;

pub fn generate(plan: &PlanIR) -> Result<String, String> {
    let modules = generate_modules(plan)?;
    Ok(modules.to_single_file())
}

pub fn generate_modules(plan: &PlanIR) -> Result<GeneratedRust, String> {
    let sections = generate_sections(plan)?;
    let mut files = Vec::new();
    let mut module_files = Vec::new();

    files.push(("prelude.rs".to_string(), sections.prelude));
    files.push(("helpers.rs".to_string(), sections.helpers));
    files.push(("paths.rs".to_string(), sections.paths));
    files.push(("shape_triples.rs".to_string(), sections.shape_triples));
    files.push(("shape_graph.nt".to_string(), sections.shape_graph_nt));
    files.push(("targets.rs".to_string(), sections.targets));
    files.push((
        "allowed_predicates.rs".to_string(),
        sections.allowed_predicates,
    ));
    files.push((
        "validators_property.rs".to_string(),
        sections.property_validators,
    ));
    files.push(("validators_node.rs".to_string(), sections.node_validators));
    files.push(("run.rs".to_string(), sections.run));

    for (name, _) in &files {
        if name.ends_with(".rs") {
            module_files.push(name.clone());
        }
    }

    let mut root = String::new();
    writeln!(root, "// Code generated by shacl-compiler. DO NOT EDIT.").unwrap();
    for name in &module_files {
        writeln!(root, "include!(\"{}\");", name).unwrap();
    }

    Ok(GeneratedRust { root, files })
}

struct Sections {
    prelude: String,
    helpers: String,
    paths: String,
    shape_triples: String,
    shape_graph_nt: String,
    targets: String,
    allowed_predicates: String,
    property_validators: String,
    node_validators: String,
    run: String,
}

fn generate_sections(plan: &PlanIR) -> Result<Sections, String> {
    let mut prelude = String::new();
    let mut helpers = String::new();
    let mut paths = String::new();
    let mut shape_triples = String::new();
    let mut shape_graph_nt = String::new();
    let mut targets = String::new();
    let mut allowed_predicates = String::new();
    let mut property_validators = String::new();
    let mut node_validators = String::new();
    let mut run = String::new();

    writeln!(prelude, "{}", "use oxigraph::model::{BlankNode, GraphName, GraphNameRef, Literal, NamedNode, NamedNodeRef, NamedOrBlankNode, NamedOrBlankNodeRef, Quad, Term, TermRef};").unwrap();
    writeln!(prelude, "{}", "use oxigraph::io::{RdfFormat, RdfParser};").unwrap();
    writeln!(prelude, "use oxigraph::store::Store;").unwrap();
    writeln!(
        prelude,
        "use oxigraph::sparql::{{QueryResults, SparqlEvaluator, Variable}};"
    )
    .unwrap();
    writeln!(
        prelude,
        "{}",
        "use std::collections::{HashMap, HashSet, VecDeque};"
    )
    .unwrap();
    writeln!(prelude, "use regex::Regex;").unwrap();
    writeln!(prelude, "").unwrap();

    let shape_graph_iri = term_iri(plan, plan.shape_graph)?;
    writeln!(
        prelude,
        "const RDF_TYPE: &str = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHAPE_GRAPH: &str = \"{}\";",
        escape_rust_string(&shape_graph_iri)
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_SELECT: &str = \"http://www.w3.org/ns/shacl#select\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_PREFIXES: &str = \"http://www.w3.org/ns/shacl#prefixes\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_DECLARE: &str = \"http://www.w3.org/ns/shacl#declare\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_PREFIX: &str = \"http://www.w3.org/ns/shacl#prefix\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_NAMESPACE: &str = \"http://www.w3.org/ns/shacl#namespace\";"
    )
    .unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "#[derive(Debug, Default)]").unwrap();
    writeln!(prelude, "{}", "pub struct Report {").unwrap();
    writeln!(prelude, "    pub violations: Vec<Violation>,").unwrap();
    writeln!(prelude, "{}", "}").unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "#[derive(Debug)]").unwrap();
    writeln!(prelude, "{}", "pub struct Violation {").unwrap();
    writeln!(prelude, "    pub shape_id: u64,").unwrap();
    writeln!(prelude, "    pub component_id: u64,").unwrap();
    writeln!(prelude, "    pub focus: Term,").unwrap();
    writeln!(prelude, "    pub value: Option<Term>,").unwrap();
    writeln!(prelude, "    pub path: Option<String>,").unwrap();
    writeln!(prelude, "{}", "}").unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "{}", "impl Report {").unwrap();
    writeln!(prelude, "    pub fn record(").unwrap();
    writeln!(prelude, "        &mut self,").unwrap();
    writeln!(prelude, "        shape_id: u64,").unwrap();
    writeln!(prelude, "        component_id: u64,").unwrap();
    writeln!(prelude, "        focus: &Term,").unwrap();
    writeln!(prelude, "        value: Option<&Term>,").unwrap();
    writeln!(prelude, "        path: Option<&str>,").unwrap();
    writeln!(prelude, "{}", "    ) {").unwrap();
    writeln!(prelude, "{}", "        self.violations.push(Violation {").unwrap();
    writeln!(prelude, "            shape_id,").unwrap();
    writeln!(prelude, "            component_id,").unwrap();
    writeln!(prelude, "            focus: focus.clone(),").unwrap();
    writeln!(prelude, "            value: value.cloned(),").unwrap();
    writeln!(prelude, "            path: path.map(|p| p.to_string()),").unwrap();
    writeln!(prelude, "{}", "        });").unwrap();
    writeln!(prelude, "{}", "    }").unwrap();
    writeln!(prelude, "{}", "    pub fn to_turtle(&self) -> String {").unwrap();
    writeln!(prelude, "        format_validation_report(self)").unwrap();
    writeln!(prelude, "{}", "    }").unwrap();
    writeln!(prelude, "{}", "}").unwrap();
    writeln!(prelude, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn graph_ref(graph: Option<&NamedNode>) -> Option<GraphNameRef<'_>> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    graph.map(|g| GraphNameRef::NamedNode(g.as_ref()))"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn shape_graph_ref() -> GraphNameRef<'static> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    GraphNameRef::NamedNode(NamedNodeRef::new(SHAPE_GRAPH).unwrap())"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn subject_ref(term: &Term) -> Option<NamedOrBlankNodeRef<'_>> {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::NamedNode(node) => Some(NamedOrBlankNodeRef::NamedNode(node.as_ref())),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::BlankNode(node) => Some(NamedOrBlankNodeRef::BlankNode(node.as_ref())),"
    )
    .unwrap();
    writeln!(helpers, "        _ => None,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "{}", "fn term_ref(term: &Term) -> TermRef<'_> {").unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::NamedNode(node) => TermRef::NamedNode(node.as_ref()),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::BlankNode(node) => TermRef::BlankNode(node.as_ref()),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => TermRef::Literal(lit.as_ref()),"
    )
    .unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn is_literal_with_datatype(term: &Term, datatype_iri: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => lit.datatype().as_str() == datatype_iri,"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn advanced_select_query(store: &Store, selector: &Term) -> Option<String> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let select_pred = NamedNodeRef::new(SHACL_SELECT).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(subject) = subject_ref(selector) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        for quad in store.quads_for_pattern(Some(subject), Some(select_pred), None, None) {").unwrap();
    writeln!(helpers, "{}", "            if let Ok(quad) = quad {").unwrap();
    writeln!(
        helpers,
        "{}",
        "                if let Term::Literal(lit) = quad.object {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    return Some(lit.value().to_string());"
    )
    .unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    for quad in store.quads_for_pattern(None, Some(select_pred), None, None) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        if let Ok(quad) = quad {").unwrap();
    writeln!(
        helpers,
        "{}",
        "            if let Term::Literal(lit) = quad.object {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                return Some(lit.value().to_string());"
    )
    .unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    None").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn prefixes_for_selector(store: &Store, selector: &Term) -> String {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_prefixes = NamedNodeRef::new(SHACL_PREFIXES).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_declare = NamedNodeRef::new(SHACL_DECLARE).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_prefix = NamedNodeRef::new(SHACL_PREFIX).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_namespace = NamedNodeRef::new(SHACL_NAMESPACE).unwrap();"
    )
    .unwrap();
    writeln!(helpers, "    let shape_graph = shape_graph_ref();").unwrap();
    writeln!(helpers, "    let mut subjects: Vec<Term> = Vec::new();").unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(subject) = subject_ref(selector) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        for quad in store.quads_for_pattern(Some(subject), Some(sh_prefixes), None, Some(shape_graph)) {").unwrap();
    writeln!(helpers, "{}", "            if let Ok(quad) = quad {").unwrap();
    writeln!(helpers, "                subjects.push(quad.object);").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    for quad in store.quads_for_pattern(None, Some(sh_declare), None, None) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        if let Ok(quad) = quad {").unwrap();
    writeln!(helpers, "            subjects.push(quad.subject.into());").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "    let mut prefixes: HashMap<String, String> = HashMap::new();"
    )
    .unwrap();
    writeln!(helpers, "{}", "    for subject_term in subjects {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        let subject_node = match subject_ref(&subject_term) {"
    )
    .unwrap();
    writeln!(helpers, "            Some(value) => value,").unwrap();
    writeln!(helpers, "            None => continue,").unwrap();
    writeln!(helpers, "{}", "        };").unwrap();
    writeln!(helpers, "{}", "        for quad in store.quads_for_pattern(Some(subject_node), Some(sh_declare), None, None) {").unwrap();
    writeln!(
        helpers,
        "{}",
        "            let quad = match quad { Ok(q) => q, Err(_) => continue };"
    )
    .unwrap();
    writeln!(helpers, "            let decl_term = quad.object;").unwrap();
    writeln!(
        helpers,
        "{}",
        "            let decl_ref = match subject_ref(&decl_term) {"
    )
    .unwrap();
    writeln!(helpers, "                Some(value) => value,").unwrap();
    writeln!(helpers, "                None => continue,").unwrap();
    writeln!(helpers, "{}", "            };").unwrap();
    writeln!(
        helpers,
        "    let prefix_val = store.quads_for_pattern(Some(decl_ref), Some(sh_prefix), None, None)"
    )
    .unwrap();
    writeln!(helpers, "        .filter_map(Result::ok)").unwrap();
    writeln!(helpers, "        .map(|q| q.object)").unwrap();
    writeln!(helpers, "        .next();").unwrap();
    writeln!(helpers, "    let namespace_val = store.quads_for_pattern(Some(decl_ref), Some(sh_namespace), None, None)").unwrap();
    writeln!(helpers, "        .filter_map(Result::ok)").unwrap();
    writeln!(helpers, "        .map(|q| q.object)").unwrap();
    writeln!(helpers, "        .next();").unwrap();
    writeln!(helpers, "{}", "            if let (Some(Term::Literal(prefix_lit)), Some(Term::Literal(ns_lit))) = (prefix_val, namespace_val) {").unwrap();
    writeln!(
        helpers,
        "                let prefix = prefix_lit.value().to_string();"
    )
    .unwrap();
    writeln!(
        helpers,
        "                let namespace = ns_lit.value().to_string();"
    )
    .unwrap();
    writeln!(
        helpers,
        "                prefixes.insert(prefix, namespace);"
    )
    .unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if prefixes.is_empty() {").unwrap();
    writeln!(helpers, "        return String::new();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "    let mut keys: Vec<String> = prefixes.keys().cloned().collect();"
    )
    .unwrap();
    writeln!(helpers, "    keys.sort();").unwrap();
    writeln!(helpers, "    let mut out = String::new();").unwrap();
    writeln!(helpers, "{}", "    for key in keys {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if let Some(ns) = prefixes.get(&key) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            out.push_str(&format!(\"PREFIX {}: <{}>\\n\", key, ns));"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    out").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn advanced_targets_for(store: &Store, selector: &Term) -> Vec<Term> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let query = match advanced_select_query(store, selector) {"
    )
    .unwrap();
    writeln!(helpers, "        Some(value) => value,").unwrap();
    writeln!(helpers, "        None => return Vec::new(),").unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(
        helpers,
        "    let prefixes = prefixes_for_selector(store, selector);"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let query_str = if prefixes.trim().is_empty() {"
    )
    .unwrap();
    writeln!(helpers, "        query.clone()").unwrap();
    writeln!(helpers, "{}", "    } else {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        format!(\"{}\\n{}\", prefixes, query)"
    )
    .unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut prepared = match SparqlEvaluator::new().parse_query(&query_str) {"
    )
    .unwrap();
    writeln!(helpers, "        Ok(prepared) => prepared,").unwrap();
    writeln!(helpers, "        Err(_) => return Vec::new(),").unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(
        helpers,
        "    prepared.dataset_mut().set_default_graph_as_union();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let mut results: HashSet<Term> = HashSet::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    match prepared.on_store(store).execute() {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        Ok(QueryResults::Solutions(solutions)) => {"
    )
    .unwrap();
    writeln!(helpers, "{}", "            for solution in solutions {").unwrap();
    writeln!(
        helpers,
        "{}",
        "                let solution = match solution { Ok(sol) => sol, Err(_) => continue };"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                if let Some(value) = solution.get(\"this\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    results.insert(value.to_owned());"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                } else if let Some(value) = solution.get(\"target\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    results.insert(value.to_owned());"
    )
    .unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "        _ => {}").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    results.into_iter().collect()").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn has_rdf_type(store: &Store, graph: Option<GraphNameRef<'_>>, term: &Term, class_iri: &str) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let subject = match subject_ref(term) { Some(s) => s, None => return false };"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let rdf_type = NamedNodeRef::new(RDF_TYPE).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let class_ref = NamedNodeRef::new(class_iri).unwrap();"
    )
    .unwrap();
    writeln!(helpers, "    store.quads_for_pattern(Some(subject), Some(rdf_type), Some(TermRef::NamedNode(class_ref)), graph).any(|q| q.is_ok())").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn matches_node_kind(term: &Term, node_kind_iri: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match node_kind_iri {").unwrap();
    writeln!(
        helpers,
        "        \"http://www.w3.org/ns/shacl#IRI\" => matches!(term, Term::NamedNode(_)),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        \"http://www.w3.org/ns/shacl#BlankNode\" => matches!(term, Term::BlankNode(_)),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        \"http://www.w3.org/ns/shacl#Literal\" => matches!(term, Term::Literal(_)),"
    )
    .unwrap();
    writeln!(helpers, "        \"http://www.w3.org/ns/shacl#BlankNodeOrIRI\" => matches!(term, Term::BlankNode(_) | Term::NamedNode(_)),").unwrap();
    writeln!(helpers, "        \"http://www.w3.org/ns/shacl#BlankNodeOrLiteral\" => matches!(term, Term::BlankNode(_) | Term::Literal(_)),").unwrap();
    writeln!(helpers, "        \"http://www.w3.org/ns/shacl#IRIOrLiteral\" => matches!(term, Term::NamedNode(_) | Term::Literal(_)),").unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn literal_length_at_least(term: &Term, min: u64) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => (lit.value().chars().count() as u64) >= min,"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn literal_length_at_most(term: &Term, max: u64) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => (lit.value().chars().count() as u64) <= max,"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn literal_matches_regex(term: &Term, regex: &Regex) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => regex.is_match(lit.value()),"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn lang_matches(tag: &str, range: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    if range == \"*\" {").unwrap();
    writeln!(helpers, "        return !tag.is_empty();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    let tag_lower = tag.to_lowercase();").unwrap();
    writeln!(helpers, "    let range_lower = range.to_lowercase();").unwrap();
    writeln!(helpers, "{}", "    if tag_lower == range_lower {").unwrap();
    writeln!(helpers, "        return true;").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    if range_lower.chars().all(|c| c.is_ascii_alphanumeric() || c == '-') {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        if tag_lower.starts_with(&format!(\"{}-\", range_lower)) {"
    )
    .unwrap();
    writeln!(helpers, "            return true;").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    false").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn language_in_allowed(term: &Term, allowed: &[&str]) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(helpers, "{}", "        Term::Literal(lit) => {").unwrap();
    writeln!(
        helpers,
        "            let lang = lit.language().unwrap_or(\"\");"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            if allowed.is_empty() { return false; }"
    )
    .unwrap();
    writeln!(
        helpers,
        "            allowed.iter().any(|range| lang_matches(lang, range))"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn values_for_predicate(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term, predicate_iri: &str) -> Vec<Term> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let subject = match subject_ref(focus) { Some(s) => s, None => return Vec::new() };"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let predicate = NamedNodeRef::new(predicate_iri).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    store.quads_for_pattern(Some(subject), Some(predicate), None, graph).filter_map(Result::ok).map(|q| q.object).collect()"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(helpers, "{}", "fn term_to_sparql(term: &Term) -> String {").unwrap();
    writeln!(helpers, "    term.to_string()").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn query_mentions_var(query: &str, var: &str) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    fn contains(query: &str, prefix: char, var: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "        let mut start = 0;").unwrap();
    writeln!(helpers, "        let bytes = query.as_bytes();").unwrap();
    writeln!(helpers, "        let var_bytes = var.as_bytes();").unwrap();
    writeln!(
        helpers,
        "{}",
        "        while let Some(pos) = query[start..].find(prefix) {"
    )
    .unwrap();
    writeln!(helpers, "            let idx = start + pos + 1;").unwrap();
    writeln!(helpers, "{}", "            if bytes.len() >= idx + var_bytes.len() && &bytes[idx..idx + var_bytes.len()] == var_bytes {").unwrap();
    writeln!(
        helpers,
        "                let after = idx + var_bytes.len();"
    )
    .unwrap();
    writeln!(helpers, "{}", "                if after >= bytes.len() {").unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "                let next = bytes[after] as char;").unwrap();
    writeln!(
        helpers,
        "{}",
        "                if !next.is_ascii_alphanumeric() && next != '_' {"
    )
    .unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "            start += pos + 1;").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "        false").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "    contains(query, '?', var) || contains(query, '$', var)"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn sparql_any_solution(query: &str, store: &Store, focus: Option<&Term>, value: Option<&Term>) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let mut prepared = SparqlEvaluator::new().parse_query(query).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    prepared.dataset_mut().set_default_graph_as_union();"
    )
    .unwrap();
    writeln!(helpers, "    let mut bound = prepared.on_store(store);").unwrap();
    writeln!(helpers, "{}", "    if let Some(focus) = focus {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if query_mentions_var(query, \"this\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "            bound = bound.substitute_variable(Variable::new_unchecked(\"this\"), focus.clone());"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if let Some(value) = value {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if query_mentions_var(query, \"value\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "            bound = bound.substitute_variable(Variable::new_unchecked(\"value\"), value.clone());"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    match bound.execute() {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        Ok(QueryResults::Solutions(solutions)) => {"
    )
    .unwrap();
    writeln!(helpers, "{}", "            for result in solutions {").unwrap();
    writeln!(helpers, "{}", "                if result.is_ok() {").unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "            false").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "        Ok(QueryResults::Boolean(val)) => val,").unwrap();
    writeln!(helpers, "        Ok(QueryResults::Graph(_)) => false,").unwrap();
    writeln!(helpers, "        Err(_) => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    emit_shape_and_component_maps(&mut helpers, plan)?;
    emit_validation_report_helpers(&mut helpers)?;

    emit_path_functions(&mut paths, plan)?;
    emit_shape_triples(&mut shape_triples, &mut shape_graph_nt, plan)?;

    let component_lookup: HashMap<CompId, _> = plan.components.iter().map(|c| (c.id, c)).collect();
    let node_shape_lookup: HashMap<u64, _> = plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Node)
        .map(|s| (s.id, s))
        .collect();
    let property_shape_lookup: HashMap<u64, _> = plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Property)
        .map(|s| (s.id, s))
        .collect();

    let term_iri = |term_id: u64| term_iri(plan, term_id);
    let term_expr = |term_id: u64| term_expr_id(plan, term_id);
    let term_sparql = |term_id: u64| term_sparql_const(plan, term_id);

    let qualified_siblings = build_qualified_sibling_map(plan, &component_lookup);
    let allowed_predicate_map =
        build_allowed_predicate_map(plan, &component_lookup, &property_shape_lookup)?;

    // Property shape validators.
    for shape in plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Property)
    {
        if shape.deactivated {
            continue;
        }
        let path_id = shape
            .path
            .ok_or_else(|| format!("Property shape {} missing path", shape.id))?;
        let path_display = path_to_string(plan, path_id)?;

        let mut emission = PropertyEmission::default();
        for component_id in &shape.constraints {
            let component = component_lookup
                .get(component_id)
                .ok_or_else(|| format!("Missing component {}", component_id))?;
            let handler = registry::lookup(component.kind);
            let sibling_list = if component.kind == ComponentKind::QualifiedValueShape {
                Some(
                    qualified_siblings
                        .get(&component.id)
                        .map(|v| v.as_slice())
                        .unwrap_or(&[]),
                )
            } else {
                None
            };
            let ctx = EmitContext {
                shape_id: shape.id,
                component_id: component.id,
                kind: component.kind,
                path_iri: Some(&path_display),
                term_iri: &term_iri,
                term_expr: &term_expr,
                term_sparql: &term_sparql,
                qualified_siblings: sibling_list,
            };
            let component_emission = handler.emit_property(ctx, &component.params)?;
            emission.merge(component_emission);
        }

        writeln!(
            property_validators,
            "fn validate_property_shape_{}_for_focus(",
            shape.id
        )
        .unwrap();
        writeln!(property_validators, "    store: &Store,").unwrap();
        writeln!(property_validators, "    graph: Option<GraphNameRef<'_>>,").unwrap();
        writeln!(property_validators, "    focus: &Term,").unwrap();
        writeln!(property_validators, "    report: &mut Report,").unwrap();
        writeln!(property_validators, "{}", ") {").unwrap();
        writeln!(
            property_validators,
            "    let values = path_{}(store, graph, focus);",
            path_id
        )
        .unwrap();
        if emission.needs_count {
            writeln!(
                property_validators,
                "    let count: u64 = values.len() as u64;"
            )
            .unwrap();
        }
        for line in &emission.pre_loop_lines {
            writeln!(property_validators, "{}", line).unwrap();
        }
        if !emission.per_value_lines.is_empty() {
            writeln!(
                property_validators,
                "{}",
                "    for value in values.iter().cloned() {"
            )
            .unwrap();
            for line in &emission.per_value_lines {
                writeln!(property_validators, "{}", line).unwrap();
            }
            writeln!(property_validators, "{}", "    }").unwrap();
        }
        for line in &emission.post_loop_lines {
            writeln!(property_validators, "{}", line).unwrap();
        }
        writeln!(property_validators, "{}", "}").unwrap();
        writeln!(property_validators, "").unwrap();

        if !shape.targets.is_empty() {
            emit_target_collector(&mut targets, shape, &term_iri, &term_expr)?;
            writeln!(property_validators, "pub fn validate_property_shape_{}(store: &Store, graph: Option<GraphNameRef<'_>>, report: &mut Report) {{", shape.id).unwrap();
            writeln!(
                property_validators,
                "    let targets = collect_targets_prop_{}(store, graph);",
                shape.id
            )
            .unwrap();
            writeln!(property_validators, "{}", "    for focus in targets {").unwrap();
            writeln!(
                property_validators,
                "        validate_property_shape_{}_for_focus(store, graph, &focus, report);",
                shape.id
            )
            .unwrap();
            writeln!(property_validators, "{}", "    }").unwrap();
            writeln!(property_validators, "{}", "}").unwrap();
            writeln!(property_validators, "").unwrap();
        }
    }

    // Node shape validators.
    for shape in plan.shapes.iter().filter(|s| s.kind == PlanShapeKind::Node) {
        let has_closed = shape.constraints.iter().any(|comp_id| {
            component_lookup
                .get(comp_id)
                .map(|c| c.kind == ComponentKind::Closed)
                .unwrap_or(false)
        });
        if has_closed {
            let preds = allowed_predicate_map
                .get(&shape.id)
                .cloned()
                .unwrap_or_default();
            writeln!(
                allowed_predicates,
                "fn allowed_predicates_{}() -> HashSet<String> {{",
                shape.id
            )
            .unwrap();
            writeln!(
                allowed_predicates,
                "    let mut set: HashSet<String> = HashSet::new();"
            )
            .unwrap();
            for pred in preds {
                writeln!(
                    allowed_predicates,
                    "    set.insert(\"{}\".to_string());",
                    escape_rust_string(&pred)
                )
                .unwrap();
            }
            writeln!(allowed_predicates, "    set").unwrap();
            writeln!(allowed_predicates, "{}", "}").unwrap();
            writeln!(allowed_predicates, "").unwrap();
        }
    }

    // Node shape validators.
    for shape in plan.shapes.iter().filter(|s| s.kind == PlanShapeKind::Node) {
        if shape.deactivated {
            continue;
        }
        emit_target_collector(&mut targets, shape, &term_iri, &term_expr)?;

        writeln!(node_validators, "fn validate_node_shape_{}_for_focus(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term, report: &mut Report) {{", shape.id).unwrap();
        for component_id in &shape.constraints {
            let component = component_lookup
                .get(component_id)
                .ok_or_else(|| format!("Missing component {}", component_id))?;
            let handler = registry::lookup(component.kind);
            let ctx = EmitContext {
                shape_id: shape.id,
                component_id: component.id,
                kind: component.kind,
                path_iri: None,
                term_iri: &term_iri,
                term_expr: &term_expr,
                term_sparql: &term_sparql,
                qualified_siblings: None,
            };
            let emission = handler.emit_node(ctx, &component.params)?;
            for line in emission.lines {
                writeln!(node_validators, "{}", line).unwrap();
            }
        }
        writeln!(node_validators, "{}", "}").unwrap();
        writeln!(node_validators, "").unwrap();

        writeln!(node_validators, "fn node_shape_conforms_{}(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term) -> bool {{", shape.id).unwrap();
        writeln!(node_validators, "    let mut report = Report::default();").unwrap();
        writeln!(
            node_validators,
            "    validate_node_shape_{}_for_focus(store, graph, focus, &mut report);",
            shape.id
        )
        .unwrap();
        writeln!(node_validators, "    report.violations.is_empty()").unwrap();
        writeln!(node_validators, "{}", "}").unwrap();
        writeln!(node_validators, "").unwrap();

        writeln!(node_validators, "pub fn validate_node_shape_{}(store: &Store, graph: Option<GraphNameRef<'_>>, report: &mut Report) {{", shape.id).unwrap();
        writeln!(
            node_validators,
            "    let targets = collect_targets_node_{}(store, graph);",
            shape.id
        )
        .unwrap();
        writeln!(node_validators, "{}", "    for focus in targets {").unwrap();
        writeln!(
            node_validators,
            "        validate_node_shape_{}_for_focus(store, graph, &focus, report);",
            shape.id
        )
        .unwrap();
        writeln!(node_validators, "{}", "    }").unwrap();
        writeln!(node_validators, "{}", "}").unwrap();
        writeln!(node_validators, "").unwrap();
    }

    writeln!(
        run,
        "{}",
        "pub fn run(store: &Store, data_graph: Option<&NamedNode>) -> Report {"
    )
    .unwrap();
    writeln!(run, "    let graph = graph_ref(data_graph);").unwrap();
    writeln!(run, "    let mut report = Report::default();").unwrap();
    writeln!(run, "    insert_shape_triples(store);").unwrap();
    writeln!(
        run,
        "    run_inference(store, graph); // inference stage placeholder"
    )
    .unwrap();
    for shape_id in &plan.order.node_shapes {
        let shape = node_shape_lookup
            .get(shape_id)
            .ok_or_else(|| format!("Missing node shape {}", shape_id))?;
        if shape.deactivated {
            continue;
        }
        writeln!(
            run,
            "    validate_node_shape_{}(store, graph, &mut report);",
            shape.id
        )
        .unwrap();
    }
    for shape_id in &plan.order.property_shapes {
        let shape = property_shape_lookup
            .get(shape_id)
            .ok_or_else(|| format!("Missing property shape {}", shape_id))?;
        if shape.deactivated || shape.targets.is_empty() {
            continue;
        }
        writeln!(
            run,
            "    validate_property_shape_{}(store, graph, &mut report);",
            shape.id
        )
        .unwrap();
    }
    writeln!(run, "    report").unwrap();
    writeln!(run, "{}", "}").unwrap();
    writeln!(run, "").unwrap();
    writeln!(
        run,
        "{}",
        "fn run_inference(_store: &Store, _graph: Option<GraphNameRef<'_>>) {"
    )
    .unwrap();
    writeln!(
        run,
        "    // Inference rules will be compiled here once plan IR includes rule stages."
    )
    .unwrap();
    writeln!(run, "{}", "}").unwrap();

    Ok(Sections {
        prelude,
        helpers,
        paths,
        shape_triples,
        shape_graph_nt,
        targets,
        allowed_predicates,
        property_validators,
        node_validators,
        run,
    })
}

fn emit_target_collector(
    out: &mut String,
    shape: &PlanShape,
    term_iri: &dyn Fn(u64) -> Result<String, String>,
    term_expr: &dyn Fn(u64) -> Result<String, String>,
) -> Result<(), String> {
    let func_prefix = match shape.kind {
        PlanShapeKind::Node => "node",
        PlanShapeKind::Property => "prop",
    };
    writeln!(
        out,
        "fn collect_targets_{}_{}(store: &Store, graph: Option<GraphNameRef<'_>>) -> Vec<Term> {{",
        func_prefix, shape.id
    )
    .unwrap();
    writeln!(out, "    let mut seen: HashSet<Term> = HashSet::new();").unwrap();
    writeln!(out, "    let mut out: Vec<Term> = Vec::new();").unwrap();
    writeln!(
        out,
        "    let rdf_type = NamedNodeRef::new(RDF_TYPE).unwrap();"
    )
    .unwrap();
    for target in &shape.targets {
        match target {
            PlanTarget::Class(term_id) => {
                let class_iri = term_iri(*term_id)?;
                writeln!(
                    out,
                    "    let class_ref = NamedNodeRef::new(\"{}\").unwrap();",
                    class_iri
                )
                .unwrap();
                writeln!(out, "{}", "    for quad in store.quads_for_pattern(None, Some(rdf_type), Some(TermRef::NamedNode(class_ref)), graph) {").unwrap();
                writeln!(
                    out,
                    "{}",
                    "        let quad = match quad { Ok(quad) => quad, Err(_) => continue };"
                )
                .unwrap();
                writeln!(out, "        let focus: Term = quad.subject.into();").unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::Node(term_id) => {
                let node_expr = term_expr(*term_id)?;
                writeln!(out, "{}", "    {").unwrap();
                writeln!(out, "        let focus: Term = {};", node_expr).unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::SubjectsOf(term_id) => {
                let pred_iri = term_iri(*term_id)?;
                writeln!(
                    out,
                    "    let pred_ref = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "    for quad in store.quads_for_pattern(None, Some(pred_ref), None, graph) {"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "        let quad = match quad { Ok(quad) => quad, Err(_) => continue };"
                )
                .unwrap();
                writeln!(out, "        let focus: Term = quad.subject.into();").unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::ObjectsOf(term_id) => {
                let pred_iri = term_iri(*term_id)?;
                writeln!(
                    out,
                    "    let pred_ref = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "    for quad in store.quads_for_pattern(None, Some(pred_ref), None, graph) {"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "        let quad = match quad { Ok(quad) => quad, Err(_) => continue };"
                )
                .unwrap();
                writeln!(out, "        let focus: Term = quad.object;").unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::Advanced(term_id) => {
                let selector_expr = term_expr(*term_id)?;
                writeln!(out, "{}", "    {").unwrap();
                writeln!(out, "        let selector: Term = {};", selector_expr).unwrap();
                writeln!(
                    out,
                    "{}",
                    "        for focus in advanced_targets_for(store, &selector) {"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "            if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "        }").unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
        }
    }
    writeln!(out, "    out").unwrap();
    writeln!(out, "{}", "}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn term_iri(plan: &PlanIR, term_id: u64) -> Result<String, String> {
    let term = plan
        .terms
        .get(term_id as usize)
        .ok_or_else(|| format!("Unknown term id {}", term_id))?;
    match term {
        Term::NamedNode(node) => Ok(node.as_str().to_string()),
        _ => Err("Expected NamedNode term".to_string()),
    }
}

fn path_to_string(plan: &PlanIR, path_id: u64) -> Result<String, String> {
    path_to_string_inner(plan, path_id, false)
}

fn path_to_string_inner(plan: &PlanIR, path_id: u64, wrap: bool) -> Result<String, String> {
    let path = plan
        .paths
        .get(path_id as usize)
        .ok_or_else(|| format!("Unknown path id {}", path_id))?;
    let rendered = match path {
        PlanPath::Simple(term_id) => term_iri(plan, *term_id)?,
        PlanPath::Inverse(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("^{}", inner_str)
        }
        PlanPath::Sequence(paths) => {
            let mut parts = Vec::with_capacity(paths.len());
            for id in paths {
                parts.push(path_to_string_inner(plan, *id, true)?);
            }
            parts.join("/")
        }
        PlanPath::Alternative(paths) => {
            let mut parts = Vec::with_capacity(paths.len());
            for id in paths {
                parts.push(path_to_string_inner(plan, *id, true)?);
            }
            parts.join("|")
        }
        PlanPath::ZeroOrMore(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("{}*", inner_str)
        }
        PlanPath::OneOrMore(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("{}+", inner_str)
        }
        PlanPath::ZeroOrOne(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("{}?", inner_str)
        }
    };
    if wrap && !matches!(path, PlanPath::Simple(_)) {
        Ok(format!("({})", rendered))
    } else {
        Ok(rendered)
    }
}

fn simple_predicate(plan: &PlanIR, path_id: u64) -> Result<String, String> {
    let path = plan
        .paths
        .get(path_id as usize)
        .ok_or_else(|| format!("Unknown path id {}", path_id))?;
    match path {
        PlanPath::Simple(term_id) => term_iri(plan, *term_id),
        _ => Err("Only simple predicate paths are supported here".to_string()),
    }
}

fn emit_path_functions(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    if plan.paths.is_empty() {
        return Ok(());
    }
    for (id, path) in plan.paths.iter().enumerate() {
        emit_path_function(out, plan, id as u64, path, false)?;
        emit_path_function(out, plan, id as u64, path, true)?;
    }
    Ok(())
}

fn emit_path_function(
    out: &mut String,
    plan: &PlanIR,
    path_id: u64,
    path: &PlanPath,
    reverse: bool,
) -> Result<(), String> {
    let func_name = if reverse {
        format!("path_{}_rev", path_id)
    } else {
        format!("path_{}", path_id)
    };
    writeln!(
        out,
        "fn {}(store: &Store, graph: Option<GraphNameRef<'_>>, start: &Term) -> Vec<Term> {{",
        func_name
    )
    .unwrap();
    match path {
        PlanPath::Simple(term_id) => {
            let pred_iri = term_iri(plan, *term_id)?;
            let pred_iri = escape_rust_string(&pred_iri);
            if reverse {
                writeln!(
                    out,
                    "    let predicate = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(out, "    let object = term_ref(start);").unwrap();
                writeln!(
                    out,
                    "{}",
                    "    store.quads_for_pattern(None, Some(predicate), Some(object), graph)"
                )
                .unwrap();
                writeln!(out, "        .filter_map(Result::ok)").unwrap();
                writeln!(out, "        .map(|q| q.subject.into())").unwrap();
                writeln!(out, "        .collect()").unwrap();
            } else {
                writeln!(out, "{}", "    let subject = match subject_ref(start) { Some(s) => s, None => return Vec::new() };").unwrap();
                writeln!(
                    out,
                    "    let predicate = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "    store.quads_for_pattern(Some(subject), Some(predicate), None, graph)"
                )
                .unwrap();
                writeln!(out, "        .filter_map(Result::ok)").unwrap();
                writeln!(out, "        .map(|q| q.object)").unwrap();
                writeln!(out, "        .collect()").unwrap();
            }
        }
        PlanPath::Inverse(inner) => {
            if reverse {
                writeln!(out, "    path_{}(store, graph, start)", inner).unwrap();
            } else {
                writeln!(out, "    path_{}_rev(store, graph, start)", inner).unwrap();
            }
        }
        PlanPath::Sequence(paths) => {
            writeln!(
                out,
                "{}",
                "    let mut current: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(out, "    current.insert(start.clone());").unwrap();
            let ids: Vec<u64> = if reverse {
                paths.iter().rev().cloned().collect()
            } else {
                paths.clone()
            };
            for id in ids {
                writeln!(
                    out,
                    "{}",
                    "    let mut next: HashSet<Term> = HashSet::new();"
                )
                .unwrap();
                writeln!(out, "{}", "    for node in current {").unwrap();
                if reverse {
                    writeln!(
                        out,
                        "        for value in path_{}_rev(store, graph, &node) {{",
                        id
                    )
                    .unwrap();
                } else {
                    writeln!(
                        out,
                        "        for value in path_{}(store, graph, &node) {{",
                        id
                    )
                    .unwrap();
                }
                writeln!(out, "            next.insert(value);").unwrap();
                writeln!(out, "{}", "        }").unwrap();
                writeln!(out, "{}", "    }").unwrap();
                writeln!(out, "    current = next;").unwrap();
                writeln!(
                    out,
                    "{}",
                    "    if current.is_empty() { return Vec::new(); }"
                )
                .unwrap();
            }
            writeln!(out, "    current.into_iter().collect()").unwrap();
        }
        PlanPath::Alternative(paths) => {
            writeln!(
                out,
                "{}",
                "    let mut out_set: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            for id in paths {
                if reverse {
                    writeln!(
                        out,
                        "    for value in path_{}_rev(store, graph, start) {{",
                        id
                    )
                    .unwrap();
                } else {
                    writeln!(out, "    for value in path_{}(store, graph, start) {{", id).unwrap();
                }
                writeln!(out, "        out_set.insert(value);").unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            writeln!(out, "    out_set.into_iter().collect()").unwrap();
        }
        PlanPath::ZeroOrMore(inner) => {
            writeln!(
                out,
                "{}",
                "    let mut seen: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(
                out,
                "{}",
                "    let mut queue: VecDeque<Term> = VecDeque::new();"
            )
            .unwrap();
            writeln!(out, "    seen.insert(start.clone());").unwrap();
            writeln!(out, "    queue.push_back(start.clone());").unwrap();
            writeln!(out, "{}", "    while let Some(node) = queue.pop_front() {").unwrap();
            if reverse {
                writeln!(
                    out,
                    "        for value in path_{}_rev(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "        for value in path_{}(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "{}", "            if seen.insert(value.clone()) {").unwrap();
            writeln!(out, "                queue.push_back(value);").unwrap();
            writeln!(out, "{}", "            }").unwrap();
            writeln!(out, "{}", "        }").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "    seen.into_iter().collect()").unwrap();
        }
        PlanPath::OneOrMore(inner) => {
            writeln!(
                out,
                "{}",
                "    let mut seen: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(
                out,
                "{}",
                "    let mut queue: VecDeque<Term> = VecDeque::new();"
            )
            .unwrap();
            if reverse {
                writeln!(
                    out,
                    "    for value in path_{}_rev(store, graph, start) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "    for value in path_{}(store, graph, start) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "{}", "        if seen.insert(value.clone()) {").unwrap();
            writeln!(out, "            queue.push_back(value);").unwrap();
            writeln!(out, "{}", "        }").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "{}", "    while let Some(node) = queue.pop_front() {").unwrap();
            if reverse {
                writeln!(
                    out,
                    "        for value in path_{}_rev(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "        for value in path_{}(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "{}", "            if seen.insert(value.clone()) {").unwrap();
            writeln!(out, "                queue.push_back(value);").unwrap();
            writeln!(out, "{}", "            }").unwrap();
            writeln!(out, "{}", "        }").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "    seen.into_iter().collect()").unwrap();
        }
        PlanPath::ZeroOrOne(inner) => {
            writeln!(
                out,
                "{}",
                "    let mut out_set: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(out, "    out_set.insert(start.clone());").unwrap();
            if reverse {
                writeln!(
                    out,
                    "    for value in path_{}_rev(store, graph, start) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "    for value in path_{}(store, graph, start) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "        out_set.insert(value);").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "    out_set.into_iter().collect()").unwrap();
        }
    }
    writeln!(out, "{}", "}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_shape_triples(
    out: &mut String,
    shape_graph_nt: &mut String,
    plan: &PlanIR,
) -> Result<(), String> {
    let shape_graph_iri = term_iri(plan, plan.shape_graph)?;
    for triple in &plan.shape_triples {
        let subject_term = plan
            .terms
            .get(triple.subject as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.subject))?;
        let predicate_term = plan
            .terms
            .get(triple.predicate as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.predicate))?;
        let object_term = plan
            .terms
            .get(triple.object as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.object))?;
        let subj_nt = term_to_nt(subject_term)?;
        let pred_nt = term_to_nt(predicate_term)?;
        let obj_nt = term_to_nt(object_term)?;
        writeln!(shape_graph_nt, "{} {} {} .", subj_nt, pred_nt, obj_nt).unwrap();
    }

    writeln!(
        out,
        "{}",
        "const SHAPE_GRAPH_NT: &str = include_str!(\"shape_graph.nt\");"
    )
    .unwrap();
    writeln!(out, "{}", "fn insert_shape_triples(store: &Store) {").unwrap();
    writeln!(
        out,
        "    let shape_graph = GraphName::NamedNode(NamedNode::new(\"{}\").unwrap());",
        escape_rust_string(&shape_graph_iri)
    )
    .unwrap();
    writeln!(
        out,
        "    let parser = RdfParser::from_format(RdfFormat::NTriples).for_slice(SHAPE_GRAPH_NT.as_bytes());"
    )
    .unwrap();
    writeln!(out, "{}", "    for triple in parser {").unwrap();
    writeln!(
        out,
        "{}",
        "        let triple = match triple { Ok(t) => t, Err(_) => continue };"
    )
    .unwrap();
    writeln!(out, "        let quad = Quad::new(triple.subject, triple.predicate, triple.object, shape_graph.clone());").unwrap();
    writeln!(out, "        let _ = store.insert(quad.as_ref());").unwrap();
    writeln!(out, "{}", "    }").unwrap();
    writeln!(out, "{}", "}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn term_expr_id(plan: &PlanIR, term_id: u64) -> Result<String, String> {
    let term = plan
        .terms
        .get(term_id as usize)
        .ok_or_else(|| format!("Unknown term id {}", term_id))?;
    term_expr(term)
}

fn term_sparql_const(plan: &PlanIR, term_id: u64) -> Result<String, String> {
    let term = plan
        .terms
        .get(term_id as usize)
        .ok_or_else(|| format!("Unknown term id {}", term_id))?;
    Ok(term.to_string())
}

fn build_qualified_sibling_map(
    plan: &PlanIR,
    component_lookup: &HashMap<CompId, &crate::plan::PlanComponent>,
) -> HashMap<CompId, Vec<u64>> {
    let mut prop_shapes_by_node: HashMap<u64, Vec<u64>> = HashMap::new();
    for shape in &plan.shapes {
        if shape.kind != PlanShapeKind::Node {
            continue;
        }
        let mut props = Vec::new();
        for comp_id in &shape.constraints {
            if let Some(component) = component_lookup.get(comp_id) {
                if component.kind == ComponentKind::Property {
                    if let crate::plan::ComponentParams::Property { shape } = component.params {
                        props.push(shape);
                    }
                }
            }
        }
        prop_shapes_by_node.insert(shape.id, props);
    }

    let mut qualified_by_prop: HashMap<u64, Vec<(CompId, u64)>> = HashMap::new();
    for shape in &plan.shapes {
        if shape.kind != PlanShapeKind::Property {
            continue;
        }
        let mut comps = Vec::new();
        for comp_id in &shape.constraints {
            if let Some(component) = component_lookup.get(comp_id) {
                if component.kind == ComponentKind::QualifiedValueShape {
                    if let crate::plan::ComponentParams::QualifiedValueShape { shape, .. } =
                        component.params
                    {
                        comps.push((component.id, shape));
                    }
                }
            }
        }
        if !comps.is_empty() {
            qualified_by_prop.insert(shape.id, comps);
        }
    }

    let mut siblings: HashMap<CompId, Vec<u64>> = HashMap::new();
    for (_, props) in prop_shapes_by_node {
        let mut all: Vec<(CompId, u64)> = Vec::new();
        for prop_id in props {
            if let Some(list) = qualified_by_prop.get(&prop_id) {
                all.extend(list.iter().cloned());
            }
        }
        for (comp_id, _) in &all {
            let mut sibs = Vec::new();
            for (other_id, shape_id) in &all {
                if other_id == comp_id {
                    continue;
                }
                sibs.push(*shape_id);
            }
            siblings.insert(*comp_id, sibs);
        }
    }

    siblings
}

fn build_allowed_predicate_map(
    plan: &PlanIR,
    component_lookup: &HashMap<CompId, &crate::plan::PlanComponent>,
    property_shape_lookup: &HashMap<u64, &PlanShape>,
) -> Result<HashMap<u64, Vec<String>>, String> {
    let mut allowed: HashMap<u64, Vec<String>> = HashMap::new();
    for shape in plan.shapes.iter().filter(|s| s.kind == PlanShapeKind::Node) {
        let mut predicates = Vec::new();
        for comp_id in &shape.constraints {
            if let Some(component) = component_lookup.get(comp_id) {
                if component.kind == ComponentKind::Property {
                    if let crate::plan::ComponentParams::Property { shape: prop_id } =
                        component.params
                    {
                        if let Some(prop_shape) = property_shape_lookup.get(&prop_id) {
                            if let Some(path_id) = prop_shape.path {
                                if let Ok(iri) = simple_predicate(plan, path_id) {
                                    predicates.push(iri);
                                }
                            }
                        }
                    }
                }
            }
        }
        allowed.insert(shape.id, predicates);
    }
    Ok(allowed)
}

fn subject_expr(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!(
            "NamedOrBlankNode::NamedNode(NamedNode::new(\"{}\").unwrap())",
            escape_rust_string(node.as_str())
        )),
        Term::BlankNode(node) => Ok(format!(
            "NamedOrBlankNode::BlankNode(BlankNode::new_unchecked(\"{}\"))",
            escape_rust_string(node.as_str())
        )),
        _ => Err("Invalid subject term for shape triple".to_string()),
    }
}

fn named_node_expr(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!(
            "NamedNode::new(\"{}\").unwrap()",
            escape_rust_string(node.as_str())
        )),
        _ => Err("Invalid predicate term for shape triple".to_string()),
    }
}

fn term_expr(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!(
            "Term::NamedNode(NamedNode::new(\"{}\").unwrap())",
            escape_rust_string(node.as_str())
        )),
        Term::BlankNode(node) => Ok(format!(
            "Term::BlankNode(BlankNode::new_unchecked(\"{}\"))",
            escape_rust_string(node.as_str())
        )),
        Term::Literal(lit) => {
            if let Some(lang) = lit.language() {
                Ok(format!(
                    "Term::Literal(Literal::new_language_tagged_literal(\"{}\", \"{}\").unwrap())",
                    escape_rust_string(lit.value()),
                    escape_rust_string(lang)
                ))
            } else if lit.datatype().as_str() == "http://www.w3.org/2001/XMLSchema#string" {
                Ok(format!(
                    "Term::Literal(Literal::new_simple_literal(\"{}\"))",
                    escape_rust_string(lit.value())
                ))
            } else {
                Ok(format!(
                    "Term::Literal(Literal::new_typed_literal(\"{}\", NamedNode::new(\"{}\").unwrap()))",
                    escape_rust_string(lit.value()),
                    escape_rust_string(lit.datatype().as_str())
                ))
            }
        }
    }
}

fn term_to_nt(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!("<{}>", escape_nt_iri(node.as_str()))),
        Term::BlankNode(node) => Ok(format!("_:{}", node.as_str())),
        Term::Literal(lit) => {
            let mut out = String::new();
            out.push('"');
            out.push_str(&escape_nt_string(lit.value()));
            out.push('"');
            if let Some(lang) = lit.language() {
                out.push('@');
                out.push_str(lang);
            } else {
                out.push_str("^^<");
                out.push_str(&escape_nt_iri(lit.datatype().as_str()));
                out.push('>');
            }
            Ok(out)
        }
    }
}

fn escape_nt_string(value: &str) -> String {
    let mut out = String::with_capacity(value.len());
    for ch in value.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            ch if ch <= '\u{1F}' || ch == '\u{7F}' => {
                out.push_str(&format!("\\u{:04X}", ch as u32))
            }
            ch => out.push(ch),
        }
    }
    out
}

fn escape_nt_iri(value: &str) -> String {
    let mut out = String::with_capacity(value.len());
    for ch in value.chars() {
        match ch {
            '<' | '>' | '"' | '{' | '}' | '|' | '^' | '`' | '\\' => {
                out.push_str(&format!("\\u{:04X}", ch as u32))
            }
            ch if ch <= '\u{1F}' || ch == '\u{7F}' => {
                out.push_str(&format!("\\u{:04X}", ch as u32))
            }
            ch => out.push(ch),
        }
    }
    out
}

fn escape_rust_string(value: &str) -> String {
    value
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn emit_shape_and_component_maps(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    emit_shape_iri_map(out, plan)?;
    emit_component_iri_map(out, plan)?;
    Ok(())
}

fn emit_shape_iri_map(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    writeln!(out, "fn shape_iri(shape_id: u64) -> &'static str {{").unwrap();
    writeln!(out, "    match shape_id {{").unwrap();
    for shape in &plan.shapes {
        let iri = term_iri(plan, shape.term)?;
        writeln!(
            out,
            "        {} => \"{}\",",
            shape.id,
            escape_rust_string(&iri)
        )
        .unwrap();
    }
    writeln!(out, "        _ => \"\",").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_component_iri_map(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    writeln!(
        out,
        "fn component_iri(component_id: u64) -> &'static str {{"
    )
    .unwrap();
    writeln!(out, "    match component_id {{").unwrap();
    for component in &plan.components {
        writeln!(
            out,
            "        {} => \"{}\",",
            component.id,
            escape_rust_string(constraint_component_iri(component.kind))
        )
        .unwrap();
    }
    writeln!(
        out,
        "        _ => \"http://www.w3.org/ns/shacl#ConstraintComponent\","
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn constraint_component_iri(kind: ComponentKind) -> &'static str {
    match kind {
        ComponentKind::Node => "http://www.w3.org/ns/shacl#node",
        ComponentKind::Property => "http://www.w3.org/ns/shacl#property",
        ComponentKind::QualifiedValueShape => "http://www.w3.org/ns/shacl#qualifiedValueShape",
        ComponentKind::Class => "http://www.w3.org/ns/shacl#class",
        ComponentKind::Datatype => "http://www.w3.org/ns/shacl#datatype",
        ComponentKind::NodeKind => "http://www.w3.org/ns/shacl#nodeKind",
        ComponentKind::MinCount => "http://www.w3.org/ns/shacl#minCount",
        ComponentKind::MaxCount => "http://www.w3.org/ns/shacl#maxCount",
        ComponentKind::MinExclusive => "http://www.w3.org/ns/shacl#minExclusive",
        ComponentKind::MinInclusive => "http://www.w3.org/ns/shacl#minInclusive",
        ComponentKind::MaxExclusive => "http://www.w3.org/ns/shacl#maxExclusive",
        ComponentKind::MaxInclusive => "http://www.w3.org/ns/shacl#maxInclusive",
        ComponentKind::MinLength => "http://www.w3.org/ns/shacl#minLength",
        ComponentKind::MaxLength => "http://www.w3.org/ns/shacl#maxLength",
        ComponentKind::Pattern => "http://www.w3.org/ns/shacl#pattern",
        ComponentKind::LanguageIn => "http://www.w3.org/ns/shacl#languageIn",
        ComponentKind::UniqueLang => "http://www.w3.org/ns/shacl#uniqueLang",
        ComponentKind::Equals => "http://www.w3.org/ns/shacl#equals",
        ComponentKind::Disjoint => "http://www.w3.org/ns/shacl#disjoint",
        ComponentKind::LessThan => "http://www.w3.org/ns/shacl#lessThan",
        ComponentKind::LessThanOrEquals => "http://www.w3.org/ns/shacl#lessThanOrEquals",
        ComponentKind::Not => "http://www.w3.org/ns/shacl#not",
        ComponentKind::And => "http://www.w3.org/ns/shacl#and",
        ComponentKind::Or => "http://www.w3.org/ns/shacl#or",
        ComponentKind::Xone => "http://www.w3.org/ns/shacl#xone",
        ComponentKind::Closed => "http://www.w3.org/ns/shacl#closed",
        ComponentKind::HasValue => "http://www.w3.org/ns/shacl#hasValue",
        ComponentKind::In => "http://www.w3.org/ns/shacl#in",
        ComponentKind::Sparql => "http://www.w3.org/ns/shacl#SPARQL",
    }
}

fn emit_validation_report_helpers(out: &mut String) -> Result<(), String> {
    writeln!(
        out,
        "const SHACL_VALIDATION_REPORT: &str = \"http://www.w3.org/ns/shacl#ValidationReport\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_VALIDATION_RESULT: &str = \"http://www.w3.org/ns/shacl#ValidationResult\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_RESULT: &str = \"http://www.w3.org/ns/shacl#result\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_FOCUS_NODE: &str = \"http://www.w3.org/ns/shacl#focusNode\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_SOURCE_SHAPE: &str = \"http://www.w3.org/ns/shacl#sourceShape\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_SOURCE_CONSTRAINT_COMPONENT: &str = \"http://www.w3.org/ns/shacl#sourceConstraintComponent\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_VALUE: &str = \"http://www.w3.org/ns/shacl#value\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_RESULT_SEVERITY: &str = \"http://www.w3.org/ns/shacl#resultSeverity\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_VIOLATION: &str = \"http://www.w3.org/ns/shacl#Violation\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_CONFORMS: &str = \"http://www.w3.org/ns/shacl#conforms\";"
    )
    .unwrap();
    writeln!(
        out,
        "const XSD_BOOLEAN: &str = \"http://www.w3.org/2001/XMLSchema#boolean\";"
    )
    .unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn bool_literal(value: bool) -> &'static str {{").unwrap();
    writeln!(out, "    if value {{").unwrap();
    writeln!(
        out,
        "        \"\\\"true\\\"^^<http://www.w3.org/2001/XMLSchema#boolean>\""
    )
    .unwrap();
    writeln!(out, "    }} else {{").unwrap();
    writeln!(
        out,
        "        \"\\\"false\\\"^^<http://www.w3.org/2001/XMLSchema#boolean>\""
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn term_to_turtle_value(term: &Term) -> String {{").unwrap();
    writeln!(out, "    term.to_string()").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn format_validation_report(report: &Report) -> String {{"
    )
    .unwrap();
    writeln!(out, "    let mut out = String::new();").unwrap();
    writeln!(
        out,
        "    out.push_str(\"@prefix sh: <http://www.w3.org/ns/shacl#> .\\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\\n\\n\");"
    )
    .unwrap();
    writeln!(
        out,
        "{}",
        "    out.push_str(&format!(\"_:report a sh:ValidationReport ;\\n    sh:conforms {} ;\\n\", bool_literal(report.violations.is_empty())));"
    )
    .unwrap();
    writeln!(out, "    if report.violations.is_empty() {{").unwrap();
    writeln!(out, "        out.push_str(\"    sh:result .\\n\\n\");").unwrap();
    writeln!(out, "    }} else {{").unwrap();
    writeln!(out, "        out.push_str(\"    sh:result \");").unwrap();
    writeln!(
        out,
        "        for (i, _) in report.violations.iter().enumerate() {{"
    )
    .unwrap();
    writeln!(out, "            if i > 0 {{").unwrap();
    writeln!(out, "                out.push_str(\", \");").unwrap();
    writeln!(out, "            }}").unwrap();
    writeln!(
        out,
        "{}",
        "            out.push_str(&format!(\"_:violation{}\", i));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        out.push_str(\" .\\n\\n\");").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(
        out,
        "    for (i, violation) in report.violations.iter().enumerate() {{"
    )
    .unwrap();
    writeln!(
        out,
        "{}",
        "        out.push_str(&format!(\"_:violation{} a sh:ValidationResult ;\\n\", i));"
    )
    .unwrap();
    writeln!(
        out,
        "{}",
        "        out.push_str(&format!(\"    sh:focusNode {} ;\\n\", term_to_turtle_value(&violation.focus)));"
    )
    .unwrap();
    writeln!(
        out,
        "{}",
        "        out.push_str(&format!(\"    sh:sourceShape <{}> ;\\n\", shape_iri(violation.shape_id)));"
    )
    .unwrap();
    writeln!(
        out,
        "{}",
        "        out.push_str(&format!(\"    sh:sourceConstraintComponent <{}> ;\\n\", component_iri(violation.component_id)));"
    )
    .unwrap();
    writeln!(out, "        if let Some(value) = &violation.value {{").unwrap();
    writeln!(
        out,
        "{}",
        "            out.push_str(&format!(\"    sh:value {} ;\\n\", term_to_turtle_value(value)));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(
        out,
        "        out.push_str(\"    sh:resultSeverity sh:Violation .\\n\\n\");"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    out").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}
