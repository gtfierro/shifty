mod analyze;
mod codegen;
mod emit;
mod ir;
mod lower;
mod opt;

pub use emit::write_generated_modules;
pub use ir::SrcGenIR;

use shifty::shacl_ir::ShapeIR;

pub struct GeneratedRust {
    pub root: String,
    pub files: Vec<(String, String)>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SrcGenBackend {
    Specialized,
    Tables,
}

impl SrcGenBackend {
    pub fn as_str(self) -> &'static str {
        match self {
            SrcGenBackend::Specialized => "specialized",
            SrcGenBackend::Tables => "tables",
        }
    }
}

impl GeneratedRust {
    pub fn to_single_file(&self) -> String {
        let mut out = String::new();
        out.push_str("// Code generated by shacl-srcgen-compiler. DO NOT EDIT.\n");
        out.push_str("#![allow(unused_variables)]\n");
        out.push_str("#![allow(dead_code)]\n");
        out.push_str("#![allow(unused_mut)]\n");
        out.push_str("#![allow(unused_imports)]\n");
        out.push_str("#![allow(unused_comparisons)]\n");
        for (_, content) in &self.files {
            out.push_str(content);
            if !content.ends_with('\n') {
                out.push('\n');
            }
            out.push('\n');
        }
        out
    }
}

pub fn lower_shape_ir(shape_ir: &ShapeIR) -> Result<SrcGenIR, String> {
    lower::lower_shape_ir(shape_ir)
}

pub fn generate_modules_from_ir_with_backend(
    ir: &SrcGenIR,
    backend: SrcGenBackend,
) -> Result<GeneratedRust, String> {
    let analysis = analyze::analyze(ir);
    let _analysis_counts = (
        analysis.shape_count,
        analysis.component_count,
        analysis.fallback_component_count,
    );
    let mut optimized = ir.clone();
    opt::optimize(&mut optimized);
    codegen::generate_modules(&optimized, backend)
}

pub fn generate_modules_from_shape_ir_with_backend(
    shape_ir: &ShapeIR,
    backend: SrcGenBackend,
) -> Result<GeneratedRust, String> {
    let ir = lower_shape_ir(shape_ir)?;
    generate_modules_from_ir_with_backend(&ir, backend)
}
