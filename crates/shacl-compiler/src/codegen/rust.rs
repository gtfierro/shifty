use crate::plan::{
    CompId, ComponentKind, PlanIR, PlanPath, PlanRuleKind, PlanShape, PlanShapeKind, PlanTarget,
};
use crate::registry::{self, EmitContext, PropertyEmission};
use crate::GeneratedRust;
use oxigraph::model::Term;
use shacl_ir::Severity;
use std::collections::{HashMap, HashSet};
use std::fmt::Write;

pub fn generate(plan: &PlanIR) -> Result<String, String> {
    let modules = generate_modules(plan)?;
    Ok(modules.to_single_file())
}

pub fn generate_modules(plan: &PlanIR) -> Result<GeneratedRust, String> {
    let sections = generate_sections(plan)?;
    let mut files = Vec::new();
    let mut module_files = Vec::new();

    files.push(("prelude.rs".to_string(), sections.prelude));
    files.push(("helpers.rs".to_string(), sections.helpers));
    files.push(("paths.rs".to_string(), sections.paths));
    files.push(("shape_triples.rs".to_string(), sections.shape_triples));
    files.push(("shape_graph.nt".to_string(), sections.shape_graph_nt));
    files.push(("targets.rs".to_string(), sections.targets));
    files.push((
        "allowed_predicates.rs".to_string(),
        sections.allowed_predicates,
    ));
    files.push((
        "validators_property.rs".to_string(),
        sections.property_validators,
    ));
    files.push(("validators_node.rs".to_string(), sections.node_validators));
    files.push(("inference.rs".to_string(), sections.inference));
    files.push(("run.rs".to_string(), sections.run));

    for (name, _) in &files {
        if name.ends_with(".rs") {
            module_files.push(name.clone());
        }
    }

    let mut root = String::new();
    writeln!(root, "// Code generated by shacl-compiler. DO NOT EDIT.").unwrap();
    writeln!(root, "#![allow(unused_variables)]").unwrap();
    writeln!(root, "#![allow(dead_code)]").unwrap();
    for name in &module_files {
        writeln!(root, "include!(\"{}\");", name).unwrap();
    }

    Ok(GeneratedRust { root, files })
}

struct Sections {
    prelude: String,
    helpers: String,
    paths: String,
    shape_triples: String,
    shape_graph_nt: String,
    targets: String,
    allowed_predicates: String,
    property_validators: String,
    node_validators: String,
    inference: String,
    run: String,
}

fn generate_sections(plan: &PlanIR) -> Result<Sections, String> {
    let mut prelude = String::new();
    let mut helpers = String::new();
    let mut paths = String::new();
    let mut shape_triples = String::new();
    let mut shape_graph_nt = String::new();
    let mut targets = String::new();
    let mut allowed_predicates = String::new();
    let mut property_validators = String::new();
    let mut node_validators = String::new();
    let mut run = String::new();
    let mut inference = String::new();

    writeln!(prelude, "{}", "use oxigraph::model::{BlankNode, Graph, GraphName, GraphNameRef, Literal, NamedNode, NamedNodeRef, NamedOrBlankNode, NamedOrBlankNodeRef, Quad, Term, TermRef, Triple};").unwrap();
    writeln!(
        prelude,
        "{}",
        "use oxigraph::io::{RdfFormat, RdfParser, RdfSerializer};"
    )
    .unwrap();
    writeln!(prelude, "use oxigraph::store::Store;").unwrap();
    writeln!(
        prelude,
        "{}",
        "use oxigraph::sparql::{{QueryResults, SparqlEvaluator, Variable}};"
    )
    .unwrap();
    writeln!(
        prelude,
        "{}",
        "use std::collections::{HashMap, HashSet, VecDeque};"
    )
    .unwrap();
    writeln!(prelude, "use rayon::prelude::*;").unwrap();
    writeln!(prelude, "use regex::Regex;").unwrap();
    writeln!(prelude, "use log::info;").unwrap();
    writeln!(prelude, "").unwrap();

    let shape_graph_iri = term_iri(plan, plan.shape_graph)?;
    let data_graph_iri = format!("{}-compiled-data", shape_graph_iri);
    writeln!(
        prelude,
        "const RDF_TYPE: &str = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const RDFS_SUBCLASS_OF: &str = \"http://www.w3.org/2000/01/rdf-schema#subClassOf\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHAPE_GRAPH: &str = \"{}\";",
        escape_rust_string(&shape_graph_iri)
    )
    .unwrap();
    writeln!(
        prelude,
        "pub const DATA_GRAPH: &str = \"{}\";",
        escape_rust_string(&data_graph_iri)
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_SELECT: &str = \"http://www.w3.org/ns/shacl#select\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_PREFIXES: &str = \"http://www.w3.org/ns/shacl#prefixes\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_DECLARE: &str = \"http://www.w3.org/ns/shacl#declare\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_PREFIX: &str = \"http://www.w3.org/ns/shacl#prefix\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_NAMESPACE: &str = \"http://www.w3.org/ns/shacl#namespace\";"
    )
    .unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "#[derive(Debug, Default)]").unwrap();
    writeln!(prelude, "{}", "pub struct Report {").unwrap();
    writeln!(prelude, "    pub violations: Vec<Violation>,").unwrap();
    writeln!(prelude, "{}", "}").unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "#[derive(Debug)]").unwrap();
    writeln!(prelude, "{}", "pub struct Violation {").unwrap();
    writeln!(prelude, "    pub shape_id: u64,").unwrap();
    writeln!(prelude, "    pub component_id: u64,").unwrap();
    writeln!(prelude, "    pub focus: Term,").unwrap();
    writeln!(prelude, "    pub value: Option<Term>,").unwrap();
    writeln!(prelude, "    pub path: Option<String>,").unwrap();
    writeln!(prelude, "{}", "}").unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "{}", "impl Report {").unwrap();
    writeln!(prelude, "    pub fn record(").unwrap();
    writeln!(prelude, "        &mut self,").unwrap();
    writeln!(prelude, "        shape_id: u64,").unwrap();
    writeln!(prelude, "        component_id: u64,").unwrap();
    writeln!(prelude, "        focus: &Term,").unwrap();
    writeln!(prelude, "        value: Option<&Term>,").unwrap();
    writeln!(prelude, "        path: Option<&str>,").unwrap();
    writeln!(prelude, "{}", "    ) {").unwrap();
    writeln!(prelude, "{}", "        self.violations.push(Violation {").unwrap();
    writeln!(prelude, "            shape_id,").unwrap();
    writeln!(prelude, "            component_id,").unwrap();
    writeln!(prelude, "            focus: focus.clone(),").unwrap();
    writeln!(prelude, "            value: value.cloned(),").unwrap();
    writeln!(prelude, "            path: path.map(|p| p.to_string()),").unwrap();
    writeln!(prelude, "{}", "        });").unwrap();
    writeln!(prelude, "{}", "    }").unwrap();
    writeln!(prelude, "{}", "    pub fn merge(&mut self, other: Report) {").unwrap();
    writeln!(
        prelude,
        "        self.violations.extend(other.violations);"
    )
    .unwrap();
    writeln!(prelude, "{}", "    }").unwrap();
    writeln!(prelude, "{}", "    pub fn to_turtle(&self) -> String {").unwrap();
    writeln!(prelude, "        format_validation_report(self)").unwrap();
    writeln!(prelude, "{}", "    }").unwrap();
    writeln!(prelude, "{}", "}").unwrap();
    writeln!(prelude, "").unwrap();

    writeln!(helpers, "use serde_json;").unwrap();
    writeln!(helpers, "use shacl_ir::ShapeIR;").unwrap();
    writeln!(helpers, "use std::cell::RefCell;").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn graph_ref(graph: Option<&NamedNode>) -> Option<GraphNameRef<'_>> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    graph.map(|g| GraphNameRef::NamedNode(g.as_ref()))"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "thread_local! {{").unwrap();
    writeln!(
        helpers,
        "    static CURRENT_SUBCLASS_CLOSURE: RefCell<SubclassClosure> = RefCell::new(SubclassClosure::new());"
    )
    .unwrap();
    writeln!(
        helpers,
        "    static TARGET_CLASS_CACHE: RefCell<HashMap<(String, String), Vec<Term>>> = RefCell::new(HashMap::new());"
    )
    .unwrap();
    writeln!(
        helpers,
        "    static TYPE_INDEX_CACHE: RefCell<HashMap<String, HashMap<String, Vec<Term>>>> = RefCell::new(HashMap::new());"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "#[derive(Clone)]").unwrap();
    writeln!(helpers, "struct SubclassClosure {{").unwrap();
    writeln!(helpers, "    parents: HashMap<String, Vec<String>>,").unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn init_thread_state(closure: SubclassClosure) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    CURRENT_SUBCLASS_CLOSURE.with(|cell| *cell.borrow_mut() = closure);"
    )
    .unwrap();
    writeln!(helpers, "    clear_target_class_caches();").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "impl SubclassClosure {{").unwrap();
    writeln!(helpers, "    fn new() -> Self {{").unwrap();
    writeln!(
        helpers,
        "        SubclassClosure {{ parents: HashMap::new() }}"
    )
    .unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    fn from_edges(edges: &[(&str, &str)]) -> Self {{"
    )
    .unwrap();
    writeln!(helpers, "        let mut closure = SubclassClosure::new();").unwrap();
    writeln!(helpers, "        for (sub, sup) in edges.iter() {{").unwrap();
    writeln!(helpers, "            closure.add_edge(sub, sup);").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "        closure").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    fn add_edge(&mut self, subclass: &str, superclass: &str) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "        self.parents.entry(subclass.to_string()).or_default().push(superclass.to_string());"
    )
    .unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    fn extend_from_store(&mut self, store: &Store, graph: Option<GraphNameRef<'_>>) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let subclass_pred = NamedNodeRef::new(RDFS_SUBCLASS_OF).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "        for quad in store.quads_for_pattern(None, Some(subclass_pred), None, graph) {{"
    )
    .unwrap();
    writeln!(helpers, "            if let Ok(quad) = quad {{").unwrap();
    writeln!(
        helpers,
        "                if let (NamedOrBlankNode::NamedNode(sub), Term::NamedNode(sup)) = (&quad.subject, &quad.object) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    self.add_edge(sub.as_str(), sup.as_str());"
    )
    .unwrap();
    writeln!(helpers, "                }}").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    fn is_subclass_of(&self, subclass: &str, superclass: &str) -> bool {{"
    )
    .unwrap();
    writeln!(helpers, "        if subclass == superclass {{").unwrap();
    writeln!(helpers, "            return true;").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(
        helpers,
        "        let mut stack: Vec<String> = vec![subclass.to_string()];"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let mut seen: HashSet<String> = HashSet::new();"
    )
    .unwrap();
    writeln!(helpers, "        while let Some(curr) = stack.pop() {{").unwrap();
    writeln!(helpers, "            if curr == superclass {{").unwrap();
    writeln!(helpers, "                return true;").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "            if !seen.insert(curr.clone()) {{").unwrap();
    writeln!(helpers, "                continue;").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(
        helpers,
        "            if let Some(parents) = self.parents.get(&curr) {{"
    )
    .unwrap();
    writeln!(helpers, "                for parent in parents {{").unwrap();
    writeln!(helpers, "                    stack.push(parent.clone());").unwrap();
    writeln!(helpers, "                }}").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "        false").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "fn subclass_closure_from_shape_edges() -> SubclassClosure {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    SubclassClosure::from_edges(SHAPE_SUBCLASS_EDGES)"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "fn set_current_subclass_closure(closure: SubclassClosure) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    CURRENT_SUBCLASS_CLOSURE.with(|cell| *cell.borrow_mut() = closure);"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "fn extend_current_subclass_closure_from_store(store: &Store, graph: Option<GraphNameRef<'_>>) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    CURRENT_SUBCLASS_CLOSURE.with(|cell| cell.borrow_mut().extend_from_store(store, graph));"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "fn with_subclass_closure<F, R>(f: F) -> R where F: FnOnce(&SubclassClosure) -> R {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    CURRENT_SUBCLASS_CLOSURE.with(|cell| f(&cell.borrow()))"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn graph_cache_key(graph: Option<GraphNameRef<'_>>) -> String {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    match graph { Some(g) => g.to_string(), None => \"__all__\".to_string() }"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn build_type_index(store: &Store, graph: Option<GraphNameRef<'_>>) -> HashMap<String, Vec<Term>> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let rdf_type = NamedNodeRef::new(RDF_TYPE).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let mut index: HashMap<String, Vec<Term>> = HashMap::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut graphs: Vec<Option<GraphNameRef<'_>>> = Vec::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(g) = graph {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        graphs.push(Some(g));"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        let shape_graph = shape_graph_ref();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        if g != shape_graph { graphs.push(Some(shape_graph)); }"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    } else {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        graphs.push(None);"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    }"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    for graph_opt in graphs {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        for quad in store.quads_for_pattern(None, Some(rdf_type), None, graph_opt) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            let quad = match quad { Ok(quad) => quad, Err(_) => continue };"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            let class_iri = match &quad.object { Term::NamedNode(node) => node.as_str(), _ => continue };"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let subject: Term = quad.subject.into();"
    )
    .unwrap();
    writeln!(
        helpers,
        "        index.entry(class_iri.to_string()).or_default().push(subject);"
    )
    .unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    index").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn clear_target_class_caches() {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    TARGET_CLASS_CACHE.with(|cell| cell.borrow_mut().clear());"
    )
    .unwrap();
    writeln!(
        helpers,
        "    TYPE_INDEX_CACHE.with(|cell| cell.borrow_mut().clear());"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn targets_for_class(store: &Store, graph: Option<GraphNameRef<'_>>, class_iri: &str) -> Vec<Term> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let graph_key = graph_cache_key(graph);"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let cache_key = (graph_key.clone(), class_iri.to_string());"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(cached) = TARGET_CLASS_CACHE.with(|cell| cell.borrow().get(&cache_key).cloned()) {"
    )
    .unwrap();
    writeln!(helpers, "        return cached;").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let targets = TYPE_INDEX_CACHE.with(|cell| {"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let mut cache = cell.borrow_mut();"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let index = cache.entry(graph_key.clone()).or_insert_with(|| build_type_index(store, graph));"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        with_subclass_closure(|closure| {"
    )
    .unwrap();
    writeln!(
        helpers,
        "            let mut out: Vec<Term> = Vec::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "            let mut seen: HashSet<Term> = HashSet::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            for (class, subjects) in index.iter() {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                if closure.is_subclass_of(class.as_str(), class_iri) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                    for subject in subjects {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                        if seen.insert(subject.clone()) { out.push(subject.clone()); }"
    )
    .unwrap();
    writeln!(helpers, "{}", "                    }").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "            out").unwrap();
    writeln!(helpers, "{}", "        })").unwrap();
    writeln!(helpers, "{}", "    });").unwrap();
    writeln!(
        helpers,
        "{}",
        "    TARGET_CLASS_CACHE.with(|cell| { cell.borrow_mut().insert(cache_key, targets.clone()); });"
    )
    .unwrap();
    writeln!(helpers, "    targets").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn shape_graph_ref() -> GraphNameRef<'static> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    GraphNameRef::NamedNode(NamedNodeRef::new(SHAPE_GRAPH).unwrap())"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn subject_ref(term: &Term) -> Option<NamedOrBlankNodeRef<'_>> {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::NamedNode(node) => Some(NamedOrBlankNodeRef::NamedNode(node.as_ref())),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::BlankNode(node) => Some(NamedOrBlankNodeRef::BlankNode(node.as_ref())),"
    )
    .unwrap();
    writeln!(helpers, "        _ => None,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "{}", "fn term_ref(term: &Term) -> TermRef<'_> {").unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::NamedNode(node) => TermRef::NamedNode(node.as_ref()),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::BlankNode(node) => TermRef::BlankNode(node.as_ref()),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => TermRef::Literal(lit.as_ref()),"
    )
    .unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn is_literal_with_datatype(term: &Term, datatype_iri: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => lit.datatype().as_str() == datatype_iri,"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn advanced_select_query(store: &Store, selector: &Term) -> Option<String> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let select_pred = NamedNodeRef::new(SHACL_SELECT).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(subject) = subject_ref(selector) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        for quad in store.quads_for_pattern(Some(subject), Some(select_pred), None, None) {").unwrap();
    writeln!(helpers, "{}", "            if let Ok(quad) = quad {").unwrap();
    writeln!(
        helpers,
        "{}",
        "                if let Term::Literal(lit) = quad.object {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    return Some(lit.value().to_string());"
    )
    .unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    for quad in store.quads_for_pattern(None, Some(select_pred), None, None) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        if let Ok(quad) = quad {").unwrap();
    writeln!(
        helpers,
        "{}",
        "            if let Term::Literal(lit) = quad.object {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                return Some(lit.value().to_string());"
    )
    .unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    None").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn prefixes_for_selector(store: &Store, selector: &Term) -> String {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_prefixes = NamedNodeRef::new(SHACL_PREFIXES).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_declare = NamedNodeRef::new(SHACL_DECLARE).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_prefix = NamedNodeRef::new(SHACL_PREFIX).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_namespace = NamedNodeRef::new(SHACL_NAMESPACE).unwrap();"
    )
    .unwrap();
    writeln!(helpers, "    let shape_graph = shape_graph_ref();").unwrap();
    writeln!(helpers, "    let mut subjects: Vec<Term> = Vec::new();").unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(subject) = subject_ref(selector) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        for quad in store.quads_for_pattern(Some(subject), Some(sh_prefixes), None, Some(shape_graph)) {").unwrap();
    writeln!(helpers, "{}", "            if let Ok(quad) = quad {").unwrap();
    writeln!(helpers, "                subjects.push(quad.object);").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    for quad in store.quads_for_pattern(None, Some(sh_declare), None, None) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        if let Ok(quad) = quad {").unwrap();
    writeln!(helpers, "            subjects.push(quad.subject.into());").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "    let mut prefixes: HashMap<String, String> = HashMap::new();"
    )
    .unwrap();
    writeln!(helpers, "{}", "    for subject_term in subjects {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        let subject_node = match subject_ref(&subject_term) {"
    )
    .unwrap();
    writeln!(helpers, "            Some(value) => value,").unwrap();
    writeln!(helpers, "            None => continue,").unwrap();
    writeln!(helpers, "{}", "        };").unwrap();
    writeln!(helpers, "{}", "        for quad in store.quads_for_pattern(Some(subject_node), Some(sh_declare), None, None) {").unwrap();
    writeln!(
        helpers,
        "{}",
        "            let quad = match quad { Ok(q) => q, Err(_) => continue };"
    )
    .unwrap();
    writeln!(helpers, "            let decl_term = quad.object;").unwrap();
    writeln!(
        helpers,
        "{}",
        "            let decl_ref = match subject_ref(&decl_term) {"
    )
    .unwrap();
    writeln!(helpers, "                Some(value) => value,").unwrap();
    writeln!(helpers, "                None => continue,").unwrap();
    writeln!(helpers, "{}", "            };").unwrap();
    writeln!(
        helpers,
        "    let prefix_val = store.quads_for_pattern(Some(decl_ref), Some(sh_prefix), None, None)"
    )
    .unwrap();
    writeln!(helpers, "        .filter_map(Result::ok)").unwrap();
    writeln!(helpers, "        .map(|q| q.object)").unwrap();
    writeln!(helpers, "        .next();").unwrap();
    writeln!(helpers, "    let namespace_val = store.quads_for_pattern(Some(decl_ref), Some(sh_namespace), None, None)").unwrap();
    writeln!(helpers, "        .filter_map(Result::ok)").unwrap();
    writeln!(helpers, "        .map(|q| q.object)").unwrap();
    writeln!(helpers, "        .next();").unwrap();
    writeln!(helpers, "{}", "            if let (Some(Term::Literal(prefix_lit)), Some(Term::Literal(ns_lit))) = (prefix_val, namespace_val) {").unwrap();
    writeln!(
        helpers,
        "                let prefix = prefix_lit.value().to_string();"
    )
    .unwrap();
    writeln!(
        helpers,
        "                let namespace = ns_lit.value().to_string();"
    )
    .unwrap();
    writeln!(
        helpers,
        "                prefixes.insert(prefix, namespace);"
    )
    .unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if prefixes.is_empty() {").unwrap();
    writeln!(helpers, "        return String::new();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "    let mut keys: Vec<String> = prefixes.keys().cloned().collect();"
    )
    .unwrap();
    writeln!(helpers, "    keys.sort();").unwrap();
    writeln!(helpers, "    let mut out = String::new();").unwrap();
    writeln!(helpers, "{}", "    for key in keys {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if let Some(ns) = prefixes.get(&key) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            out.push_str(&format!(\"PREFIX {}: <{}>\\n\", key, ns));"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    out").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn advanced_targets_for(store: &Store, selector: &Term) -> Vec<Term> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let query = match advanced_select_query(store, selector) {"
    )
    .unwrap();
    writeln!(helpers, "        Some(value) => value,").unwrap();
    writeln!(helpers, "        None => return Vec::new(),").unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(
        helpers,
        "    let prefixes = prefixes_for_selector(store, selector);"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let query_str = if prefixes.trim().is_empty() {"
    )
    .unwrap();
    writeln!(helpers, "        query.clone()").unwrap();
    writeln!(helpers, "{}", "    } else {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        format!(\"{}\\n{}\", prefixes, query)"
    )
    .unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut prepared = match SparqlEvaluator::new().parse_query(&query_str) {"
    )
    .unwrap();
    writeln!(helpers, "        Ok(prepared) => prepared,").unwrap();
    writeln!(helpers, "        Err(_) => return Vec::new(),").unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(
        helpers,
        "    prepared.dataset_mut().set_default_graph_as_union();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let mut results: HashSet<Term> = HashSet::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    match prepared.on_store(store).execute() {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        Ok(QueryResults::Solutions(solutions)) => {"
    )
    .unwrap();
    writeln!(helpers, "{}", "            for solution in solutions {").unwrap();
    writeln!(
        helpers,
        "{}",
        "                let solution = match solution { Ok(sol) => sol, Err(_) => continue };"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                if let Some(value) = solution.get(\"this\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    results.insert(value.to_owned());"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                } else if let Some(value) = solution.get(\"target\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    results.insert(value.to_owned());"
    )
    .unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "        _ => {}").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    results.into_iter().collect()").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn has_rdf_type(store: &Store, graph: Option<GraphNameRef<'_>>, term: &Term, class_iri: &str) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let subject = match subject_ref(term) { Some(s) => s, None => return false };"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let rdf_type = NamedNodeRef::new(RDF_TYPE).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    for quad in store.quads_for_pattern(Some(subject), Some(rdf_type), None, graph) {{"
    )
    .unwrap();
    writeln!(helpers, "        if let Ok(quad) = quad {{").unwrap();
    writeln!(
        helpers,
        "            if let Term::NamedNode(node) = quad.object {{"
    )
    .unwrap();
    writeln!(helpers, "                let node_str = node.as_str();").unwrap();
    writeln!(
        helpers,
        "                if with_subclass_closure(|closure| closure.is_subclass_of(node_str, class_iri)) {{"
    )
    .unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "                }}").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "    false").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn matches_node_kind(term: &Term, node_kind_iri: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match node_kind_iri {").unwrap();
    writeln!(
        helpers,
        "        \"http://www.w3.org/ns/shacl#IRI\" => matches!(term, Term::NamedNode(_)),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        \"http://www.w3.org/ns/shacl#BlankNode\" => matches!(term, Term::BlankNode(_)),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        \"http://www.w3.org/ns/shacl#Literal\" => matches!(term, Term::Literal(_)),"
    )
    .unwrap();
    writeln!(helpers, "        \"http://www.w3.org/ns/shacl#BlankNodeOrIRI\" => matches!(term, Term::BlankNode(_) | Term::NamedNode(_)),").unwrap();
    writeln!(helpers, "        \"http://www.w3.org/ns/shacl#BlankNodeOrLiteral\" => matches!(term, Term::BlankNode(_) | Term::Literal(_)),").unwrap();
    writeln!(helpers, "        \"http://www.w3.org/ns/shacl#IRIOrLiteral\" => matches!(term, Term::NamedNode(_) | Term::Literal(_)),").unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn literal_length_at_least(term: &Term, min: u64) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => (lit.value().chars().count() as u64) >= min,"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn literal_length_at_most(term: &Term, max: u64) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => (lit.value().chars().count() as u64) <= max,"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn literal_matches_regex(term: &Term, regex: &Regex) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => regex.is_match(lit.value()),"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn lang_matches(tag: &str, range: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    if range == \"*\" {").unwrap();
    writeln!(helpers, "        return !tag.is_empty();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    let tag_lower = tag.to_lowercase();").unwrap();
    writeln!(helpers, "    let range_lower = range.to_lowercase();").unwrap();
    writeln!(helpers, "{}", "    if tag_lower == range_lower {").unwrap();
    writeln!(helpers, "        return true;").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    if range_lower.chars().all(|c| c.is_ascii_alphanumeric() || c == '-') {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        if tag_lower.starts_with(&format!(\"{}-\", range_lower)) {"
    )
    .unwrap();
    writeln!(helpers, "            return true;").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    false").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn language_in_allowed(term: &Term, allowed: &[&str]) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(helpers, "{}", "        Term::Literal(lit) => {").unwrap();
    writeln!(
        helpers,
        "            let lang = lit.language().unwrap_or(\"\");"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            if allowed.is_empty() { return false; }"
    )
    .unwrap();
    writeln!(
        helpers,
        "            allowed.iter().any(|range| lang_matches(lang, range))"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn values_for_predicate(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term, predicate_iri: &str) -> Vec<Term> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let subject = match subject_ref(focus) { Some(s) => s, None => return Vec::new() };"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let predicate = NamedNodeRef::new(predicate_iri).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let data_graph = data_graph_named();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let graph_ref = match graph { Some(g) => g, None => GraphNameRef::NamedNode(data_graph.as_ref()) };"
    )
    .unwrap();
    writeln!(
        helpers,
        "    store.quads_for_pattern(Some(subject), Some(predicate), None, Some(graph_ref)).filter_map(Result::ok).map(|q| q.object).collect()"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(helpers, "{}", "fn term_to_sparql(term: &Term) -> String {").unwrap();
    writeln!(helpers, "    term.to_string()").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn query_mentions_var(query: &str, var: &str) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    fn contains(query: &str, prefix: char, var: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "        let mut start = 0;").unwrap();
    writeln!(helpers, "        let bytes = query.as_bytes();").unwrap();
    writeln!(helpers, "        let var_bytes = var.as_bytes();").unwrap();
    writeln!(
        helpers,
        "{}",
        "        while let Some(pos) = query[start..].find(prefix) {"
    )
    .unwrap();
    writeln!(helpers, "            let idx = start + pos + 1;").unwrap();
    writeln!(helpers, "{}", "            if bytes.len() >= idx + var_bytes.len() && &bytes[idx..idx + var_bytes.len()] == var_bytes {").unwrap();
    writeln!(
        helpers,
        "                let after = idx + var_bytes.len();"
    )
    .unwrap();
    writeln!(helpers, "{}", "                if after >= bytes.len() {").unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "                let next = bytes[after] as char;").unwrap();
    writeln!(
        helpers,
        "{}",
        "                if !next.is_ascii_alphanumeric() && next != '_' {"
    )
    .unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "            start += pos + 1;").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "        false").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "    contains(query, '?', var) || contains(query, '$', var)"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn sparql_any_solution(query: &str, store: &Store, selector: Option<&Term>, focus: Option<&Term>, value: Option<&Term>) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let query_str = if let Some(selector) = selector {"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let prefixes = prefixes_for_selector(store, selector);"
    )
    .unwrap();
    writeln!(helpers, "        if prefixes.trim().is_empty() {{").unwrap();
    writeln!(helpers, "            query.to_string()").unwrap();
    writeln!(helpers, "        }} else {{").unwrap();
    writeln!(
        helpers,
        "            format!(\"{{}}\\n{{}}\", prefixes, query)"
    )
    .unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "    }} else {{").unwrap();
    writeln!(helpers, "        query.to_string()").unwrap();
    writeln!(helpers, "    }};").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut prepared = match SparqlEvaluator::new().parse_query(&query_str) {"
    )
    .unwrap();
    writeln!(helpers, "        Ok(prepared) => prepared,").unwrap();
    writeln!(helpers, "        Err(_) => return false,").unwrap();
    writeln!(helpers, "    }};").unwrap();
    writeln!(
        helpers,
        "    prepared.dataset_mut().set_default_graph_as_union();"
    )
    .unwrap();
    writeln!(helpers, "    let mut bound = prepared.on_store(store);").unwrap();
    writeln!(helpers, "{}", "    if let Some(focus) = focus {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if query_mentions_var(query, \"this\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "            bound = bound.substitute_variable(Variable::new_unchecked(\"this\"), focus.clone());"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if let Some(value) = value {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if query_mentions_var(query, \"value\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "            bound = bound.substitute_variable(Variable::new_unchecked(\"value\"), value.clone());"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    match bound.execute() {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        Ok(QueryResults::Solutions(solutions)) => {"
    )
    .unwrap();
    writeln!(helpers, "{}", "            for result in solutions {").unwrap();
    writeln!(helpers, "{}", "                if result.is_ok() {").unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "            false").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "        Ok(QueryResults::Boolean(val)) => val,").unwrap();
    writeln!(helpers, "        Ok(QueryResults::Graph(_)) => false,").unwrap();
    writeln!(helpers, "        Err(_) => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn sparql_any_solution_lenient(query: &str, store: &Store, selector: Option<&Term>, focus: Option<&Term>, value: Option<&Term>) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let query_str = if let Some(selector) = selector {"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let prefixes = prefixes_for_selector(store, selector);"
    )
    .unwrap();
    writeln!(helpers, "        if prefixes.trim().is_empty() {{").unwrap();
    writeln!(helpers, "            query.to_string()").unwrap();
    writeln!(helpers, "        }} else {{").unwrap();
    writeln!(
        helpers,
        "            format!(\"{{}}\\n{{}}\", prefixes, query)"
    )
    .unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "    }} else {{").unwrap();
    writeln!(helpers, "        query.to_string()").unwrap();
    writeln!(helpers, "    }};").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut prepared = match SparqlEvaluator::new().parse_query(&query_str) {"
    )
    .unwrap();
    writeln!(helpers, "        Ok(prepared) => prepared,").unwrap();
    writeln!(helpers, "        Err(_) => return false,").unwrap();
    writeln!(helpers, "    }};").unwrap();
    writeln!(
        helpers,
        "    prepared.dataset_mut().set_default_graph_as_union();"
    )
    .unwrap();
    writeln!(helpers, "    let mut bound = prepared.on_store(store);").unwrap();
    writeln!(helpers, "{}", "    if let Some(focus) = focus {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if query_mentions_var(query, \"this\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "            bound = bound.substitute_variable(Variable::new_unchecked(\"this\"), focus.clone());"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if let Some(value) = value {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if query_mentions_var(query, \"value\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "            bound = bound.substitute_variable(Variable::new_unchecked(\"value\"), value.clone());"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    match bound.execute() {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        Ok(QueryResults::Solutions(solutions)) => {"
    )
    .unwrap();
    writeln!(helpers, "{}", "            for result in solutions {").unwrap();
    writeln!(helpers, "{}", "                if result.is_ok() {").unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "            false").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "        Ok(QueryResults::Boolean(val)) => val,").unwrap();
    writeln!(helpers, "        Ok(QueryResults::Graph(_)) => false,").unwrap();
    writeln!(helpers, "        Err(_) => true,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "{}", "pub fn data_graph_named() -> NamedNode {").unwrap();
    writeln!(helpers, "    NamedNode::new(DATA_GRAPH).unwrap()").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn load_shape_ir() -> Result<ShapeIR, String> {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    serde_json::from_str(include_str!(\"shape_ir.json\")).map_err(|e| format!(\"Failed to deserialize shape IR: {}\", e))")
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    emit_shape_and_component_maps(&mut helpers, plan)?;
    emit_validation_report_helpers(&mut helpers)?;

    let term_iri = |term_id: u64| term_iri(plan, term_id);
    let term_expr = |term_id: u64| term_expr_id(plan, term_id);
    let term_sparql = |term_id: u64| term_sparql_const(plan, term_id);

    emit_inference(&mut inference, plan, &term_expr, &term_iri)?;

    emit_path_functions(&mut paths, plan)?;
    emit_shape_triples(&mut shape_triples, &mut shape_graph_nt, plan)?;
    emit_subclass_edges(&mut helpers, plan)?;

    let component_lookup: HashMap<CompId, _> = plan.components.iter().map(|c| (c.id, c)).collect();
    let node_shape_lookup: HashMap<u64, _> = plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Node)
        .map(|s| (s.id, s))
        .collect();
    let property_shape_lookup: HashMap<u64, _> = plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Property)
        .map(|s| (s.id, s))
        .collect();

    let qualified_siblings = build_qualified_sibling_map(plan, &component_lookup);
    let allowed_predicate_map =
        build_allowed_predicate_map(plan, &component_lookup, &property_shape_lookup)?;

    // Property shape validators.
    for shape in plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Property)
    {
        if shape.deactivated {
            continue;
        }
        let path_id = shape
            .path
            .ok_or_else(|| format!("Property shape {} missing path", shape.id))?;
        let path_display = path_to_string(plan, path_id)?;

        let mut emission = PropertyEmission::default();
        for component_id in &shape.constraints {
            let component = component_lookup
                .get(component_id)
                .ok_or_else(|| format!("Missing component {}", component_id))?;
            let handler = registry::lookup(component.kind);
            let sibling_list = if component.kind == ComponentKind::QualifiedValueShape {
                Some(
                    qualified_siblings
                        .get(&component.id)
                        .map(|v| v.as_slice())
                        .unwrap_or(&[]),
                )
            } else {
                None
            };
            let ctx = EmitContext {
                shape_id: shape.id,
                component_id: component.id,
                kind: component.kind,
                path_iri: Some(&path_display),
                term_iri: &term_iri,
                term_expr: &term_expr,
                term_sparql: &term_sparql,
                qualified_siblings: sibling_list,
            };
            let component_emission = handler.emit_property(ctx, &component.params)?;
            emission.merge(component_emission);
        }

        writeln!(
            property_validators,
            "fn validate_property_shape_{}_for_focus(",
            shape.id
        )
        .unwrap();
        writeln!(property_validators, "    store: &Store,").unwrap();
        writeln!(property_validators, "    graph: Option<GraphNameRef<'_>>,").unwrap();
        writeln!(property_validators, "    focus: &Term,").unwrap();
        writeln!(property_validators, "    report: &mut Report,").unwrap();
        writeln!(property_validators, "{}", ") {").unwrap();
        writeln!(
            property_validators,
            "    let values = path_{}(store, graph, focus);",
            path_id
        )
        .unwrap();
        if emission.needs_count {
            writeln!(
                property_validators,
                "    let count: u64 = values.len() as u64;"
            )
            .unwrap();
        }
        for line in &emission.pre_loop_lines {
            writeln!(property_validators, "{}", line).unwrap();
        }
        if !emission.per_value_lines.is_empty() {
            writeln!(
                property_validators,
                "{}",
                "    for value in values.iter().cloned() {"
            )
            .unwrap();
            for line in &emission.per_value_lines {
                writeln!(property_validators, "{}", line).unwrap();
            }
            writeln!(property_validators, "{}", "    }").unwrap();
        }
        for line in &emission.post_loop_lines {
            writeln!(property_validators, "{}", line).unwrap();
        }
        writeln!(property_validators, "{}", "}").unwrap();
        writeln!(property_validators, "").unwrap();

        if !shape.targets.is_empty() {
            emit_target_collector(&mut targets, shape, &term_iri, &term_expr)?;
            writeln!(property_validators, "pub fn validate_property_shape_{}(store: &Store, graph: Option<GraphNameRef<'_>>, report: &mut Report) {{", shape.id).unwrap();
            writeln!(
                property_validators,
                "    let targets = collect_targets_prop_{}(store, graph);",
                shape.id
            )
            .unwrap();
            writeln!(property_validators, "{}", "    for focus in targets {").unwrap();
            writeln!(
                property_validators,
                "        validate_property_shape_{}_for_focus(store, graph, &focus, report);",
                shape.id
            )
            .unwrap();
            writeln!(property_validators, "{}", "    }").unwrap();
            writeln!(property_validators, "{}", "}").unwrap();
            writeln!(property_validators, "").unwrap();
        }
    }

    // Node shape validators.
    for shape in plan.shapes.iter().filter(|s| s.kind == PlanShapeKind::Node) {
        let has_closed = shape.constraints.iter().any(|comp_id| {
            component_lookup
                .get(comp_id)
                .map(|c| c.kind == ComponentKind::Closed)
                .unwrap_or(false)
        });
        if has_closed {
            let preds = allowed_predicate_map
                .get(&shape.id)
                .cloned()
                .unwrap_or_default();
            writeln!(
                allowed_predicates,
                "fn allowed_predicates_{}() -> HashSet<String> {{",
                shape.id
            )
            .unwrap();
            writeln!(
                allowed_predicates,
                "    let mut set: HashSet<String> = HashSet::new();"
            )
            .unwrap();
            for pred in preds {
                writeln!(
                    allowed_predicates,
                    "    set.insert(\"{}\".to_string());",
                    escape_rust_string(&pred)
                )
                .unwrap();
            }
            writeln!(allowed_predicates, "    set").unwrap();
            writeln!(allowed_predicates, "{}", "}").unwrap();
            writeln!(allowed_predicates, "").unwrap();
        }
    }

    // Node shape validators.
    for shape in plan.shapes.iter().filter(|s| s.kind == PlanShapeKind::Node) {
        if shape.deactivated {
            continue;
        }
        emit_target_collector(&mut targets, shape, &term_iri, &term_expr)?;

        writeln!(node_validators, "fn validate_node_shape_{}_for_focus(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term, report: &mut Report) {{", shape.id).unwrap();
        if shape.constraints.is_empty() {
            writeln!(
                node_validators,
                "    let _ = (store, graph, focus, report);"
            )
            .unwrap();
        } else {
            for component_id in &shape.constraints {
                let component = component_lookup
                    .get(component_id)
                    .ok_or_else(|| format!("Missing component {}", component_id))?;
                let handler = registry::lookup(component.kind);
                let ctx = EmitContext {
                    shape_id: shape.id,
                    component_id: component.id,
                    kind: component.kind,
                    path_iri: None,
                    term_iri: &term_iri,
                    term_expr: &term_expr,
                    term_sparql: &term_sparql,
                    qualified_siblings: None,
                };
                let emission = handler.emit_node(ctx, &component.params)?;
                for line in emission.lines {
                    writeln!(node_validators, "{}", line).unwrap();
                }
            }
        }
        writeln!(node_validators, "{}", "}").unwrap();
        writeln!(node_validators, "").unwrap();

        writeln!(node_validators, "fn node_shape_conforms_{}(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term) -> bool {{", shape.id).unwrap();
        writeln!(node_validators, "    let mut report = Report::default();").unwrap();
        writeln!(
            node_validators,
            "    validate_node_shape_{}_for_focus(store, graph, focus, &mut report);",
            shape.id
        )
        .unwrap();
        writeln!(node_validators, "    report.violations.is_empty()").unwrap();
        writeln!(node_validators, "{}", "}").unwrap();
        writeln!(node_validators, "").unwrap();

        writeln!(node_validators, "pub fn validate_node_shape_{}(store: &Store, graph: Option<GraphNameRef<'_>>, report: &mut Report) {{", shape.id).unwrap();
        writeln!(
            node_validators,
            "    let targets = collect_targets_node_{}(store, graph);",
            shape.id
        )
        .unwrap();
        writeln!(node_validators, "{}", "    for focus in targets {").unwrap();
        writeln!(
            node_validators,
            "        validate_node_shape_{}_for_focus(store, graph, &focus, report);",
            shape.id
        )
        .unwrap();
        writeln!(node_validators, "{}", "    }").unwrap();
        writeln!(node_validators, "{}", "}").unwrap();
        writeln!(node_validators, "").unwrap();
    }

    writeln!(
        run,
        "{}",
        "type ValidateFn = for<'a> fn(&Store, Option<GraphNameRef<'a>>, &mut Report);"
    )
    .unwrap();
    writeln!(run, "{}", "struct ThreadState {").unwrap();
    writeln!(run, "    closure: Option<SubclassClosure>,").unwrap();
    writeln!(run, "{}", "}").unwrap();
    writeln!(run, "").unwrap();
    writeln!(run, "{}", "const NODE_SHAPE_VALIDATORS: &[ValidateFn] = &[").unwrap();
    for shape_id in &plan.order.node_shapes {
        let shape = node_shape_lookup
            .get(shape_id)
            .ok_or_else(|| format!("Missing node shape {}", shape_id))?;
        if shape.deactivated {
            continue;
        }
        writeln!(run, "    validate_node_shape_{},", shape.id).unwrap();
    }
    writeln!(run, "];").unwrap();
    writeln!(
        run,
        "{}",
        "const PROPERTY_SHAPE_VALIDATORS: &[ValidateFn] = &["
    )
    .unwrap();
    for shape_id in &plan.order.property_shapes {
        let shape = property_shape_lookup
            .get(shape_id)
            .ok_or_else(|| format!("Missing property shape {}", shape_id))?;
        if shape.deactivated || shape.targets.is_empty() {
            continue;
        }
        writeln!(run, "    validate_property_shape_{},", shape.id).unwrap();
    }
    writeln!(run, "];").unwrap();
    writeln!(run, "").unwrap();
    writeln!(
        run,
        "{}",
        "pub fn run(store: &Store, data_graph: Option<&NamedNode>) -> Report {"
    )
    .unwrap();
    writeln!(run, "    let default_data_graph = data_graph_named();").unwrap();
    writeln!(
        run,
        "    let graph_node = data_graph.unwrap_or(&default_data_graph);"
    )
    .unwrap();
    writeln!(run, "    let graph = graph_ref(None);").unwrap();
    writeln!(run, "    let mut report = Report::default();").unwrap();
    writeln!(run, "    info!(\"Starting shape graph load\");").unwrap();
    writeln!(run, "    insert_shape_triples(store);").unwrap();
    writeln!(run, "    info!(\"Finished shape graph load\");").unwrap();
    writeln!(
        run,
        "    set_current_subclass_closure(subclass_closure_from_shape_edges());"
    )
    .unwrap();
    writeln!(
        run,
        "    extend_current_subclass_closure_from_store(store, Some(shape_graph_ref()));"
    )
    .unwrap();
    writeln!(
        run,
        "    extend_current_subclass_closure_from_store(store, None);"
    )
    .unwrap();
    writeln!(run, "    clear_target_class_caches();").unwrap();
    writeln!(run, "{}", "    info!(\"Starting inference\");").unwrap();
    writeln!(
        run,
        "{}",
        "    match run_inference(store, graph, graph_node) {"
    )
    .unwrap();
    writeln!(run, "{}", "        Ok(_) => info!(\"Finished inference\"),").unwrap();
    writeln!(run, "{}", "        Err(err) => {").unwrap();
    writeln!(
        run,
        "{}",
        "            eprintln!(\"Inference failed: {}\", err);"
    )
    .unwrap();
    writeln!(run, "{}", "            info!(\"Inference failed\");").unwrap();
    writeln!(run, "{}", "        }").unwrap();
    writeln!(run, "{}", "    }").unwrap();
    writeln!(
        run,
        "    extend_current_subclass_closure_from_store(store, Some(GraphNameRef::NamedNode(graph_node.as_ref())));"
    )
    .unwrap();
    writeln!(run, "{}", "    info!(\"Starting validation\");").unwrap();
    writeln!(
        run,
        "    let validation_closure = with_subclass_closure(|closure| closure.clone());"
    )
    .unwrap();
    writeln!(run, "    let node_reports: Vec<Report> = NODE_SHAPE_VALIDATORS").unwrap();
    writeln!(run, "        .par_iter()").unwrap();
    writeln!(
        run,
        "{}",
        "        .map_init(|| ThreadState { closure: Some(validation_closure.clone()) }, |state, validator| {"
    )
    .unwrap();
    writeln!(
        run,
        "{}",
        "            if let Some(closure) = state.closure.take() {"
    )
    .unwrap();
    writeln!(run, "                init_thread_state(closure);").unwrap();
    writeln!(run, "{}", "            }").unwrap();
    writeln!(run, "            let mut local = Report::default();").unwrap();
    writeln!(run, "            validator(store, graph, &mut local);").unwrap();
    writeln!(run, "            local").unwrap();
    writeln!(run, "{}", "        })").unwrap();
    writeln!(run, "        .collect();").unwrap();
    writeln!(run, "{}", "    for local in node_reports {").unwrap();
    writeln!(run, "        report.merge(local);").unwrap();
    writeln!(run, "{}", "    }").unwrap();
    writeln!(
        run,
        "    let prop_reports: Vec<Report> = PROPERTY_SHAPE_VALIDATORS"
    )
    .unwrap();
    writeln!(run, "        .par_iter()").unwrap();
    writeln!(
        run,
        "{}",
        "        .map_init(|| ThreadState { closure: Some(validation_closure.clone()) }, |state, validator| {"
    )
    .unwrap();
    writeln!(
        run,
        "{}",
        "            if let Some(closure) = state.closure.take() {"
    )
    .unwrap();
    writeln!(run, "                init_thread_state(closure);").unwrap();
    writeln!(run, "{}", "            }").unwrap();
    writeln!(run, "            let mut local = Report::default();").unwrap();
    writeln!(run, "            validator(store, graph, &mut local);").unwrap();
    writeln!(run, "            local").unwrap();
    writeln!(run, "{}", "        })").unwrap();
    writeln!(run, "        .collect();").unwrap();
    writeln!(run, "{}", "    for local in prop_reports {").unwrap();
    writeln!(run, "        report.merge(local);").unwrap();
    writeln!(run, "{}", "    }").unwrap();
    writeln!(run, "{}", "    info!(\"Finished validation\");").unwrap();
    writeln!(run, "    report").unwrap();
    writeln!(run, "{}", "}").unwrap();
    writeln!(run, "").unwrap();
    Ok(Sections {
        prelude,
        helpers,
        paths,
        shape_triples,
        shape_graph_nt,
        targets,
        allowed_predicates,
        property_validators,
        node_validators,
        inference,
        run,
    })
}

fn emit_target_collector(
    out: &mut String,
    shape: &PlanShape,
    term_iri: &dyn Fn(u64) -> Result<String, String>,
    term_expr: &dyn Fn(u64) -> Result<String, String>,
) -> Result<(), String> {
    let func_prefix = match shape.kind {
        PlanShapeKind::Node => "node",
        PlanShapeKind::Property => "prop",
    };
    writeln!(
        out,
        "fn collect_targets_{}_{}(store: &Store, graph: Option<GraphNameRef<'_>>) -> Vec<Term> {{",
        func_prefix, shape.id
    )
    .unwrap();
    writeln!(out, "    let mut seen: HashSet<Term> = HashSet::new();").unwrap();
    writeln!(out, "    let mut out: Vec<Term> = Vec::new();").unwrap();
    for target in &shape.targets {
        match target {
            PlanTarget::Class(term_id) => {
                let class_iri = term_iri(*term_id)?;
                writeln!(
                    out,
                    "    for focus in targets_for_class(store, graph, \"{}\") {{",
                    class_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::Node(term_id) => {
                let node_expr = term_expr(*term_id)?;
                writeln!(out, "{}", "    {").unwrap();
                writeln!(out, "        let focus: Term = {};", node_expr).unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::SubjectsOf(term_id) => {
                let pred_iri = term_iri(*term_id)?;
                writeln!(
                    out,
                    "    let pred_ref = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "    for quad in store.quads_for_pattern(None, Some(pred_ref), None, graph) {"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "        let quad = match quad { Ok(quad) => quad, Err(_) => continue };"
                )
                .unwrap();
                writeln!(out, "        let focus: Term = quad.subject.into();").unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::ObjectsOf(term_id) => {
                let pred_iri = term_iri(*term_id)?;
                writeln!(
                    out,
                    "    let pred_ref = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "    for quad in store.quads_for_pattern(None, Some(pred_ref), None, graph) {"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "        let quad = match quad { Ok(quad) => quad, Err(_) => continue };"
                )
                .unwrap();
                writeln!(out, "        let focus: Term = quad.object;").unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::Advanced(term_id) => {
                let selector_expr = term_expr(*term_id)?;
                writeln!(out, "{}", "    {").unwrap();
                writeln!(out, "        let selector: Term = {};", selector_expr).unwrap();
                writeln!(
                    out,
                    "{}",
                    "        for focus in advanced_targets_for(store, &selector) {"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "            if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "        }").unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
        }
    }
    writeln!(out, "    out").unwrap();
    writeln!(out, "{}", "}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn term_iri(plan: &PlanIR, term_id: u64) -> Result<String, String> {
    let term = plan
        .terms
        .get(term_id as usize)
        .ok_or_else(|| format!("Unknown term id {}", term_id))?;
    match term {
        Term::NamedNode(node) => Ok(node.as_str().to_string()),
        _ => Err("Expected NamedNode term".to_string()),
    }
}

fn path_to_string(plan: &PlanIR, path_id: u64) -> Result<String, String> {
    path_to_string_inner(plan, path_id, false)
}

fn path_to_string_inner(plan: &PlanIR, path_id: u64, wrap: bool) -> Result<String, String> {
    let path = plan
        .paths
        .get(path_id as usize)
        .ok_or_else(|| format!("Unknown path id {}", path_id))?;
    let rendered = match path {
        PlanPath::Simple(term_id) => term_iri(plan, *term_id)?,
        PlanPath::Inverse(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("^{}", inner_str)
        }
        PlanPath::Sequence(paths) => {
            let mut parts = Vec::with_capacity(paths.len());
            for id in paths {
                parts.push(path_to_string_inner(plan, *id, true)?);
            }
            parts.join("/")
        }
        PlanPath::Alternative(paths) => {
            let mut parts = Vec::with_capacity(paths.len());
            for id in paths {
                parts.push(path_to_string_inner(plan, *id, true)?);
            }
            parts.join("|")
        }
        PlanPath::ZeroOrMore(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("{}*", inner_str)
        }
        PlanPath::OneOrMore(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("{}+", inner_str)
        }
        PlanPath::ZeroOrOne(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("{}?", inner_str)
        }
    };
    if wrap && !matches!(path, PlanPath::Simple(_)) {
        Ok(format!("({})", rendered))
    } else {
        Ok(rendered)
    }
}

fn simple_predicate(plan: &PlanIR, path_id: u64) -> Result<String, String> {
    let path = plan
        .paths
        .get(path_id as usize)
        .ok_or_else(|| format!("Unknown path id {}", path_id))?;
    match path {
        PlanPath::Simple(term_id) => term_iri(plan, *term_id),
        _ => Err("Only simple predicate paths are supported here".to_string()),
    }
}

fn emit_path_functions(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    if plan.paths.is_empty() {
        return Ok(());
    }
    for (id, path) in plan.paths.iter().enumerate() {
        emit_path_function(out, plan, id as u64, path, false)?;
        emit_path_function(out, plan, id as u64, path, true)?;
    }
    Ok(())
}

fn emit_inference(
    out: &mut String,
    plan: &PlanIR,
    term_expr: &dyn Fn(u64) -> Result<String, String>,
    term_iri: &dyn Fn(u64) -> Result<String, String>,
) -> Result<(), String> {
    let mut property_shape_targets: HashSet<u64> = HashSet::new();
    for shape in plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Property)
    {
        if !shape.targets.is_empty() {
            property_shape_targets.insert(shape.id);
        }
    }

    let mut rule_targets: HashMap<u64, (Vec<u64>, Vec<u64>)> = HashMap::new();
    for (shape_id, rule_ids) in &plan.node_shape_rules {
        for rule_id in rule_ids {
            let entry = rule_targets
                .entry(*rule_id)
                .or_insert_with(|| (Vec::new(), Vec::new()));
            entry.0.push(*shape_id);
        }
    }
    for (shape_id, rule_ids) in &plan.property_shape_rules {
        if !property_shape_targets.contains(shape_id) {
            continue;
        }
        for rule_id in rule_ids {
            let entry = rule_targets
                .entry(*rule_id)
                .or_insert_with(|| (Vec::new(), Vec::new()));
            entry.1.push(*shape_id);
        }
    }

    for (_, targets) in rule_targets.iter_mut() {
        targets.0.sort_unstable();
        targets.1.sort_unstable();
    }

    let rule_ids: Vec<u64> = plan.rules.iter().map(|rule| rule.id).collect();
    if rule_ids.is_empty() {
        writeln!(out, "const INFERENCE_MAX_ITERATIONS: usize = 32;").unwrap();
        writeln!(out, "const INFERENCE_RULE_IDS: [u64; 0] = [];").unwrap();
    } else {
        let list = rule_ids
            .iter()
            .map(|id| id.to_string())
            .collect::<Vec<_>>()
            .join(", ");
        writeln!(out, "const INFERENCE_MAX_ITERATIONS: usize = 32;").unwrap();
        writeln!(
            out,
            "const INFERENCE_RULE_IDS: [u64; {}] = [{}];",
            rule_ids.len(),
            list
        )
        .unwrap();
    }
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn run_inference(store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode) -> Result<(), String> {{"
    )
    .unwrap();
    writeln!(out, "    let mut iterations: usize = 0;").unwrap();
    writeln!(out, "    loop {{").unwrap();
    writeln!(
        out,
        "        info!(\"Starting inference iteration {{}}\", iterations);"
    )
    .unwrap();
    writeln!(
        out,
        "        let mut seen_new: HashSet<(Term, NamedNode, Term)> = HashSet::new();"
    )
    .unwrap();
    writeln!(
        out,
        "        let added = run_inference_iteration(store, graph, graph_node, &mut seen_new)?;"
    )
    .unwrap();
    writeln!(
        out,
        "        info!(\"Iteration {{}} added {{}} triples\", iterations, added);"
    )
    .unwrap();
    writeln!(
        out,
        "        if added == 0 || iterations >= INFERENCE_MAX_ITERATIONS {{"
    )
    .unwrap();
    writeln!(out, "            break;").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        iterations = iterations.saturating_add(1);").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    Ok(())").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn run_inference_iteration(store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode, seen_new: &mut HashSet<(Term, NamedNode, Term)>) -> Result<usize, String> {{"
    )
    .unwrap();
    writeln!(out, "    let mut added: usize = 0;").unwrap();
    writeln!(
        out,
        "    let mut node_target_cache: HashMap<u64, Vec<Term>> = HashMap::new();"
    )
    .unwrap();
    writeln!(
        out,
        "    let mut prop_target_cache: HashMap<u64, Vec<Term>> = HashMap::new();"
    )
    .unwrap();
    writeln!(out, "    for rule_id in INFERENCE_RULE_IDS {{").unwrap();
    writeln!(
        out,
        "        let focus_nodes = focus_nodes_for_rule(rule_id, store, graph, &mut node_target_cache, &mut prop_target_cache);"
    )
    .unwrap();
    writeln!(out, "        if focus_nodes.is_empty() {{").unwrap();
    writeln!(out, "            continue;").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(
            out,
            "        let delta = apply_inference_rule(rule_id, store, graph, graph_node, &focus_nodes, seen_new)?;"
        )
        .unwrap();
    writeln!(out, "        added += delta;").unwrap();
    writeln!(out, "{}", "        if delta > 0 {").unwrap();
    writeln!(out, "            node_target_cache.clear();").unwrap();
    writeln!(out, "            prop_target_cache.clear();").unwrap();
    writeln!(out, "            clear_target_class_caches();").unwrap();
    writeln!(out, "{}", "        }").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    Ok(added)").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn focus_nodes_for_rule(rule_id: u64, store: &Store, graph: Option<GraphNameRef<'_>>, node_target_cache: &mut HashMap<u64, Vec<Term>>, prop_target_cache: &mut HashMap<u64, Vec<Term>>) -> Vec<Term> {{"
    )
    .unwrap();
    writeln!(out, "    match rule_id {{").unwrap();
    for rule in &plan.rules {
        let targets = rule_targets.get(&rule.id);
        writeln!(out, "        {} => {{", rule.id).unwrap();
        writeln!(
            out,
            "            let mut seen: HashSet<Term> = HashSet::new();"
        )
        .unwrap();
        writeln!(out, "            let mut nodes: Vec<Term> = Vec::new();").unwrap();
        if let Some((node_shapes, prop_shapes)) = targets {
            for node_shape in node_shapes {
                writeln!(
                    out,
                    "            if !node_target_cache.contains_key(&{}) {{",
                    node_shape
                )
                .unwrap();
                writeln!(
                    out,
                    "                let targets = collect_targets_node_{}(store, graph);",
                    node_shape
                )
                .unwrap();
                writeln!(
                    out,
                    "                node_target_cache.insert({}, targets);",
                    node_shape
                )
                .unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(
                    out,
                    "            if let Some(targets) = node_target_cache.get(&{}) {{",
                    node_shape
                )
                .unwrap();
                writeln!(out, "{}", "                for focus in targets {").unwrap();
                writeln!(
                    out,
                    "                    if seen.insert(focus.clone()) {{ nodes.push(focus.clone()); }}"
                )
                .unwrap();
                writeln!(out, "                }}").unwrap();
                writeln!(out, "            }}").unwrap();
            }
            for prop_shape in prop_shapes {
                writeln!(
                    out,
                    "            if !prop_target_cache.contains_key(&{}) {{",
                    prop_shape
                )
                .unwrap();
                writeln!(
                    out,
                    "                let targets = collect_targets_prop_{}(store, graph);",
                    prop_shape
                )
                .unwrap();
                writeln!(
                    out,
                    "                prop_target_cache.insert({}, targets);",
                    prop_shape
                )
                .unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(
                    out,
                    "            if let Some(targets) = prop_target_cache.get(&{}) {{",
                    prop_shape
                )
                .unwrap();
                writeln!(out, "{}", "                for focus in targets {").unwrap();
                writeln!(
                    out,
                    "                    if seen.insert(focus.clone()) {{ nodes.push(focus.clone()); }}"
                )
                .unwrap();
                writeln!(out, "                }}").unwrap();
                writeln!(out, "            }}").unwrap();
            }
        }
        writeln!(out, "            nodes").unwrap();
        writeln!(out, "        }}").unwrap();
    }
    writeln!(out, "        _ => Vec::new(),").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn rule_conditions_satisfied(rule_id: u64, store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term) -> bool {{"
    )
    .unwrap();
    writeln!(out, "    match rule_id {{").unwrap();
    for rule in &plan.rules {
        if rule.conditions.is_empty() {
            continue;
        }
        writeln!(out, "        {} => {{", rule.id).unwrap();
        for shape in &rule.conditions {
            writeln!(
                out,
                "            if !node_shape_conforms_{}(store, graph, focus) {{",
                shape
            )
            .unwrap();
            writeln!(out, "                return false;").unwrap();
            writeln!(out, "            }}").unwrap();
        }
        writeln!(out, "            true").unwrap();
        writeln!(out, "        }}").unwrap();
    }
    writeln!(out, "        _ => true,").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn apply_inference_rule(rule_id: u64, store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode, focus_nodes: &[Term], seen_new: &mut HashSet<(Term, NamedNode, Term)>) -> Result<usize, String> {{"
    )
    .unwrap();
    writeln!(out, "    match rule_id {{").unwrap();
    for rule in &plan.rules {
        writeln!(
            out,
            "        {} => inference_rule_{}(store, graph, graph_node, focus_nodes, seen_new),",
            rule.id, rule.id
        )
        .unwrap();
    }
    writeln!(out, "        _ => Ok(0),").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    for rule in &plan.rules {
        match &rule.kind {
            PlanRuleKind::Triple {
                subject,
                predicate,
                object,
            } => {
                let predicate_expr = term_iri(*predicate)?;
                writeln!(
                    out,
                    "fn inference_rule_{}(store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode, focus_nodes: &[Term], seen_new: &mut HashSet<(Term, NamedNode, Term)>) -> Result<usize, String> {{",
                    rule.id
                )
                .unwrap();
                writeln!(
                    out,
                    "    let predicate = NamedNode::new(\"{}\").unwrap();",
                    escape_rust_string(&predicate_expr)
                )
                .unwrap();
                writeln!(out, "    let mut added: usize = 0;").unwrap();
                writeln!(out, "    for focus in focus_nodes {{").unwrap();
                writeln!(
                    out,
                    "        if !rule_conditions_satisfied({}, store, graph, focus) {{",
                    rule.id
                )
                .unwrap();
                writeln!(out, "            continue;").unwrap();
                writeln!(out, "        }}").unwrap();

                writeln!(out, "        let subjects = {{").unwrap();
                match subject {
                    crate::plan::PlanRuleTerm::This => {
                        writeln!(out, "            let mut values = Vec::new();").unwrap();
                        writeln!(out, "            values.push(focus.clone());").unwrap();
                        writeln!(out, "            values").unwrap();
                    }
                    crate::plan::PlanRuleTerm::Constant(term_id) => {
                        let term_expr = term_expr(*term_id)?;
                        writeln!(out, "            let mut values = Vec::new();").unwrap();
                        writeln!(out, "            values.push({});", term_expr).unwrap();
                        writeln!(out, "            values").unwrap();
                    }
                    crate::plan::PlanRuleTerm::Path(path_id) => {
                        writeln!(out, "            path_{}(store, graph, focus)", path_id).unwrap();
                    }
                }
                writeln!(out, "        }};").unwrap();

                writeln!(out, "        let objects = {{").unwrap();
                match object {
                    crate::plan::PlanRuleTerm::This => {
                        writeln!(out, "            let mut values = Vec::new();").unwrap();
                        writeln!(out, "            values.push(focus.clone());").unwrap();
                        writeln!(out, "            values").unwrap();
                    }
                    crate::plan::PlanRuleTerm::Constant(term_id) => {
                        let term_expr = term_expr(*term_id)?;
                        writeln!(out, "            let mut values = Vec::new();").unwrap();
                        writeln!(out, "            values.push({});", term_expr).unwrap();
                        writeln!(out, "            values").unwrap();
                    }
                    crate::plan::PlanRuleTerm::Path(path_id) => {
                        writeln!(out, "            path_{}(store, graph, focus)", path_id).unwrap();
                    }
                }
                writeln!(out, "        }};").unwrap();

                writeln!(out, "        for subject_term in &subjects {{").unwrap();
                writeln!(out, "            for object_term in &objects {{").unwrap();
                writeln!(
                    out,
                    "                if record_inferred_quad(store, graph_node, seen_new, subject_term.clone(), predicate.clone(), object_term.clone())? {{"
                )
                .unwrap();
                writeln!(out, "                    added += 1;").unwrap();
                writeln!(out, "                }}").unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(out, "        }}").unwrap();
                writeln!(out, "    }}").unwrap();
                writeln!(out, "    Ok(added)").unwrap();
                writeln!(out, "}}").unwrap();
                writeln!(out, "").unwrap();
            }
            PlanRuleKind::Sparql { query } => {
                let escaped_query = escape_rust_string(query);
                writeln!(
                    out,
                    "fn inference_rule_{}(store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode, focus_nodes: &[Term], seen_new: &mut HashSet<(Term, NamedNode, Term)>) -> Result<usize, String> {{",
                    rule.id
                )
                .unwrap();
                writeln!(
                    out,
                    "    let mut prepared = SparqlEvaluator::new().parse_query(\"{}\").map_err(|e| format!(\"Failed to parse inference query {{}}: {{}}\", {}, e))?;",
                    escaped_query,
                    rule.id
                )
                .unwrap();
                writeln!(
                    out,
                    "    prepared.dataset_mut().set_default_graph_as_union();"
                )
                .unwrap();
                writeln!(
                    out,
                    "    let var_this = Variable::new(\"this\").map_err(|e| format!(\"Inference rule {{}} failed to build variable: {{}}\", {}, e))?;",
                    rule.id
                )
                .unwrap();
                writeln!(out, "    let mut added: usize = 0;").unwrap();
                writeln!(out, "    for focus in focus_nodes {{").unwrap();
                writeln!(
                    out,
                    "        if !rule_conditions_satisfied({}, store, graph, focus) {{",
                    rule.id
                )
                .unwrap();
                writeln!(out, "            continue;").unwrap();
                writeln!(out, "        }}").unwrap();
                writeln!(
                    out,
                    "        let mut bound = prepared.clone().on_store(store);"
                )
                .unwrap();
                writeln!(
                    out,
                    "        bound = bound.substitute_variable(var_this.clone(), focus.clone());"
                )
                .unwrap();
                writeln!(out, "        match bound.execute() {{").unwrap();
                writeln!(
                    out,
                    "            Ok(QueryResults::Graph(mut triples)) => {{"
                )
                .unwrap();
                writeln!(out, "                for triple_res in &mut triples {{").unwrap();
                writeln!(
                    out,
                    "                    let triple = triple_res.map_err(|e| format!(\"Inference rule {{}} failed: {{}}\", {}, e))?;",
                    rule.id
                )
                .unwrap();
                writeln!(out, "                    let subject_term = named_or_blank_to_term(&triple.subject);").unwrap();
                writeln!(out, "                    let object_term = triple.object;").unwrap();
                writeln!(out, "                    let predicate = triple.predicate;").unwrap();
                writeln!(out, "                    if record_inferred_quad(store, graph_node, seen_new, subject_term.clone(), predicate.clone(), object_term.clone())? {{").unwrap();
                writeln!(out, "                        added += 1;").unwrap();
                writeln!(out, "                    }}").unwrap();
                writeln!(out, "                }}").unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(out, "            Ok(_) => {{").unwrap();
                writeln!(
                    out,
                    "                return Err(format!(\"Inference rule {{}} returned non-graph result\", {}));",
                    rule.id
                )
                .unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(out, "            Err(e) => {{").unwrap();
                writeln!(out, "                return Err(e.to_string());").unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(out, "        }}").unwrap();
                writeln!(out, "    }}").unwrap();
                writeln!(out, "    Ok(added)").unwrap();
                writeln!(out, "}}").unwrap();
                writeln!(out, "").unwrap();
            }
        }
    }

    writeln!(
        out,
        "fn record_inferred_quad(store: &Store, graph_node: &NamedNode, seen_new: &mut HashSet<(Term, NamedNode, Term)>, subject_term: Term, predicate: NamedNode, object_term: Term) -> Result<bool, String> {{"
    )
    .unwrap();
    writeln!(
        out,
        "    let key = (subject_term.clone(), predicate.clone(), object_term.clone());"
    )
    .unwrap();
    writeln!(out, "    if seen_new.contains(&key) {{").unwrap();
    writeln!(out, "        return Ok(false);").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(
        out,
        "    let subject = term_to_named_or_blank_inference(&subject_term)?;"
    )
    .unwrap();
    writeln!(
        out,
        "    let graph = GraphName::NamedNode(graph_node.clone());"
    )
    .unwrap();
    writeln!(
        out,
        "    let quad = Quad::new(subject.clone(), predicate.clone(), object_term.clone(), graph.clone());"
    )
    .unwrap();
    writeln!(
        out,
        "    if store.contains(&quad).map_err(|e| e.to_string())? {{"
    )
    .unwrap();
    writeln!(out, "        return Ok(false);").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(
        out,
        "    store.insert(quad.as_ref()).map_err(|e| e.to_string())?;"
    )
    .unwrap();
    writeln!(out, "    seen_new.insert(key);").unwrap();
    writeln!(out, "    Ok(true)").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn term_to_named_or_blank_inference(term: &Term) -> Result<NamedOrBlankNode, String> {{"
    )
    .unwrap();
    writeln!(out, "    match term {{").unwrap();
    writeln!(
        out,
        "        Term::NamedNode(node) => Ok(node.clone().into()),"
    )
    .unwrap();
    writeln!(out, "        Term::BlankNode(bn) => Ok(bn.clone().into()),").unwrap();
    writeln!(
        out,
        "        other => Err(format!(\"Inference subject must be IRI or blank node, found {{:?}}\", other)),"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn named_or_blank_to_term(value: &NamedOrBlankNode) -> Term {{"
    )
    .unwrap();
    writeln!(out, "    match value {{").unwrap();
    writeln!(
        out,
        "        NamedOrBlankNode::NamedNode(nn) => Term::NamedNode(nn.clone()),"
    )
    .unwrap();
    writeln!(
        out,
        "        NamedOrBlankNode::BlankNode(bn) => Term::BlankNode(bn.clone()),"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();

    Ok(())
}

fn emit_path_function(
    out: &mut String,
    plan: &PlanIR,
    path_id: u64,
    path: &PlanPath,
    reverse: bool,
) -> Result<(), String> {
    let func_name = if reverse {
        format!("path_{}_rev", path_id)
    } else {
        format!("path_{}", path_id)
    };
    writeln!(
        out,
        "fn {}(store: &Store, graph: Option<GraphNameRef<'_>>, start: &Term) -> Vec<Term> {{",
        func_name
    )
    .unwrap();
    match path {
        PlanPath::Simple(term_id) => {
            let pred_iri = term_iri(plan, *term_id)?;
            let pred_iri = escape_rust_string(&pred_iri);
            if reverse {
                writeln!(
                    out,
                    "    let predicate = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(out, "    let object = term_ref(start);").unwrap();
                writeln!(
                    out,
                    "{}",
                    "    store.quads_for_pattern(None, Some(predicate), Some(object), graph)"
                )
                .unwrap();
                writeln!(out, "        .filter_map(Result::ok)").unwrap();
                writeln!(out, "        .map(|q| q.subject.into())").unwrap();
                writeln!(out, "        .collect()").unwrap();
            } else {
                writeln!(out, "{}", "    let subject = match subject_ref(start) { Some(s) => s, None => return Vec::new() };").unwrap();
                writeln!(
                    out,
                    "    let predicate = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "    store.quads_for_pattern(Some(subject), Some(predicate), None, graph)"
                )
                .unwrap();
                writeln!(out, "        .filter_map(Result::ok)").unwrap();
                writeln!(out, "        .map(|q| q.object)").unwrap();
                writeln!(out, "        .collect()").unwrap();
            }
        }
        PlanPath::Inverse(inner) => {
            if reverse {
                writeln!(out, "    path_{}(store, graph, start)", inner).unwrap();
            } else {
                writeln!(out, "    path_{}_rev(store, graph, start)", inner).unwrap();
            }
        }
        PlanPath::Sequence(paths) => {
            writeln!(
                out,
                "{}",
                "    let mut current: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(out, "    current.insert(start.clone());").unwrap();
            let ids: Vec<u64> = if reverse {
                paths.iter().rev().cloned().collect()
            } else {
                paths.clone()
            };
            for id in ids {
                writeln!(
                    out,
                    "{}",
                    "    let mut next: HashSet<Term> = HashSet::new();"
                )
                .unwrap();
                writeln!(out, "{}", "    for node in current {").unwrap();
                if reverse {
                    writeln!(
                        out,
                        "        for value in path_{}_rev(store, graph, &node) {{",
                        id
                    )
                    .unwrap();
                } else {
                    writeln!(
                        out,
                        "        for value in path_{}(store, graph, &node) {{",
                        id
                    )
                    .unwrap();
                }
                writeln!(out, "            next.insert(value);").unwrap();
                writeln!(out, "{}", "        }").unwrap();
                writeln!(out, "{}", "    }").unwrap();
                writeln!(out, "    current = next;").unwrap();
                writeln!(
                    out,
                    "{}",
                    "    if current.is_empty() { return Vec::new(); }"
                )
                .unwrap();
            }
            writeln!(out, "    current.into_iter().collect()").unwrap();
        }
        PlanPath::Alternative(paths) => {
            writeln!(
                out,
                "{}",
                "    let mut out_set: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            for id in paths {
                if reverse {
                    writeln!(
                        out,
                        "    for value in path_{}_rev(store, graph, start) {{",
                        id
                    )
                    .unwrap();
                } else {
                    writeln!(out, "    for value in path_{}(store, graph, start) {{", id).unwrap();
                }
                writeln!(out, "        out_set.insert(value);").unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            writeln!(out, "    out_set.into_iter().collect()").unwrap();
        }
        PlanPath::ZeroOrMore(inner) => {
            writeln!(
                out,
                "{}",
                "    let mut seen: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(
                out,
                "{}",
                "    let mut queue: VecDeque<Term> = VecDeque::new();"
            )
            .unwrap();
            writeln!(out, "    seen.insert(start.clone());").unwrap();
            writeln!(out, "    queue.push_back(start.clone());").unwrap();
            writeln!(out, "{}", "    while let Some(node) = queue.pop_front() {").unwrap();
            if reverse {
                writeln!(
                    out,
                    "        for value in path_{}_rev(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "        for value in path_{}(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "{}", "            if seen.insert(value.clone()) {").unwrap();
            writeln!(out, "                queue.push_back(value);").unwrap();
            writeln!(out, "{}", "            }").unwrap();
            writeln!(out, "{}", "        }").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "    seen.into_iter().collect()").unwrap();
        }
        PlanPath::OneOrMore(inner) => {
            writeln!(
                out,
                "{}",
                "    let mut seen: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(
                out,
                "{}",
                "    let mut queue: VecDeque<Term> = VecDeque::new();"
            )
            .unwrap();
            if reverse {
                writeln!(
                    out,
                    "    for value in path_{}_rev(store, graph, start) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "    for value in path_{}(store, graph, start) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "{}", "        if seen.insert(value.clone()) {").unwrap();
            writeln!(out, "            queue.push_back(value);").unwrap();
            writeln!(out, "{}", "        }").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "{}", "    while let Some(node) = queue.pop_front() {").unwrap();
            if reverse {
                writeln!(
                    out,
                    "        for value in path_{}_rev(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "        for value in path_{}(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "{}", "            if seen.insert(value.clone()) {").unwrap();
            writeln!(out, "                queue.push_back(value);").unwrap();
            writeln!(out, "{}", "            }").unwrap();
            writeln!(out, "{}", "        }").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "    seen.into_iter().collect()").unwrap();
        }
        PlanPath::ZeroOrOne(inner) => {
            writeln!(
                out,
                "{}",
                "    let mut out_set: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(out, "    out_set.insert(start.clone());").unwrap();
            if reverse {
                writeln!(
                    out,
                    "    for value in path_{}_rev(store, graph, start) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "    for value in path_{}(store, graph, start) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "        out_set.insert(value);").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "    out_set.into_iter().collect()").unwrap();
        }
    }
    writeln!(out, "{}", "}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_shape_triples(
    out: &mut String,
    shape_graph_nt: &mut String,
    plan: &PlanIR,
) -> Result<(), String> {
    let shape_graph_iri = term_iri(plan, plan.shape_graph)?;
    for triple in &plan.shape_triples {
        let subject_term = plan
            .terms
            .get(triple.subject as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.subject))?;
        let predicate_term = plan
            .terms
            .get(triple.predicate as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.predicate))?;
        let object_term = plan
            .terms
            .get(triple.object as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.object))?;
        let subj_nt = term_to_nt(subject_term)?;
        let pred_nt = term_to_nt(predicate_term)?;
        let obj_nt = term_to_nt(object_term)?;
        writeln!(shape_graph_nt, "{} {} {} .", subj_nt, pred_nt, obj_nt).unwrap();
    }

    writeln!(
        out,
        "{}",
        "const SHAPE_GRAPH_NT: &str = include_str!(\"shape_graph.nt\");"
    )
    .unwrap();
    writeln!(out, "{}", "fn insert_shape_triples(store: &Store) {").unwrap();
    writeln!(
        out,
        "    let shape_graph = GraphName::NamedNode(NamedNode::new(\"{}\").unwrap());",
        escape_rust_string(&shape_graph_iri)
    )
    .unwrap();
    writeln!(
        out,
        "    let parser = RdfParser::from_format(RdfFormat::NTriples).for_slice(SHAPE_GRAPH_NT.as_bytes());"
    )
    .unwrap();
    writeln!(out, "{}", "    for triple in parser {").unwrap();
    writeln!(
        out,
        "{}",
        "        let triple = match triple { Ok(t) => t, Err(_) => continue };"
    )
    .unwrap();
    writeln!(out, "        let quad = Quad::new(triple.subject, triple.predicate, triple.object, shape_graph.clone());").unwrap();
    writeln!(out, "        let _ = store.insert(quad.as_ref());").unwrap();
    writeln!(out, "{}", "    }").unwrap();
    writeln!(out, "{}", "}").unwrap();
    writeln!(out, "").unwrap();

    Ok(())
}

fn emit_subclass_edges(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    let edges = collect_subclass_edges(plan)?;
    writeln!(out, "const SHAPE_SUBCLASS_EDGES: &[(&str, &str)] = &[").unwrap();
    for (sub, sup) in edges {
        writeln!(
            out,
            "    (\"{}\", \"{}\"),",
            escape_rust_string(&sub),
            escape_rust_string(&sup)
        )
        .unwrap();
    }
    writeln!(out, "];").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn collect_subclass_edges(plan: &PlanIR) -> Result<Vec<(String, String)>, String> {
    let mut edges = Vec::new();
    for triple in &plan.shape_triples {
        let predicate_term = plan
            .terms
            .get(triple.predicate as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.predicate))?;
        if let Term::NamedNode(node) = predicate_term {
            if node.as_str() != "http://www.w3.org/2000/01/rdf-schema#subClassOf" {
                continue;
            }
        } else {
            continue;
        }

        let subject = match term_iri(plan, triple.subject) {
            Ok(value) => value,
            Err(_) => continue,
        };
        let object = match term_iri(plan, triple.object) {
            Ok(value) => value,
            Err(_) => continue,
        };
        edges.push((subject, object));
    }
    Ok(edges)
}

fn term_expr_id(plan: &PlanIR, term_id: u64) -> Result<String, String> {
    let term = plan
        .terms
        .get(term_id as usize)
        .ok_or_else(|| format!("Unknown term id {}", term_id))?;
    term_expr(term)
}

fn term_sparql_const(plan: &PlanIR, term_id: u64) -> Result<String, String> {
    let term = plan
        .terms
        .get(term_id as usize)
        .ok_or_else(|| format!("Unknown term id {}", term_id))?;
    Ok(term.to_string())
}

fn build_qualified_sibling_map(
    plan: &PlanIR,
    component_lookup: &HashMap<CompId, &crate::plan::PlanComponent>,
) -> HashMap<CompId, Vec<u64>> {
    let mut prop_shapes_by_node: HashMap<u64, Vec<u64>> = HashMap::new();
    for shape in &plan.shapes {
        if shape.kind != PlanShapeKind::Node {
            continue;
        }
        let mut props = Vec::new();
        for comp_id in &shape.constraints {
            if let Some(component) = component_lookup.get(comp_id) {
                if component.kind == ComponentKind::Property {
                    if let crate::plan::ComponentParams::Property { shape } = component.params {
                        props.push(shape);
                    }
                }
            }
        }
        prop_shapes_by_node.insert(shape.id, props);
    }

    let mut qualified_by_prop: HashMap<u64, Vec<(CompId, u64)>> = HashMap::new();
    for shape in &plan.shapes {
        if shape.kind != PlanShapeKind::Property {
            continue;
        }
        let mut comps = Vec::new();
        for comp_id in &shape.constraints {
            if let Some(component) = component_lookup.get(comp_id) {
                if component.kind == ComponentKind::QualifiedValueShape {
                    if let crate::plan::ComponentParams::QualifiedValueShape { shape, .. } =
                        component.params
                    {
                        comps.push((component.id, shape));
                    }
                }
            }
        }
        if !comps.is_empty() {
            qualified_by_prop.insert(shape.id, comps);
        }
    }

    let mut siblings: HashMap<CompId, Vec<u64>> = HashMap::new();
    for (_, props) in prop_shapes_by_node {
        let mut all: Vec<(CompId, u64)> = Vec::new();
        for prop_id in props {
            if let Some(list) = qualified_by_prop.get(&prop_id) {
                all.extend(list.iter().cloned());
            }
        }
        for (comp_id, _) in &all {
            let mut sibs = Vec::new();
            for (other_id, shape_id) in &all {
                if other_id == comp_id {
                    continue;
                }
                sibs.push(*shape_id);
            }
            siblings.insert(*comp_id, sibs);
        }
    }

    siblings
}

fn build_allowed_predicate_map(
    plan: &PlanIR,
    component_lookup: &HashMap<CompId, &crate::plan::PlanComponent>,
    property_shape_lookup: &HashMap<u64, &PlanShape>,
) -> Result<HashMap<u64, Vec<String>>, String> {
    let mut allowed: HashMap<u64, Vec<String>> = HashMap::new();
    for shape in plan.shapes.iter().filter(|s| s.kind == PlanShapeKind::Node) {
        let mut predicates = Vec::new();
        for comp_id in &shape.constraints {
            if let Some(component) = component_lookup.get(comp_id) {
                if component.kind == ComponentKind::Property {
                    if let crate::plan::ComponentParams::Property { shape: prop_id } =
                        component.params
                    {
                        if let Some(prop_shape) = property_shape_lookup.get(&prop_id) {
                            if let Some(path_id) = prop_shape.path {
                                if let Ok(iri) = simple_predicate(plan, path_id) {
                                    predicates.push(iri);
                                }
                            }
                        }
                    }
                }
            }
        }
        allowed.insert(shape.id, predicates);
    }
    Ok(allowed)
}

fn subject_expr(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!(
            "NamedOrBlankNode::NamedNode(NamedNode::new(\"{}\").unwrap())",
            escape_rust_string(node.as_str())
        )),
        Term::BlankNode(node) => Ok(format!(
            "NamedOrBlankNode::BlankNode(BlankNode::new_unchecked(\"{}\"))",
            escape_rust_string(node.as_str())
        )),
        _ => Err("Invalid subject term for shape triple".to_string()),
    }
}

fn named_node_expr(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!(
            "NamedNode::new(\"{}\").unwrap()",
            escape_rust_string(node.as_str())
        )),
        _ => Err("Invalid predicate term for shape triple".to_string()),
    }
}

fn term_expr(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!(
            "Term::NamedNode(NamedNode::new(\"{}\").unwrap())",
            escape_rust_string(node.as_str())
        )),
        Term::BlankNode(node) => Ok(format!(
            "Term::BlankNode(BlankNode::new_unchecked(\"{}\"))",
            escape_rust_string(node.as_str())
        )),
        Term::Literal(lit) => {
            if let Some(lang) = lit.language() {
                Ok(format!(
                    "Term::Literal(Literal::new_language_tagged_literal(\"{}\", \"{}\").unwrap())",
                    escape_rust_string(lit.value()),
                    escape_rust_string(lang)
                ))
            } else if lit.datatype().as_str() == "http://www.w3.org/2001/XMLSchema#string" {
                Ok(format!(
                    "Term::Literal(Literal::new_simple_literal(\"{}\"))",
                    escape_rust_string(lit.value())
                ))
            } else {
                Ok(format!(
                    "Term::Literal(Literal::new_typed_literal(\"{}\", NamedNode::new(\"{}\").unwrap()))",
                    escape_rust_string(lit.value()),
                    escape_rust_string(lit.datatype().as_str())
                ))
            }
        }
    }
}

fn term_to_nt(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!("<{}>", escape_nt_iri(node.as_str()))),
        Term::BlankNode(node) => Ok(format!("_:{}", node.as_str())),
        Term::Literal(lit) => {
            let mut out = String::new();
            out.push('"');
            out.push_str(&escape_nt_string(lit.value()));
            out.push('"');
            if let Some(lang) = lit.language() {
                out.push('@');
                out.push_str(lang);
            } else {
                out.push_str("^^<");
                out.push_str(&escape_nt_iri(lit.datatype().as_str()));
                out.push('>');
            }
            Ok(out)
        }
    }
}

fn escape_nt_string(value: &str) -> String {
    let mut out = String::with_capacity(value.len());
    for ch in value.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            ch if ch <= '\u{1F}' || ch == '\u{7F}' => {
                out.push_str(&format!("\\u{:04X}", ch as u32))
            }
            ch => out.push(ch),
        }
    }
    out
}

fn escape_nt_iri(value: &str) -> String {
    let mut out = String::with_capacity(value.len());
    for ch in value.chars() {
        match ch {
            '<' | '>' | '"' | '{' | '}' | '|' | '^' | '`' | '\\' => {
                out.push_str(&format!("\\u{:04X}", ch as u32))
            }
            ch if ch <= '\u{1F}' || ch == '\u{7F}' => {
                out.push_str(&format!("\\u{:04X}", ch as u32))
            }
            ch => out.push(ch),
        }
    }
    out
}

fn escape_rust_string(value: &str) -> String {
    value
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn severity_to_iri_string(severity: &Severity) -> Result<String, String> {
    match severity {
        Severity::Info => Ok("http://www.w3.org/ns/shacl#Info".to_string()),
        Severity::Warning => Ok("http://www.w3.org/ns/shacl#Warning".to_string()),
        Severity::Violation => Ok("http://www.w3.org/ns/shacl#Violation".to_string()),
        Severity::Custom(term) => Ok(term.as_str().to_string()),
    }
}

fn emit_shape_and_component_maps(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    emit_shape_iri_map(out, plan)?;
    emit_component_iri_map(out, plan)?;
    emit_severity_map(out, plan)?;
    Ok(())
}

fn emit_shape_iri_map(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    writeln!(out, "fn shape_iri(shape_id: u64) -> &'static str {{").unwrap();
    writeln!(out, "    match shape_id {{").unwrap();
    for shape in &plan.shapes {
        let iri = term_iri(plan, shape.term)?;
        writeln!(
            out,
            "        {} => \"{}\",",
            shape.id,
            escape_rust_string(&iri)
        )
        .unwrap();
    }
    writeln!(out, "        _ => \"\",").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_component_iri_map(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    writeln!(
        out,
        "fn component_iri(component_id: u64) -> &'static str {{"
    )
    .unwrap();
    writeln!(out, "    match component_id {{").unwrap();
    for component in &plan.components {
        writeln!(
            out,
            "        {} => \"{}\",",
            component.id,
            escape_rust_string(constraint_component_iri(component.kind))
        )
        .unwrap();
    }
    writeln!(
        out,
        "        _ => \"http://www.w3.org/ns/shacl#ConstraintComponent\","
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_severity_map(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    writeln!(out, "fn severity_term(shape_id: u64) -> &'static str {{").unwrap();
    writeln!(out, "    match shape_id {{").unwrap();
    for shape in &plan.shapes {
        let severity_str = severity_to_iri_string(&shape.severity)?;
        writeln!(
            out,
            "        {} => \"{}\",",
            shape.id,
            escape_rust_string(&severity_str)
        )
        .unwrap();
    }
    writeln!(
        out,
        "        _ => \"http://www.w3.org/ns/shacl#Violation\","
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn constraint_component_iri(kind: ComponentKind) -> &'static str {
    match kind {
        ComponentKind::Node => "http://www.w3.org/ns/shacl#node",
        ComponentKind::Property => "http://www.w3.org/ns/shacl#property",
        ComponentKind::QualifiedValueShape => "http://www.w3.org/ns/shacl#qualifiedValueShape",
        ComponentKind::Class => "http://www.w3.org/ns/shacl#class",
        ComponentKind::Datatype => "http://www.w3.org/ns/shacl#datatype",
        ComponentKind::NodeKind => "http://www.w3.org/ns/shacl#nodeKind",
        ComponentKind::MinCount => "http://www.w3.org/ns/shacl#minCount",
        ComponentKind::MaxCount => "http://www.w3.org/ns/shacl#maxCount",
        ComponentKind::MinExclusive => "http://www.w3.org/ns/shacl#minExclusive",
        ComponentKind::MinInclusive => "http://www.w3.org/ns/shacl#minInclusive",
        ComponentKind::MaxExclusive => "http://www.w3.org/ns/shacl#maxExclusive",
        ComponentKind::MaxInclusive => "http://www.w3.org/ns/shacl#maxInclusive",
        ComponentKind::MinLength => "http://www.w3.org/ns/shacl#minLength",
        ComponentKind::MaxLength => "http://www.w3.org/ns/shacl#maxLength",
        ComponentKind::Pattern => "http://www.w3.org/ns/shacl#pattern",
        ComponentKind::LanguageIn => "http://www.w3.org/ns/shacl#languageIn",
        ComponentKind::UniqueLang => "http://www.w3.org/ns/shacl#uniqueLang",
        ComponentKind::Equals => "http://www.w3.org/ns/shacl#equals",
        ComponentKind::Disjoint => "http://www.w3.org/ns/shacl#disjoint",
        ComponentKind::LessThan => "http://www.w3.org/ns/shacl#lessThan",
        ComponentKind::LessThanOrEquals => "http://www.w3.org/ns/shacl#lessThanOrEquals",
        ComponentKind::Not => "http://www.w3.org/ns/shacl#not",
        ComponentKind::And => "http://www.w3.org/ns/shacl#and",
        ComponentKind::Or => "http://www.w3.org/ns/shacl#or",
        ComponentKind::Xone => "http://www.w3.org/ns/shacl#xone",
        ComponentKind::Closed => "http://www.w3.org/ns/shacl#closed",
        ComponentKind::HasValue => "http://www.w3.org/ns/shacl#hasValue",
        ComponentKind::In => "http://www.w3.org/ns/shacl#in",
        ComponentKind::Sparql => "http://www.w3.org/ns/shacl#SPARQL",
    }
}

fn emit_validation_report_helpers(out: &mut String) -> Result<(), String> {
    writeln!(
        out,
        "const SHACL_VALIDATION_REPORT: &str = \"http://www.w3.org/ns/shacl#ValidationReport\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_VALIDATION_RESULT: &str = \"http://www.w3.org/ns/shacl#ValidationResult\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_RESULT: &str = \"http://www.w3.org/ns/shacl#result\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_FOCUS_NODE: &str = \"http://www.w3.org/ns/shacl#focusNode\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_SOURCE_SHAPE: &str = \"http://www.w3.org/ns/shacl#sourceShape\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_SOURCE_CONSTRAINT_COMPONENT: &str = \"http://www.w3.org/ns/shacl#sourceConstraintComponent\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_VALUE: &str = \"http://www.w3.org/ns/shacl#value\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_RESULT_SEVERITY: &str = \"http://www.w3.org/ns/shacl#resultSeverity\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_VIOLATION: &str = \"http://www.w3.org/ns/shacl#Violation\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_CONFORMS: &str = \"http://www.w3.org/ns/shacl#conforms\";"
    )
    .unwrap();
    writeln!(
        out,
        "const XSD_BOOLEAN: &str = \"http://www.w3.org/2001/XMLSchema#boolean\";"
    )
    .unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn bool_literal(value: bool) -> &'static str {{").unwrap();
    writeln!(out, "    if value {{").unwrap();
    writeln!(
        out,
        "        \"\\\"true\\\"^^<http://www.w3.org/2001/XMLSchema#boolean>\""
    )
    .unwrap();
    writeln!(out, "    }} else {{").unwrap();
    writeln!(
        out,
        "        \"\\\"false\\\"^^<http://www.w3.org/2001/XMLSchema#boolean>\""
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn term_to_turtle_value(term: &Term) -> String {{").unwrap();
    writeln!(out, "    term.to_string()").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn literal_string(value: &str) -> String {{").unwrap();
    writeln!(
        out,
        "    format!(\"\\\"{{}}\\\"^^<http://www.w3.org/2001/XMLSchema#string>\", escape_literal(value))"
    )
    .unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(out, "fn escape_literal(value: &str) -> String {{").unwrap();
    writeln!(out, "    let mut escaped = String::new();").unwrap();
    writeln!(out, "    for ch in value.chars() {{").unwrap();
    writeln!(out, "        match ch {{").unwrap();
    writeln!(out, "            '\\\\' => escaped.push_str(\"\\\\\\\\\"),").unwrap();
    writeln!(out, "            '\"' => escaped.push_str(\"\\\\\\\"\"),").unwrap();
    writeln!(out, "            '\\n' => escaped.push_str(\"\\\\n\"),").unwrap();
    writeln!(out, "            '\\r' => escaped.push_str(\"\\\\r\"),").unwrap();
    writeln!(out, "            '\\t' => escaped.push_str(\"\\\\t\"),").unwrap();
    writeln!(
        out,
        "            ch if (ch as u32) < 0x20 => escaped.push_str(&format!(\"\\\\u{{:04X}}\", ch as u32)),"
    )
    .unwrap();
    writeln!(out, "            ch => escaped.push(ch),").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    escaped").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn format_validation_report(report: &Report) -> String {{"
    )
    .unwrap();
    writeln!(out, "    let mut out = String::new();").unwrap();
    writeln!(
        out,
        "    out.push_str(\"@prefix sh: <http://www.w3.org/ns/shacl#> .\\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\\n\\n\");"
    )
    .unwrap();
    writeln!(
        out,
        "    out.push_str(&format!(\"_:report a sh:ValidationReport ;\\n    sh:conforms {{}} ;\\n\", bool_literal(report.violations.is_empty())));"
    )
    .unwrap();
    writeln!(out, "    if report.violations.is_empty() {{").unwrap();
    writeln!(out, "        out.push_str(\"    sh:result .\\n\\n\");").unwrap();
    writeln!(out, "    }} else {{").unwrap();
    writeln!(out, "        out.push_str(\"    sh:result \");").unwrap();
    writeln!(
        out,
        "        for (i, _) in report.violations.iter().enumerate() {{"
    )
    .unwrap();
    writeln!(out, "            if i > 0 {{").unwrap();
    writeln!(out, "                out.push_str(\", \");").unwrap();
    writeln!(out, "            }}").unwrap();
    writeln!(
        out,
        "            out.push_str(&format!(\"_:violation{{}}\", i));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        out.push_str(\" .\\n\\n\");").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(
        out,
        "    for (i, violation) in report.violations.iter().enumerate() {{"
    )
    .unwrap();
    writeln!(
        out,
        "        out.push_str(&format!(\"_:violation{{}} a sh:ValidationResult ;\\n\", i));"
    )
    .unwrap();
    writeln!(
        out,
        "        out.push_str(&format!(\"    sh:focusNode {{}} ;\\n\", term_to_turtle_value(&violation.focus)));"
    )
    .unwrap();
    writeln!(
        out,
        "        out.push_str(&format!(\"    sh:sourceShape <{{}}> ;\\n\", shape_iri(violation.shape_id)));"
    )
    .unwrap();
    writeln!(
        out,
        "        let component_term = component_iri(violation.component_id);"
    )
    .unwrap();
    writeln!(
        out,
        "        out.push_str(&format!(\"    sh:sourceConstraintComponent <{{}}> ;\\n\", component_term));"
    )
    .unwrap();
    writeln!(out, "        if let Some(value) = &violation.value {{").unwrap();
    writeln!(
        out,
        "            out.push_str(&format!(\"    sh:value {{}} ;\\n\", term_to_turtle_value(value)));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        if let Some(path) = &violation.path {{").unwrap();
    writeln!(
        out,
        "            out.push_str(&format!(\"    sh:resultPath <{{}}> ;\\n\", path));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(
        out,
        "        out.push_str(&format!(\"    sh:resultSeverity <{{}}> ;\\n\", severity_term(violation.shape_id)));"
    )
    .unwrap();
    writeln!(
        out,
        "        out.push_str(&format!(\"    sh:resultMessage {{}} .\\n\\n\", literal_string(&format!(\"Constraint violation of {{}}\", component_term))));"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    out").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(
        out,
        "fn validation_report_graph(report: &Report) -> Graph {{"
    )
    .unwrap();
    writeln!(out, "    let ttl = format_validation_report(report);").unwrap();
    writeln!(
        out,
        "    let parser = RdfParser::from_format(RdfFormat::Turtle).for_slice(ttl.as_bytes());"
    )
    .unwrap();
    writeln!(out, "    let mut graph = Graph::new();").unwrap();
    writeln!(out, "    for triple in parser {{").unwrap();
    writeln!(out, "        if let Ok(triple) = triple {{").unwrap();
    writeln!(out, "            graph.insert(triple.as_ref());").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    graph").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(out, "fn graph_to_turtle(graph: &Graph) -> String {{").unwrap();
    writeln!(out, "    let mut buffer = Vec::new();").unwrap();
    writeln!(out, "    let mut serializer = RdfSerializer::from_format(RdfFormat::Turtle).for_writer(&mut buffer);").unwrap();
    writeln!(out, "    for triple in graph.iter() {{").unwrap();
    writeln!(
        out,
        "        if serializer.serialize_triple(triple).is_err() {{"
    )
    .unwrap();
    writeln!(out, "            continue;").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(
        out,
        "    let mut turtle = String::from_utf8(buffer).unwrap_or_default();"
    )
    .unwrap();
    writeln!(out, "    if !turtle.ends_with('.') {{").unwrap();
    writeln!(out, "        turtle.push_str(\"\\n.\");").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    turtle").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(
        out,
        "fn follow_validation_bnodes(graph: &mut Graph, store: &Store) {{"
    )
    .unwrap();
    writeln!(out, "    let mut queue: VecDeque<Term> = VecDeque::new();").unwrap();
    writeln!(out, "    let mut seen: HashSet<Term> = HashSet::new();").unwrap();
    writeln!(out, "    for triple in graph.iter() {{").unwrap();
    writeln!(
        out,
        "        if let NamedOrBlankNodeRef::BlankNode(bn) = triple.subject {{"
    )
    .unwrap();
    writeln!(
        out,
        "            queue.push_back(Term::BlankNode(bn.into_owned()));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(
        out,
        "        if let TermRef::BlankNode(bn) = triple.object {{"
    )
    .unwrap();
    writeln!(
        out,
        "            queue.push_back(Term::BlankNode(bn.into_owned()));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    while let Some(term) = queue.pop_front() {{").unwrap();
    writeln!(out, "        if !seen.insert(term.clone()) {{").unwrap();
    writeln!(out, "            continue;").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        let subject = match subject_ref(&term) {{").unwrap();
    writeln!(out, "            Some(subject) => subject,").unwrap();
    writeln!(out, "            None => continue,").unwrap();
    writeln!(out, "        }};").unwrap();
    writeln!(
        out,
        "        for quad in store.quads_for_pattern(Some(subject), None, None, None) {{"
    )
    .unwrap();
    writeln!(out, "            if let Ok(quad) = quad {{").unwrap();
    writeln!(out, "                let object = quad.object.clone();").unwrap();
    writeln!(out, "                let triple = Triple::new(quad.subject.clone(), quad.predicate.clone(), object.clone());").unwrap();
    writeln!(out, "                graph.insert(triple.as_ref());").unwrap();
    writeln!(
        out,
        "                if let Term::BlankNode(bn) = object {{"
    )
    .unwrap();
    writeln!(
        out,
        "                    queue.push_back(Term::BlankNode(bn));"
    )
    .unwrap();
    writeln!(out, "                }}").unwrap();
    writeln!(out, "            }}").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(
        out,
        "pub fn render_report(report: &Report, store: &Store, follow_bnodes: bool) -> String {{"
    )
    .unwrap();
    writeln!(out, "    let mut graph = validation_report_graph(report);").unwrap();
    writeln!(out, "    if follow_bnodes {{").unwrap();
    writeln!(out, "        follow_validation_bnodes(&mut graph, store);").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    graph_to_turtle(&graph)").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}
