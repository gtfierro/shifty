use crate::plan::{
    CompId, ComponentKind, ComponentParams, PlanComponent, PlanIR, PlanPath, PlanRuleKind,
    PlanShape, PlanShapeKind, PlanTarget,
};
use crate::registry::{self, EmitContext, PropertyEmission};
use crate::GeneratedRust;
use oxigraph::model::Term;
use shacl_ir::Severity;
use std::collections::{HashMap, HashSet};
use std::fmt::Write;

pub fn generate(plan: &PlanIR) -> Result<String, String> {
    let modules = generate_modules(plan)?;
    Ok(modules.to_single_file())
}

pub fn generate_modules(plan: &PlanIR) -> Result<GeneratedRust, String> {
    let sections = generate_sections(plan)?;
    let mut files = Vec::new();
    let mut module_files = Vec::new();

    files.push(("prelude.rs".to_string(), sections.prelude));
    files.push(("helpers.rs".to_string(), sections.helpers));
    files.push(("paths.rs".to_string(), sections.paths));
    files.push(("shape_triples.rs".to_string(), sections.shape_triples));
    files.push(("shape_graph.nt".to_string(), sections.shape_graph_nt));
    files.push(("targets.rs".to_string(), sections.targets));
    files.push((
        "allowed_predicates.rs".to_string(),
        sections.allowed_predicates,
    ));
    files.push((
        "validators_property.rs".to_string(),
        sections.property_validators,
    ));
    files.push(("validators_node.rs".to_string(), sections.node_validators));
    files.push(("inference.rs".to_string(), sections.inference));
    files.push(("run.rs".to_string(), sections.run));

    for (name, _) in &files {
        if name.ends_with(".rs") {
            module_files.push(name.clone());
        }
    }

    let mut root = String::new();
    writeln!(root, "// Code generated by shacl-compiler. DO NOT EDIT.").unwrap();
    writeln!(root, "#![allow(unused_variables)]").unwrap();
    writeln!(root, "#![allow(dead_code)]").unwrap();
    for name in &module_files {
        writeln!(root, "include!(\"{}\");", name).unwrap();
    }

    Ok(GeneratedRust { root, files })
}

struct Sections {
    prelude: String,
    helpers: String,
    paths: String,
    shape_triples: String,
    shape_graph_nt: String,
    targets: String,
    allowed_predicates: String,
    property_validators: String,
    node_validators: String,
    inference: String,
    run: String,
}

fn generate_sections(plan: &PlanIR) -> Result<Sections, String> {
    let mut prelude = String::new();
    let mut helpers = String::new();
    let mut paths = String::new();
    let mut shape_triples = String::new();
    let mut shape_graph_nt = String::new();
    let mut targets = String::new();
    let mut allowed_predicates = String::new();
    let mut property_validators = String::new();
    let mut node_validators = String::new();
    let mut run = String::new();
    let mut inference = String::new();

    writeln!(prelude, "{}", "use oxigraph::model::{BlankNode, Graph, GraphName, GraphNameRef, Literal, NamedNode, NamedNodeRef, NamedOrBlankNode, NamedOrBlankNodeRef, Quad, Term, TermRef, Triple};").unwrap();
    writeln!(
        prelude,
        "{}",
        "use oxigraph::model::vocab::{rdf, xsd};"
    )
    .unwrap();
    writeln!(
        prelude,
        "{}",
        "use oxigraph::io::{RdfFormat, RdfParser, RdfSerializer};"
    )
    .unwrap();
    writeln!(prelude, "use oxigraph::store::Store;").unwrap();
    writeln!(
        prelude,
        "{}",
        "use oxigraph::sparql::{{QueryResults, SparqlEvaluator, Variable}};"
    )
    .unwrap();
    writeln!(
        prelude,
        "{}",
        "use std::collections::{HashMap, HashSet, VecDeque};"
    )
    .unwrap();
    writeln!(prelude, "use rayon::prelude::*;").unwrap();
    writeln!(prelude, "use regex::Regex;").unwrap();
    writeln!(prelude, "use log::info;").unwrap();
    writeln!(prelude, "use oxsdatatypes::*;").unwrap();
    writeln!(prelude, "use std::str::FromStr;").unwrap();
    writeln!(prelude, "use std::fs::File;").unwrap();
    writeln!(prelude, "use std::io::BufReader;").unwrap();
    writeln!(prelude, "use std::path::Path;").unwrap();
    writeln!(prelude, "").unwrap();

    let shape_graph_iri = term_iri(plan, plan.shape_graph)?;
    let data_graph_iri = format!("{}-compiled-data", shape_graph_iri);
    writeln!(
        prelude,
        "const RDF_TYPE: &str = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const RDFS_SUBCLASS_OF: &str = \"http://www.w3.org/2000/01/rdf-schema#subClassOf\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHAPE_GRAPH: &str = \"{}\";",
        escape_rust_string(&shape_graph_iri)
    )
    .unwrap();
    writeln!(
        prelude,
        "pub const DATA_GRAPH: &str = \"{}\";",
        escape_rust_string(&data_graph_iri)
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_SELECT: &str = \"http://www.w3.org/ns/shacl#select\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_PREFIXES: &str = \"http://www.w3.org/ns/shacl#prefixes\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_DECLARE: &str = \"http://www.w3.org/ns/shacl#declare\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_PREFIX: &str = \"http://www.w3.org/ns/shacl#prefix\";"
    )
    .unwrap();
    writeln!(
        prelude,
        "const SHACL_NAMESPACE: &str = \"http://www.w3.org/ns/shacl#namespace\";"
    )
    .unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "#[derive(Debug, Default)]").unwrap();
    writeln!(prelude, "{}", "pub struct Report {").unwrap();
    writeln!(prelude, "    pub violations: Vec<Violation>,").unwrap();
    writeln!(prelude, "{}", "}").unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "#[derive(Debug)]").unwrap();
    writeln!(prelude, "{}", "pub struct Violation {").unwrap();
    writeln!(prelude, "    pub shape_id: u64,").unwrap();
    writeln!(prelude, "    pub component_id: u64,").unwrap();
    writeln!(prelude, "    pub focus: Term,").unwrap();
    writeln!(prelude, "    pub value: Option<Term>,").unwrap();
    writeln!(prelude, "    pub path: Option<ResultPath>,").unwrap();
    writeln!(prelude, "{}", "}").unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "#[derive(Debug, Clone)]").unwrap();
    writeln!(prelude, "pub enum ResultPath {{").unwrap();
    writeln!(prelude, "    Term(Term),").unwrap();
    writeln!(prelude, "    PathId(u64),").unwrap();
    writeln!(prelude, "}}").unwrap();
    writeln!(prelude, "").unwrap();
    writeln!(prelude, "{}", "impl Report {").unwrap();
    writeln!(prelude, "    pub fn record(").unwrap();
    writeln!(prelude, "        &mut self,").unwrap();
    writeln!(prelude, "        shape_id: u64,").unwrap();
    writeln!(prelude, "        component_id: u64,").unwrap();
    writeln!(prelude, "        focus: &Term,").unwrap();
    writeln!(prelude, "        value: Option<&Term>,").unwrap();
    writeln!(prelude, "        path: Option<ResultPath>,").unwrap();
    writeln!(prelude, "{}", "    ) {").unwrap();
    writeln!(prelude, "{}", "        self.violations.push(Violation {").unwrap();
    writeln!(prelude, "            shape_id,").unwrap();
    writeln!(prelude, "            component_id,").unwrap();
    writeln!(prelude, "            focus: focus.clone(),").unwrap();
    writeln!(prelude, "            value: value.cloned(),").unwrap();
    writeln!(prelude, "            path,").unwrap();
    writeln!(prelude, "{}", "        });").unwrap();
    writeln!(prelude, "{}", "    }").unwrap();
    writeln!(prelude, "{}", "    pub fn merge(&mut self, other: Report) {").unwrap();
    writeln!(
        prelude,
        "        self.violations.extend(other.violations);"
    )
    .unwrap();
    writeln!(prelude, "{}", "    }").unwrap();
    writeln!(
        prelude,
        "{}",
        "    pub fn to_turtle(&self, store: &Store) -> String {"
    )
    .unwrap();
    writeln!(prelude, "        format_validation_report(self, store)").unwrap();
    writeln!(prelude, "{}", "    }").unwrap();
    writeln!(prelude, "{}", "}").unwrap();
    writeln!(prelude, "").unwrap();

    writeln!(helpers, "use serde_json;").unwrap();
    writeln!(helpers, "use shacl_ir::ShapeIR;").unwrap();
    writeln!(helpers, "use std::cell::RefCell;").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn graph_ref(graph: Option<&NamedNode>) -> Option<GraphNameRef<'_>> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    graph.map(|g| GraphNameRef::NamedNode(g.as_ref()))"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn query_mentions_bound_var(query: &str, var: &str) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let lower = query.to_ascii_lowercase();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let needle_q = format!(\"bound(?{})\", var);"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let needle_d = format!(\"bound(${})\", var);"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    lower.contains(&needle_q) || lower.contains(&needle_d)"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "thread_local! {{").unwrap();
    writeln!(
        helpers,
        "    static CURRENT_SUBCLASS_CLOSURE: RefCell<SubclassClosure> = RefCell::new(SubclassClosure::new());"
    )
    .unwrap();
    writeln!(
        helpers,
        "    static TARGET_CLASS_CACHE: RefCell<HashMap<(String, String), Vec<Term>>> = RefCell::new(HashMap::new());"
    )
    .unwrap();
    writeln!(
        helpers,
        "    static TYPE_INDEX_CACHE: RefCell<HashMap<String, HashMap<String, Vec<Term>>>> = RefCell::new(HashMap::new());"
    )
    .unwrap();
    writeln!(
        helpers,
        "    static ORIGINAL_VALUE_INDEX: RefCell<Option<OriginalValueIndex>> = RefCell::new(None);"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "#[derive(Hash, Eq, PartialEq, Clone)]").unwrap();
    writeln!(helpers, "struct LiteralKey {{").unwrap();
    writeln!(helpers, "    lexical: String,").unwrap();
    writeln!(helpers, "    language: Option<String>,").unwrap();
    writeln!(helpers, "    datatype: String,").unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "impl LiteralKey {{").unwrap();
    writeln!(
        helpers,
        "    fn from_literal(lit: &Literal) -> Self {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let mut lexical = lit.value().to_string();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        if lit.datatype().as_str() == \"http://www.w3.org/2001/XMLSchema#decimal\" {"
    )
    .unwrap();
    writeln!(
        helpers,
        "            lexical = normalize_decimal_literal(&lexical);"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(
        helpers,
        "        let language = lit.language().map(|l| l.to_ascii_lowercase());"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let datatype = lit.datatype().as_str().to_string();"
    )
    .unwrap();
    writeln!(helpers, "        LiteralKey {{ lexical, language, datatype }}").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "#[derive(Default, Clone)]").unwrap();
    writeln!(helpers, "pub struct OriginalValueIndex {{").unwrap();
    writeln!(
        helpers,
        "    literals: HashMap<Term, HashMap<NamedNode, HashMap<LiteralKey, VecDeque<Term>>>>,"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "impl OriginalValueIndex {{").unwrap();
    writeln!(helpers, "    pub fn new() -> Self {{").unwrap();
    writeln!(helpers, "        Self::default()").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    fn record_triple(&mut self, subject: NamedOrBlankNode, predicate: NamedNode, object: Term) {{"
    )
    .unwrap();
    writeln!(helpers, "        if let Term::Literal(lit) = object {{").unwrap();
    writeln!(
        helpers,
        "            let subject_term: Term = match subject {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "                NamedOrBlankNode::NamedNode(nn) => Term::NamedNode(nn),"
    )
    .unwrap();
    writeln!(
        helpers,
        "                NamedOrBlankNode::BlankNode(bn) => Term::BlankNode(bn),"
    )
    .unwrap();
    writeln!(helpers, "            }};").unwrap();
    writeln!(
        helpers,
        "            let entry = self"
    )
    .unwrap();
    writeln!(
        helpers,
        "                .literals"
    )
    .unwrap();
    writeln!(
        helpers,
        "                .entry(subject_term)"
    )
    .unwrap();
    writeln!(helpers, "                .or_default()").unwrap();
    writeln!(helpers, "                .entry(predicate)").unwrap();
    writeln!(helpers, "                .or_default()").unwrap();
    writeln!(
        helpers,
        "                .entry(LiteralKey::from_literal(&lit))"
    )
    .unwrap();
    writeln!(helpers, "                .or_default();").unwrap();
    writeln!(
        helpers,
        "            entry.push_back(Term::Literal(lit));"
    )
    .unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    pub fn resolve_literal(&self, subject: &Term, predicate: &NamedNode, candidate: &Literal) -> Option<Term> {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let key = LiteralKey::from_literal(candidate);"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let predicate_map = self.literals.get(subject)?.get(predicate)?;"
    )
    .unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "        if let Some(candidates) = predicate_map.get(&key) {{").unwrap();
    writeln!(helpers, "            if candidates.is_empty() {{").unwrap();
    writeln!(helpers, "                return None;").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(
        helpers,
        "            let candidate_term = Term::Literal(candidate.clone());"
    )
    .unwrap();
    writeln!(
        helpers,
        "            if candidates.iter().any(|term| term == &candidate_term) {{"
    )
    .unwrap();
    writeln!(helpers, "                return Some(candidate_term);").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "            return candidates.front().cloned();").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "        for (other_key, candidates) in predicate_map {{").unwrap();
    writeln!(
        helpers,
        "            if other_key.lexical == key.lexical && other_key.language == key.language {{"
    )
    .unwrap();
    writeln!(helpers, "                return candidates.front().cloned();").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "        None").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "pub fn load_original_value_index(path: &Path) -> Result<OriginalValueIndex, String> {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let extension = path.extension().and_then(|ext| ext.to_str()).map(|ext| ext.to_ascii_lowercase());"
    )
    .unwrap();
    writeln!(helpers, "    let format = match extension.as_deref() {{").unwrap();
    writeln!(
        helpers,
        "        Some(\"ttl\") | Some(\"turtle\") => Some(RdfFormat::Turtle),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Some(\"nt\") => Some(RdfFormat::NTriples),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Some(\"rdf\") | Some(\"xml\") => Some(RdfFormat::RdfXml),"
    )
    .unwrap();
    writeln!(helpers, "        _ => None,").unwrap();
    writeln!(helpers, "    }};").unwrap();
    writeln!(helpers, "    let format = match format {{").unwrap();
    writeln!(helpers, "        Some(f) => f,").unwrap();
    writeln!(helpers, "        None => return Ok(OriginalValueIndex::new()),").unwrap();
    writeln!(helpers, "    }};").unwrap();
    writeln!(helpers, "    let file = File::open(path).map_err(|e| e.to_string())?;").unwrap();
    writeln!(helpers, "    let reader = BufReader::new(file);").unwrap();
    writeln!(helpers, "    let parser = RdfParser::from_format(format).without_named_graphs();").unwrap();
    writeln!(helpers, "    let mut index = OriginalValueIndex::new();").unwrap();
    writeln!(helpers, "    for quad in parser.for_reader(reader) {{").unwrap();
    writeln!(helpers, "        let triple = quad.map_err(|e| e.to_string())?;").unwrap();
    writeln!(helpers, "        index.record_triple(triple.subject, triple.predicate, triple.object);").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "    Ok(index)").unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "pub fn set_original_value_index(index: Option<OriginalValueIndex>) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    ORIGINAL_VALUE_INDEX.with(|cell| *cell.borrow_mut() = index);"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "fn with_original_value_index<F, R>(f: F) -> R where F: FnOnce(Option<&OriginalValueIndex>) -> R {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    ORIGINAL_VALUE_INDEX.with(|cell| f(cell.borrow().as_ref()))"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "#[derive(Clone)]").unwrap();
    writeln!(helpers, "struct SubclassClosure {{").unwrap();
    writeln!(helpers, "    parents: HashMap<String, Vec<String>>,").unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn init_thread_state(closure: SubclassClosure) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    CURRENT_SUBCLASS_CLOSURE.with(|cell| *cell.borrow_mut() = closure);"
    )
    .unwrap();
    writeln!(helpers, "    clear_target_class_caches();").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "impl SubclassClosure {{").unwrap();
    writeln!(helpers, "    fn new() -> Self {{").unwrap();
    writeln!(
        helpers,
        "        SubclassClosure {{ parents: HashMap::new() }}"
    )
    .unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    fn from_edges(edges: &[(&str, &str)]) -> Self {{"
    )
    .unwrap();
    writeln!(helpers, "        let mut closure = SubclassClosure::new();").unwrap();
    writeln!(helpers, "        for (sub, sup) in edges.iter() {{").unwrap();
    writeln!(helpers, "            closure.add_edge(sub, sup);").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "        closure").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    fn add_edge(&mut self, subclass: &str, superclass: &str) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "        self.parents.entry(subclass.to_string()).or_default().push(superclass.to_string());"
    )
    .unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    fn extend_from_store(&mut self, store: &Store, graph: Option<GraphNameRef<'_>>) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let subclass_pred = NamedNodeRef::new(RDFS_SUBCLASS_OF).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "        for quad in store.quads_for_pattern(None, Some(subclass_pred), None, graph) {{"
    )
    .unwrap();
    writeln!(helpers, "            if let Ok(quad) = quad {{").unwrap();
    writeln!(
        helpers,
        "                if let (NamedOrBlankNode::NamedNode(sub), Term::NamedNode(sup)) = (&quad.subject, &quad.object) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    self.add_edge(sub.as_str(), sup.as_str());"
    )
    .unwrap();
    writeln!(helpers, "                }}").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "    fn is_subclass_of(&self, subclass: &str, superclass: &str) -> bool {{"
    )
    .unwrap();
    writeln!(helpers, "        if subclass == superclass {{").unwrap();
    writeln!(helpers, "            return true;").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(
        helpers,
        "        let mut stack: Vec<String> = vec![subclass.to_string()];"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let mut seen: HashSet<String> = HashSet::new();"
    )
    .unwrap();
    writeln!(helpers, "        while let Some(curr) = stack.pop() {{").unwrap();
    writeln!(helpers, "            if curr == superclass {{").unwrap();
    writeln!(helpers, "                return true;").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "            if !seen.insert(curr.clone()) {{").unwrap();
    writeln!(helpers, "                continue;").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(
        helpers,
        "            if let Some(parents) = self.parents.get(&curr) {{"
    )
    .unwrap();
    writeln!(helpers, "                for parent in parents {{").unwrap();
    writeln!(helpers, "                    stack.push(parent.clone());").unwrap();
    writeln!(helpers, "                }}").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "        false").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "fn subclass_closure_from_shape_edges() -> SubclassClosure {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    SubclassClosure::from_edges(SHAPE_SUBCLASS_EDGES)"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "fn set_current_subclass_closure(closure: SubclassClosure) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    CURRENT_SUBCLASS_CLOSURE.with(|cell| *cell.borrow_mut() = closure);"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "fn extend_current_subclass_closure_from_store(store: &Store, graph: Option<GraphNameRef<'_>>) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    CURRENT_SUBCLASS_CLOSURE.with(|cell| cell.borrow_mut().extend_from_store(store, graph));"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "fn with_subclass_closure<F, R>(f: F) -> R where F: FnOnce(&SubclassClosure) -> R {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "    CURRENT_SUBCLASS_CLOSURE.with(|cell| f(&cell.borrow()))"
    )
    .unwrap();
    writeln!(helpers, "}}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn graph_cache_key(graph: Option<GraphNameRef<'_>>) -> String {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    match graph { Some(g) => g.to_string(), None => \"__all__\".to_string() }"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn build_type_index(store: &Store, graph: Option<GraphNameRef<'_>>) -> HashMap<String, Vec<Term>> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let rdf_type = NamedNodeRef::new(RDF_TYPE).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let mut index: HashMap<String, Vec<Term>> = HashMap::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut graphs: Vec<Option<GraphNameRef<'_>>> = Vec::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(g) = graph {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        graphs.push(Some(g));"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    } else {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        graphs.push(None);"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    }"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    for graph_opt in graphs {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        for quad in store.quads_for_pattern(None, Some(rdf_type), None, graph_opt) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            let quad = match quad { Ok(quad) => quad, Err(_) => continue };"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            let class_iri = match &quad.object { Term::NamedNode(node) => node.as_str(), _ => continue };"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let subject: Term = quad.subject.into();"
    )
    .unwrap();
    writeln!(
        helpers,
        "        index.entry(class_iri.to_string()).or_default().push(subject);"
    )
    .unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(helpers, "    index").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn clear_target_class_caches() {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    TARGET_CLASS_CACHE.with(|cell| cell.borrow_mut().clear());"
    )
    .unwrap();
    writeln!(
        helpers,
        "    TYPE_INDEX_CACHE.with(|cell| cell.borrow_mut().clear());"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn targets_for_class(store: &Store, graph: Option<GraphNameRef<'_>>, class_iri: &str) -> Vec<Term> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let graph_key = graph_cache_key(graph);"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let cache_key = (graph_key.clone(), class_iri.to_string());"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(cached) = TARGET_CLASS_CACHE.with(|cell| cell.borrow().get(&cache_key).cloned()) {"
    )
    .unwrap();
    writeln!(helpers, "        return cached;").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let targets = TYPE_INDEX_CACHE.with(|cell| {"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let mut cache = cell.borrow_mut();"
    )
    .unwrap();
    writeln!(
        helpers,
        "        let index = cache.entry(graph_key.clone()).or_insert_with(|| build_type_index(store, graph));"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        with_subclass_closure(|closure| {"
    )
    .unwrap();
    writeln!(
        helpers,
        "            let mut out: Vec<Term> = Vec::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "            let mut seen: HashSet<Term> = HashSet::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            for (class, subjects) in index.iter() {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                if closure.is_subclass_of(class.as_str(), class_iri) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                    for subject in subjects {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                        if seen.insert(subject.clone()) { out.push(subject.clone()); }"
    )
    .unwrap();
    writeln!(helpers, "{}", "                    }").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "            out").unwrap();
    writeln!(helpers, "{}", "        })").unwrap();
    writeln!(helpers, "{}", "    });").unwrap();
    writeln!(
        helpers,
        "{}",
        "    TARGET_CLASS_CACHE.with(|cell| { cell.borrow_mut().insert(cache_key, targets.clone()); });"
    )
    .unwrap();
    writeln!(helpers, "    targets").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn shape_graph_ref() -> GraphNameRef<'static> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    GraphNameRef::NamedNode(NamedNodeRef::new(SHAPE_GRAPH).unwrap())"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn subject_ref(term: &Term) -> Option<NamedOrBlankNodeRef<'_>> {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::NamedNode(node) => Some(NamedOrBlankNodeRef::NamedNode(node.as_ref())),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::BlankNode(node) => Some(NamedOrBlankNodeRef::BlankNode(node.as_ref())),"
    )
    .unwrap();
    writeln!(helpers, "        _ => None,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "{}", "fn term_ref(term: &Term) -> TermRef<'_> {").unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::NamedNode(node) => TermRef::NamedNode(node.as_ref()),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::BlankNode(node) => TermRef::BlankNode(node.as_ref()),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => TermRef::Literal(lit.as_ref()),"
    )
    .unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn literal_signature(lit: &Literal) -> (String, Option<String>, String) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut lexical = lit.value().to_string();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if lit.datatype().as_str() == \"http://www.w3.org/2001/XMLSchema#decimal\" {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        lexical = normalize_decimal_literal(&lexical);"
    )
    .unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    (lexical, lit.language().map(|lang| lang.to_ascii_lowercase()), lit.datatype().as_str().to_string())"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn lookup_by_signature(buckets: &mut HashMap<(String, Option<String>, String), VecDeque<Term>>, exact_matches: &mut HashSet<Term>, lit: &Literal) -> Option<Term> {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    let key = literal_signature(lit);").unwrap();
    writeln!(helpers, "{}", "    if let Some(queue) = buckets.get_mut(&key) {").unwrap();
    writeln!(helpers, "{}", "        if let Some(term) = queue.pop_front() {").unwrap();
    writeln!(helpers, "{}", "            exact_matches.remove(&term);").unwrap();
    writeln!(helpers, "{}", "            return Some(term);").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    None").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn canonicalize_values_for_predicate(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term, predicate_iri: &str, mut nodes: Vec<Term>) -> Vec<Term> {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    if nodes.is_empty() {").unwrap();
    writeln!(helpers, "{}", "        return nodes;").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let predicate_ref = match NamedNodeRef::new(predicate_iri) { Ok(p) => p, Err(_) => return nodes };"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let subject = match subject_ref(focus) { Some(s) => s, None => return nodes };"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut raw_objects: Vec<Term> = Vec::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    for quad in store.quads_for_pattern(Some(subject), Some(predicate_ref), None, graph) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        if let Ok(quad) = quad {").unwrap();
    writeln!(helpers, "{}", "            raw_objects.push(quad.object);").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let has_original_index = with_original_value_index(|idx| idx.is_some());"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if raw_objects.is_empty() && !has_original_index {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        return nodes;").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut exact_matches: HashSet<Term> = raw_objects.iter().cloned().collect();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut literals_by_signature: HashMap<(String, Option<String>, String), VecDeque<Term>> = HashMap::new();"
    )
    .unwrap();
    writeln!(helpers, "{}", "    for term in &raw_objects {").unwrap();
    writeln!(helpers, "{}", "        if let Term::Literal(lit) = term {").unwrap();
    writeln!(helpers, "{}", "            let key = literal_signature(lit);").unwrap();
    writeln!(
        helpers,
        "{}",
        "            literals_by_signature.entry(key).or_default().push_back(term.clone());"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let predicate = NamedNode::new_unchecked(predicate_iri);"
    )
    .unwrap();
    writeln!(helpers, "{}", "    for node in &mut nodes {").unwrap();
    writeln!(helpers, "{}", "        let current = node.clone();").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if let Term::Literal(ref lit) = current {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            let resolved = with_original_value_index(|idx| idx.and_then(|index| index.resolve_literal(focus, &predicate, lit)));"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            if let Some(original) = resolved {"
    )
    .unwrap();
    writeln!(helpers, "{}", "                if original != current {").unwrap();
    writeln!(helpers, "{}", "                    exact_matches.remove(&original);").unwrap();
    writeln!(helpers, "{}", "                    *node = original;").unwrap();
    writeln!(helpers, "{}", "                    continue;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "        if exact_matches.remove(&current) {").unwrap();
    writeln!(helpers, "{}", "            continue;").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if let Term::Literal(ref lit) = current {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            if let Some(term) = lookup_by_signature(&mut literals_by_signature, &mut exact_matches, lit) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "                *node = term;").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    nodes").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        r#"fn is_literal_with_datatype(term: &Term, datatype_iri: &str) -> bool {
    let lit = match term {
        Term::Literal(lit) => lit,
        _ => return false,
    };
    if datatype_iri == rdf::LANG_STRING.as_str() {
        return lit.language().is_some();
    }
    let lit_datatype = lit.datatype();
    let mut datatype_matches = lit_datatype.as_str() == datatype_iri;
    if !datatype_matches && datatype_iri == xsd::DECIMAL.as_str() && lit_datatype == xsd::INTEGER {
        datatype_matches = true;
    }
    if !datatype_matches {
        return false;
    }
    let literal_value = lit.value();
    if datatype_iri == xsd::STRING.as_str() {
        true
    } else if datatype_iri == xsd::BOOLEAN.as_str() {
        Boolean::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::DECIMAL.as_str() {
        Decimal::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::INTEGER.as_str() {
        Integer::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::BYTE.as_str() {
        Integer::from_str(literal_value)
            .map(|v| {
                let value: i64 = v.into();
                value >= i64::from(i8::MIN) && value <= i64::from(i8::MAX)
            })
            .unwrap_or(false)
    } else if datatype_iri == xsd::SHORT.as_str() {
        Integer::from_str(literal_value)
            .map(|v| {
                let value: i64 = v.into();
                value >= i64::from(i16::MIN) && value <= i64::from(i16::MAX)
            })
            .unwrap_or(false)
    } else if datatype_iri == xsd::INT.as_str() {
        Integer::from_str(literal_value)
            .map(|v| {
                let value: i64 = v.into();
                value >= i64::from(i32::MIN) && value <= i64::from(i32::MAX)
            })
            .unwrap_or(false)
    } else if datatype_iri == xsd::LONG.as_str() {
        Integer::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::UNSIGNED_BYTE.as_str() {
        Integer::from_str(literal_value)
            .map(|v| {
                let value: i64 = v.into();
                value >= 0 && value <= i64::from(u8::MAX)
            })
            .unwrap_or(false)
    } else if datatype_iri == xsd::UNSIGNED_SHORT.as_str() {
        Integer::from_str(literal_value)
            .map(|v| {
                let value: i64 = v.into();
                value >= 0 && value <= i64::from(u16::MAX)
            })
            .unwrap_or(false)
    } else if datatype_iri == xsd::UNSIGNED_INT.as_str() {
        Integer::from_str(literal_value)
            .map(|v| {
                let value: i64 = v.into();
                value >= 0 && value <= i64::from(u32::MAX)
            })
            .unwrap_or(false)
    } else if datatype_iri == xsd::DOUBLE.as_str() {
        Double::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::FLOAT.as_str() {
        Float::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::DATE.as_str() {
        Date::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::TIME.as_str() {
        Time::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::DATE_TIME.as_str() {
        DateTime::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::G_YEAR.as_str() {
        GYear::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::G_MONTH.as_str() {
        GMonth::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::G_DAY.as_str() {
        GDay::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::G_YEAR_MONTH.as_str() {
        GYearMonth::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::G_MONTH_DAY.as_str() {
        GMonthDay::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::DURATION.as_str() {
        Duration::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::YEAR_MONTH_DURATION.as_str() {
        YearMonthDuration::from_str(literal_value).is_ok()
    } else if datatype_iri == xsd::DAY_TIME_DURATION.as_str() {
        DayTimeDuration::from_str(literal_value).is_ok()
    } else {
        true
    }
}
"#
    )
    .unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn advanced_select_query(store: &Store, selector: &Term) -> Option<String> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let select_pred = NamedNodeRef::new(SHACL_SELECT).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(subject) = subject_ref(selector) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        for quad in store.quads_for_pattern(Some(subject), Some(select_pred), None, None) {").unwrap();
    writeln!(helpers, "{}", "            if let Ok(quad) = quad {").unwrap();
    writeln!(
        helpers,
        "{}",
        "                if let Term::Literal(lit) = quad.object {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    return Some(lit.value().to_string());"
    )
    .unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    for quad in store.quads_for_pattern(None, Some(select_pred), None, None) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        if let Ok(quad) = quad {").unwrap();
    writeln!(
        helpers,
        "{}",
        "            if let Term::Literal(lit) = quad.object {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                return Some(lit.value().to_string());"
    )
    .unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    None").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn prefixes_for_selector(store: &Store, selector: &Term) -> String {"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_prefixes = NamedNodeRef::new(SHACL_PREFIXES).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_declare = NamedNodeRef::new(SHACL_DECLARE).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_prefix = NamedNodeRef::new(SHACL_PREFIX).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let sh_namespace = NamedNodeRef::new(SHACL_NAMESPACE).unwrap();"
    )
    .unwrap();
    writeln!(helpers, "    let shape_graph = shape_graph_ref();").unwrap();
    writeln!(helpers, "    let mut subjects: Vec<Term> = Vec::new();").unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(subject) = subject_ref(selector) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        for quad in store.quads_for_pattern(Some(subject), Some(sh_prefixes), None, Some(shape_graph)) {").unwrap();
    writeln!(helpers, "{}", "            if let Ok(quad) = quad {").unwrap();
    writeln!(helpers, "                subjects.push(quad.object);").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    for quad in store.quads_for_pattern(None, Some(sh_declare), None, None) {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        if let Ok(quad) = quad {").unwrap();
    writeln!(helpers, "            subjects.push(quad.subject.into());").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "    let mut prefixes: HashMap<String, String> = HashMap::new();"
    )
    .unwrap();
    writeln!(helpers, "{}", "    for subject_term in subjects {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        let subject_node = match subject_ref(&subject_term) {"
    )
    .unwrap();
    writeln!(helpers, "            Some(value) => value,").unwrap();
    writeln!(helpers, "            None => continue,").unwrap();
    writeln!(helpers, "{}", "        };").unwrap();
    writeln!(helpers, "{}", "        for quad in store.quads_for_pattern(Some(subject_node), Some(sh_declare), None, None) {").unwrap();
    writeln!(
        helpers,
        "{}",
        "            let quad = match quad { Ok(q) => q, Err(_) => continue };"
    )
    .unwrap();
    writeln!(helpers, "            let decl_term = quad.object;").unwrap();
    writeln!(
        helpers,
        "{}",
        "            let decl_ref = match subject_ref(&decl_term) {"
    )
    .unwrap();
    writeln!(helpers, "                Some(value) => value,").unwrap();
    writeln!(helpers, "                None => continue,").unwrap();
    writeln!(helpers, "{}", "            };").unwrap();
    writeln!(
        helpers,
        "    let prefix_val = store.quads_for_pattern(Some(decl_ref), Some(sh_prefix), None, None)"
    )
    .unwrap();
    writeln!(helpers, "        .filter_map(Result::ok)").unwrap();
    writeln!(helpers, "        .map(|q| q.object)").unwrap();
    writeln!(helpers, "        .next();").unwrap();
    writeln!(helpers, "    let namespace_val = store.quads_for_pattern(Some(decl_ref), Some(sh_namespace), None, None)").unwrap();
    writeln!(helpers, "        .filter_map(Result::ok)").unwrap();
    writeln!(helpers, "        .map(|q| q.object)").unwrap();
    writeln!(helpers, "        .next();").unwrap();
    writeln!(helpers, "{}", "            if let (Some(Term::Literal(prefix_lit)), Some(Term::Literal(ns_lit))) = (prefix_val, namespace_val) {").unwrap();
    writeln!(
        helpers,
        "                let prefix = prefix_lit.value().to_string();"
    )
    .unwrap();
    writeln!(
        helpers,
        "                let namespace = ns_lit.value().to_string();"
    )
    .unwrap();
    writeln!(
        helpers,
        "                prefixes.insert(prefix, namespace);"
    )
    .unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if prefixes.is_empty() {").unwrap();
    writeln!(helpers, "        return String::new();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "    let mut keys: Vec<String> = prefixes.keys().cloned().collect();"
    )
    .unwrap();
    writeln!(helpers, "    keys.sort();").unwrap();
    writeln!(helpers, "    let mut out = String::new();").unwrap();
    writeln!(helpers, "{}", "    for key in keys {").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if let Some(ns) = prefixes.get(&key) {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            out.push_str(&format!(\"PREFIX {}: <{}>\\n\", key, ns));"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    out").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn advanced_targets_for(store: &Store, graph: Option<GraphNameRef<'_>>, selector: &Term) -> Vec<Term> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let query = match advanced_select_query(store, selector) {"
    )
    .unwrap();
    writeln!(helpers, "        Some(value) => value,").unwrap();
    writeln!(helpers, "        None => return Vec::new(),").unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let normalized_query = query.replace('$', \"?\");"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let prefixes = prefixes_for_selector(store, selector);"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let query_str = if prefixes.trim().is_empty() { normalized_query.clone() } else { format!(\"{}\\n{}\", prefixes, normalized_query) };"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let debug = std::env::var(\"SHACL_DEBUG_SPARQL\").is_ok();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if debug { eprintln!(\"SPARQL query:\\n{}\", query_str); }"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut prepared = match SparqlEvaluator::new().parse_query(&query_str) {"
    )
    .unwrap();
    writeln!(helpers, "        Ok(prepared) => prepared,").unwrap();
    writeln!(helpers, "        Err(_) => return Vec::new(),").unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(helpers, "    if let Some(graph) = graph {{").unwrap();
    writeln!(
        helpers,
        "        prepared.dataset_mut().set_default_graph(vec![graph.into_owned()]);"
    )
    .unwrap();
    writeln!(helpers, "    }} else {{").unwrap();
    writeln!(
        helpers,
        "        prepared.dataset_mut().set_default_graph_as_union();"
    )
    .unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(
        helpers,
        "    let mut results: HashSet<Term> = HashSet::new();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    match prepared.on_store(store).execute() {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        Ok(QueryResults::Solutions(solutions)) => {"
    )
    .unwrap();
    writeln!(helpers, "{}", "            for solution in solutions {").unwrap();
    writeln!(
        helpers,
        "{}",
        "                let solution = match solution { Ok(sol) => sol, Err(_) => continue };"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                if let Some(value) = solution.get(\"this\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    results.insert(value.to_owned());"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                } else if let Some(value) = solution.get(\"target\") {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    results.insert(value.to_owned());"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                } else if let Some(var) = solution.variables().first() {"
    )
    .unwrap();
    writeln!(
        helpers,
        "                    if let Some(value) = solution.get(var.as_str()) {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "                        results.insert(value.to_owned());"
    )
    .unwrap();
    writeln!(helpers, "{}", "                    }").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "        _ => {}").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    results.into_iter().collect()").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn has_rdf_type(store: &Store, graph: Option<GraphNameRef<'_>>, term: &Term, class_iri: &str) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let subject = match subject_ref(term) { Some(s) => s, None => return false };"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let rdf_type = NamedNodeRef::new(RDF_TYPE).unwrap();"
    )
    .unwrap();
    writeln!(helpers, "    let mut graphs: Vec<Option<GraphNameRef<'_>>> = Vec::new();").unwrap();
    writeln!(helpers, "    if let Some(g) = graph {{").unwrap();
    writeln!(helpers, "        graphs.push(Some(g));").unwrap();
    writeln!(helpers, "        let shape_graph = shape_graph_ref();").unwrap();
    writeln!(helpers, "        if g != shape_graph {{ graphs.push(Some(shape_graph)); }}").unwrap();
    writeln!(helpers, "    }} else {{").unwrap();
    writeln!(helpers, "        graphs.push(None);").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "    for graph_opt in graphs {{").unwrap();
    writeln!(helpers, "        for quad in store.quads_for_pattern(Some(subject), Some(rdf_type), None, graph_opt) {{").unwrap();
    writeln!(helpers, "        if let Ok(quad) = quad {{").unwrap();
    writeln!(helpers, "            if let Term::NamedNode(node) = quad.object {{").unwrap();
    writeln!(helpers, "                let node_str = node.as_str();").unwrap();
    writeln!(helpers, "                if with_subclass_closure(|closure| closure.is_subclass_of(node_str, class_iri)) {{").unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "                }}").unwrap();
    writeln!(helpers, "            }}").unwrap();
    writeln!(helpers, "        }}").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "    }}").unwrap();
    writeln!(helpers, "    false").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn matches_node_kind(term: &Term, node_kind_iri: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match node_kind_iri {").unwrap();
    writeln!(
        helpers,
        "        \"http://www.w3.org/ns/shacl#IRI\" => matches!(term, Term::NamedNode(_)),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        \"http://www.w3.org/ns/shacl#BlankNode\" => matches!(term, Term::BlankNode(_)),"
    )
    .unwrap();
    writeln!(
        helpers,
        "        \"http://www.w3.org/ns/shacl#Literal\" => matches!(term, Term::Literal(_)),"
    )
    .unwrap();
    writeln!(helpers, "        \"http://www.w3.org/ns/shacl#BlankNodeOrIRI\" => matches!(term, Term::BlankNode(_) | Term::NamedNode(_)),").unwrap();
    writeln!(helpers, "        \"http://www.w3.org/ns/shacl#BlankNodeOrLiteral\" => matches!(term, Term::BlankNode(_) | Term::Literal(_)),").unwrap();
    writeln!(helpers, "        \"http://www.w3.org/ns/shacl#IRIOrLiteral\" => matches!(term, Term::NamedNode(_) | Term::Literal(_)),").unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn literal_length_at_least(term: &Term, min: u64) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => (lit.value().chars().count() as u64) >= min,"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::NamedNode(node) => (node.as_str().chars().count() as u64) >= min,"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn literal_length_at_most(term: &Term, max: u64) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => (lit.value().chars().count() as u64) <= max,"
    )
    .unwrap();
    writeln!(
        helpers,
        "        Term::NamedNode(node) => (node.as_str().chars().count() as u64) <= max,"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn literal_matches_regex(term: &Term, regex: &Regex) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(
        helpers,
        "        Term::Literal(lit) => regex.is_match(lit.value()),"
    )
    .unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn lang_matches(tag: &str, range: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    if range == \"*\" {").unwrap();
    writeln!(helpers, "        return !tag.is_empty();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    let tag_lower = tag.to_lowercase();").unwrap();
    writeln!(helpers, "    let range_lower = range.to_lowercase();").unwrap();
    writeln!(helpers, "{}", "    if tag_lower == range_lower {").unwrap();
    writeln!(helpers, "        return true;").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    if range_lower.chars().all(|c| c.is_ascii_alphanumeric() || c == '-') {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        if tag_lower.starts_with(&format!(\"{}-\", range_lower)) {"
    )
    .unwrap();
    writeln!(helpers, "            return true;").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "    false").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn language_in_allowed(term: &Term, allowed: &[&str]) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    match term {").unwrap();
    writeln!(helpers, "{}", "        Term::Literal(lit) => {").unwrap();
    writeln!(
        helpers,
        "            let lang = lit.language().unwrap_or(\"\");"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            if allowed.is_empty() { return false; }"
    )
    .unwrap();
    writeln!(
        helpers,
        "            allowed.iter().any(|range| lang_matches(lang, range))"
    )
    .unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "        _ => false,").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn values_for_predicate(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term, predicate_iri: &str) -> Vec<Term> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let subject = match subject_ref(focus) { Some(s) => s, None => return Vec::new() };"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let predicate = NamedNodeRef::new(predicate_iri).unwrap();"
    )
    .unwrap();
    writeln!(
        helpers,
        "    let data_graph = data_graph_named();"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    let graph_ref = match graph { Some(g) => g, None => GraphNameRef::NamedNode(data_graph.as_ref()) };"
    )
    .unwrap();
    writeln!(
        helpers,
        "    store.quads_for_pattern(Some(subject), Some(predicate), None, Some(graph_ref)).filter_map(Result::ok).map(|q| q.object).collect()"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(helpers, "{}", "fn term_to_sparql(term: &Term) -> String {").unwrap();
    writeln!(helpers, "    term.to_string()").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn term_to_sparql_ground(term: &Term) -> Option<String> {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    match term {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        Term::BlankNode(_) => None,"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        _ => Some(term.to_string()),"
    )
    .unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn inject_values_clause(query: &str, values_clause: &str) -> String {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if values_clause.trim().is_empty() {"
    )
    .unwrap();
    writeln!(helpers, "        return query.to_string();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    if let Some(pos) = query.find('{') {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        let mut out = String::with_capacity(query.len() + values_clause.len() + 2);"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "        out.push_str(&query[..pos + 1]);"
    )
    .unwrap();
    writeln!(helpers, "        out.push('\\n');").unwrap();
    writeln!(helpers, "        out.push_str(values_clause);").unwrap();
    writeln!(helpers, "        out.push('\\n');").unwrap();
    writeln!(helpers, "        out.push_str(&query[pos + 1..]);").unwrap();
    writeln!(helpers, "        out").unwrap();
    writeln!(helpers, "{}", "    } else {").unwrap();
    writeln!(helpers, "        query.to_string()").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn inject_bindings_everywhere(query: &str, bindings_clause: &str) -> String {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if bindings_clause.trim().is_empty() {"
    )
    .unwrap();
    writeln!(helpers, "{}", "        return query.to_string();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let mut out = String::with_capacity(query.len() + bindings_clause.len() * 2);"
    )
    .unwrap();
    writeln!(helpers, "{}", "    let bytes = query.as_bytes();").unwrap();
    writeln!(helpers, "{}", "    let mut i = 0;").unwrap();
    writeln!(helpers, "{}", "    while i < bytes.len() {").unwrap();
    writeln!(helpers, "{}", "        let ch = bytes[i] as char;").unwrap();
    writeln!(helpers, "{}", "        out.push(ch);").unwrap();
    writeln!(helpers, "{}", "        if ch == '{' {").unwrap();
    writeln!(helpers, "{}", "            let mut j = i + 1;").unwrap();
    writeln!(helpers, "{}", "            while j < bytes.len() {").unwrap();
    writeln!(helpers, "{}", "                let c = bytes[j] as char;").unwrap();
    writeln!(helpers, "{}", "                if c.is_whitespace() {").unwrap();
    writeln!(helpers, "{}", "                    j += 1;").unwrap();
    writeln!(helpers, "{}", "                    continue;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "                if c == '#' {").unwrap();
    writeln!(helpers, "{}", "                    while j < bytes.len() && bytes[j] as char != '\\n' {").unwrap();
    writeln!(helpers, "{}", "                        j += 1;").unwrap();
    writeln!(helpers, "{}", "                    }").unwrap();
    writeln!(helpers, "{}", "                    continue;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "                break;").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "            let rest = &query[j..];").unwrap();
    writeln!(
        helpers,
        "{}",
        "            if rest.len() < 6 || !rest[..6].eq_ignore_ascii_case(\"select\") {"
    )
    .unwrap();
    writeln!(helpers, "{}", "                out.push('\\n');").unwrap();
    writeln!(helpers, "{}", "                out.push_str(bindings_clause);").unwrap();
    writeln!(helpers, "{}", "                out.push('\\n');").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "        i += 1;").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    out").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn inject_bindings_in_where(query: &str, bindings_clause: &str) -> String {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    if bindings_clause.trim().is_empty() {{"
    )
    .unwrap();
    writeln!(helpers, "{}", "        return query.to_string();").unwrap();
    writeln!(helpers, "{}", "    }}").unwrap();
    writeln!(
        helpers,
        "{}",
        "    let bytes = query.as_bytes();"
    )
    .unwrap();
    writeln!(helpers, "{}", "    let mut i = 0;").unwrap();
    writeln!(helpers, "{}", "    let mut in_string = false;").unwrap();
    writeln!(helpers, "{}", "    let mut in_iri = false;").unwrap();
    writeln!(helpers, "{}", "    let mut in_comment = false;").unwrap();
    writeln!(helpers, "{}", "    while i < bytes.len() {{").unwrap();
    writeln!(helpers, "{}", "        let ch = bytes[i] as char;").unwrap();
    writeln!(helpers, "{}", "        if in_comment {{").unwrap();
    writeln!(helpers, "{}", "            if ch == '\\n' {{ in_comment = false; }}").unwrap();
    writeln!(helpers, "{}", "            i += 1;").unwrap();
    writeln!(helpers, "{}", "            continue;").unwrap();
    writeln!(helpers, "{}", "        }}").unwrap();
    writeln!(helpers, "{}", "        if in_string {{").unwrap();
    writeln!(helpers, "{}", "            if ch == '\\\\' {{ i += 2; continue; }}").unwrap();
    writeln!(helpers, "{}", "            if ch == '\"' {{ in_string = false; }}").unwrap();
    writeln!(helpers, "{}", "            i += 1;").unwrap();
    writeln!(helpers, "{}", "            continue;").unwrap();
    writeln!(helpers, "{}", "        }}").unwrap();
    writeln!(helpers, "{}", "        if in_iri {{").unwrap();
    writeln!(helpers, "{}", "            if ch == '>' {{ in_iri = false; }}").unwrap();
    writeln!(helpers, "{}", "            i += 1;").unwrap();
    writeln!(helpers, "{}", "            continue;").unwrap();
    writeln!(helpers, "{}", "        }}").unwrap();
    writeln!(helpers, "{}", "        if ch == '#' {{ in_comment = true; i += 1; continue; }}").unwrap();
    writeln!(helpers, "{}", "        if ch == '\"' {{ in_string = true; i += 1; continue; }}").unwrap();
    writeln!(helpers, "{}", "        if ch == '<' {{ in_iri = true; i += 1; continue; }}").unwrap();
    writeln!(
        helpers,
        "{}",
        "        if i + 5 <= bytes.len() {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            let slice = &query[i..i + 5];"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "            if slice.eq_ignore_ascii_case(\"where\") {{"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                let before_ok = i == 0 || !((bytes[i - 1] as char).is_ascii_alphanumeric() || bytes[i - 1] as char == '_');"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                let after_idx = i + 5;"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                let after_ok = after_idx >= bytes.len() || !((bytes[after_idx] as char).is_ascii_alphanumeric() || bytes[after_idx] as char == '_');"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                if !(before_ok && after_ok) {{ i += 1; continue; }}"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "                let mut j = i + 5;"
    )
    .unwrap();
    writeln!(helpers, "{}", "                while j < bytes.len() {{").unwrap();
    writeln!(helpers, "{}", "                    let c = bytes[j] as char;").unwrap();
    writeln!(helpers, "{}", "                    if c.is_whitespace() {{ j += 1; continue; }}").unwrap();
    writeln!(helpers, "{}", "                    if c == '#' {{ while j < bytes.len() && bytes[j] as char != '\\n' {{ j += 1; }} continue; }}").unwrap();
    writeln!(helpers, "{}", "                    break;").unwrap();
    writeln!(helpers, "{}", "                }}").unwrap();
    writeln!(helpers, "{}", "                if j < bytes.len() && bytes[j] as char == '{' {{").unwrap();
    writeln!(
        helpers,
        "{}",
        "                    let mut out = String::with_capacity(query.len() + bindings_clause.len() + 2);"
    )
    .unwrap();
    writeln!(helpers, "{}", "                    out.push_str(&query[..j + 1]);").unwrap();
    writeln!(helpers, "{}", "                    out.push('\\n');").unwrap();
    writeln!(helpers, "{}", "                    out.push_str(bindings_clause);").unwrap();
    writeln!(helpers, "{}", "                    out.push('\\n');").unwrap();
    writeln!(helpers, "{}", "                    out.push_str(&query[j + 1..]);").unwrap();
    writeln!(helpers, "{}", "                    return out;").unwrap();
    writeln!(helpers, "{}", "                }}").unwrap();
    writeln!(helpers, "{}", "            }}").unwrap();
    writeln!(helpers, "{}", "        }}").unwrap();
    writeln!(helpers, "{}", "        i += 1;").unwrap();
    writeln!(helpers, "{}", "    }}").unwrap();
    writeln!(helpers, "{}", "    query.to_string()").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    writeln!(
        helpers,
        "{}",
        "fn query_mentions_var(query: &str, var: &str) -> bool {"
    )
    .unwrap();
    writeln!(
        helpers,
        "{}",
        "    fn contains(query: &str, prefix: char, var: &str) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "        let mut start = 0;").unwrap();
    writeln!(helpers, "        let bytes = query.as_bytes();").unwrap();
    writeln!(helpers, "        let var_bytes = var.as_bytes();").unwrap();
    writeln!(
        helpers,
        "{}",
        "        while let Some(pos) = query[start..].find(prefix) {"
    )
    .unwrap();
    writeln!(helpers, "            let idx = start + pos + 1;").unwrap();
    writeln!(helpers, "{}", "            if bytes.len() >= idx + var_bytes.len() && &bytes[idx..idx + var_bytes.len()] == var_bytes {").unwrap();
    writeln!(
        helpers,
        "                let after = idx + var_bytes.len();"
    )
    .unwrap();
    writeln!(helpers, "{}", "                if after >= bytes.len() {").unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "                let next = bytes[after] as char;").unwrap();
    writeln!(
        helpers,
        "{}",
        "                if !next.is_ascii_alphanumeric() && next != '_' {"
    )
    .unwrap();
    writeln!(helpers, "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "            start += pos + 1;").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "        false").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(
        helpers,
        "    contains(query, '?', var) || contains(query, '$', var)"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn sparql_any_solution(query: &str, store: &Store, graph: Option<GraphNameRef<'_>>, selector: Option<&Term>, focus: Option<&Term>, value: Option<&Term>) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "    let prefixes = match selector {{").unwrap();
    writeln!(
        helpers,
        "        Some(selector) => prefixes_for_selector(store, selector),"
    )
    .unwrap();
    writeln!(helpers, "        None => String::new(),").unwrap();
    writeln!(helpers, "    }};").unwrap();
    writeln!(
        helpers,
        "    sparql_any_solution_with_bindings(query, &prefixes, store, graph, focus, value, &[])"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "{}", "fn sparql_any_solution_with_bindings(query: &str, prefixes: &str, store: &Store, graph: Option<GraphNameRef<'_>>, focus: Option<&Term>, value: Option<&Term>, bindings: &[(&str, Term)]) -> bool {").unwrap();
    writeln!(helpers, "{}", "    let mut normalized_query = query.replace('$', \"?\");").unwrap();
    writeln!(helpers, "{}", "    let debug = std::env::var(\"SHACL_DEBUG_SPARQL\").is_ok();").unwrap();
    writeln!(helpers, "{}", "    let mut bind_lines: Vec<String> = Vec::new();").unwrap();
    writeln!(helpers, "{}", "    let mut remaining: Vec<(String, Term)> = Vec::new();").unwrap();
    writeln!(helpers, "{}", "    let mut bind_everywhere = false;").unwrap();
    writeln!(helpers, "{}", "    if let Some(focus) = focus {").unwrap();
    writeln!(helpers, "{}", "        if query_mentions_var(query, \"this\") {").unwrap();
    writeln!(helpers, "{}", "            if let Some(ground) = term_to_sparql_ground(focus) {").unwrap();
    writeln!(helpers, "{}", "                bind_lines.push(format!(\"BIND({} AS ?this)\", ground));").unwrap();
    writeln!(helpers, "{}", "                bind_everywhere = true;").unwrap();
    writeln!(helpers, "{}", "            } else {").unwrap();
    writeln!(helpers, "{}", "                remaining.push((\"this\".to_string(), focus.clone()));").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if let Some(value) = value {").unwrap();
    writeln!(helpers, "{}", "        if query_mentions_var(query, \"value\") {").unwrap();
    writeln!(helpers, "{}", "            if let Some(ground) = term_to_sparql_ground(value) {").unwrap();
    writeln!(helpers, "{}", "                bind_lines.push(format!(\"BIND({} AS ?value)\", ground));").unwrap();
    writeln!(helpers, "{}", "                bind_everywhere = true;").unwrap();
    writeln!(helpers, "{}", "            } else {").unwrap();
    writeln!(helpers, "{}", "                remaining.push((\"value\".to_string(), value.clone()));").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    for (name, term) in bindings {").unwrap();
    writeln!(helpers, "{}", "        if query_mentions_var(query, name) {").unwrap();
    writeln!(helpers, "{}", "            if let Some(ground) = term_to_sparql_ground(term) {").unwrap();
    writeln!(helpers, "{}", "                bind_lines.push(format!(\"BIND({} AS ?{})\", ground, name));").unwrap();
    writeln!(helpers, "{}", "            } else {").unwrap();
    writeln!(helpers, "{}", "                remaining.push(((*name).to_string(), term.clone()));").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if !bind_lines.is_empty() {").unwrap();
    writeln!(helpers, "{}", "        let bindings_clause = bind_lines.join(\"\\n\");").unwrap();
    writeln!(helpers, "{}", "        normalized_query = if bind_everywhere { inject_bindings_everywhere(&normalized_query, &bindings_clause) } else { inject_values_clause(&normalized_query, &bindings_clause) };").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    let query_str = if prefixes.trim().is_empty() { normalized_query.clone() } else { format!(\"{}\\n{}\", prefixes, normalized_query) };").unwrap();
    writeln!(helpers, "{}", "    if debug { eprintln!(\"SPARQL query:\\n{}\", query_str); }").unwrap();
    writeln!(helpers, "{}", "    let mut prepared = match SparqlEvaluator::new().parse_query(&query_str) {").unwrap();
    writeln!(helpers, "{}", "        Ok(prepared) => prepared,").unwrap();
    writeln!(helpers, "{}", "        Err(err) => { if debug { eprintln!(\"SPARQL parse error: {}\", err); } return false },").unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(helpers, "{}", "    if let Some(graph) = graph {").unwrap();
    writeln!(helpers, "{}", "        prepared.dataset_mut().set_default_graph(vec![graph.into_owned()]);").unwrap();
    writeln!(helpers, "{}", "    } else {").unwrap();
    writeln!(helpers, "{}", "        prepared.dataset_mut().set_default_graph_as_union();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    let mut bound = prepared.on_store(store);").unwrap();
    writeln!(helpers, "{}", "    for (name, term) in remaining.iter() {").unwrap();
    writeln!(helpers, "{}", "        bound = bound.substitute_variable(Variable::new_unchecked(name.as_str()), term.clone());").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    match bound.execute() {").unwrap();
    writeln!(helpers, "{}", "        Ok(QueryResults::Solutions(solutions)) => {").unwrap();
    writeln!(helpers, "{}", "            for result in solutions {").unwrap();
    writeln!(helpers, "{}", "                if result.is_ok() {").unwrap();
    writeln!(helpers, "{}", "                    return true;").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "            false").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "        Ok(QueryResults::Boolean(val)) => val,").unwrap();
    writeln!(helpers, "{}", "        Ok(QueryResults::Graph(_)) => false,").unwrap();
    writeln!(helpers, "{}", "        Err(err) => {").unwrap();
    writeln!(helpers, "{}", "            if debug { eprintln!(\"SPARQL execute error: {}\", err); }").unwrap();
    writeln!(helpers, "{}", "            false").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "{}", "fn sparql_select_solutions_with_bindings(query: &str, prefixes: &str, store: &Store, graph: Option<GraphNameRef<'_>>, focus: Option<&Term>, value: Option<&Term>, bindings: &[(&str, Term)]) -> Vec<HashMap<String, Term>> {").unwrap();
    writeln!(helpers, "{}", "    let mut normalized_query = query.replace('$', \"?\");").unwrap();
    writeln!(helpers, "{}", "    let debug = std::env::var(\"SHACL_DEBUG_SPARQL\").is_ok();").unwrap();
    writeln!(helpers, "{}", "    let mut bind_lines: Vec<String> = Vec::new();").unwrap();
    writeln!(helpers, "{}", "    let mut remaining: Vec<(String, Term)> = Vec::new();").unwrap();
    writeln!(helpers, "{}", "    let mut bind_everywhere = false;").unwrap();
    writeln!(helpers, "{}", "    if let Some(focus) = focus {").unwrap();
    writeln!(helpers, "{}", "        if query_mentions_var(query, \"this\") {").unwrap();
    writeln!(helpers, "{}", "            if let Some(ground) = term_to_sparql_ground(focus) {").unwrap();
    writeln!(helpers, "{}", "                bind_lines.push(format!(\"BIND({} AS ?this)\", ground));").unwrap();
    writeln!(helpers, "{}", "                bind_everywhere = true;").unwrap();
    writeln!(helpers, "{}", "            } else {").unwrap();
    writeln!(helpers, "{}", "                remaining.push((\"this\".to_string(), focus.clone()));").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if let Some(value) = value {").unwrap();
    writeln!(helpers, "{}", "        if query_mentions_var(query, \"value\") {").unwrap();
    writeln!(helpers, "{}", "            if let Some(ground) = term_to_sparql_ground(value) {").unwrap();
    writeln!(helpers, "{}", "                bind_lines.push(format!(\"BIND({} AS ?value)\", ground));").unwrap();
    writeln!(helpers, "{}", "                bind_everywhere = true;").unwrap();
    writeln!(helpers, "{}", "            } else {").unwrap();
    writeln!(helpers, "{}", "                remaining.push((\"value\".to_string(), value.clone()));").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    for (name, term) in bindings {").unwrap();
    writeln!(helpers, "{}", "        if query_mentions_var(query, name) {").unwrap();
    writeln!(helpers, "{}", "            if let Some(ground) = term_to_sparql_ground(term) {").unwrap();
    writeln!(helpers, "{}", "                bind_lines.push(format!(\"BIND({} AS ?{})\", ground, name));").unwrap();
    writeln!(helpers, "{}", "            } else {").unwrap();
    writeln!(helpers, "{}", "                remaining.push(((*name).to_string(), term.clone()));").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if !bind_lines.is_empty() {").unwrap();
    writeln!(helpers, "{}", "        let bindings_clause = bind_lines.join(\"\\n\");").unwrap();
    writeln!(helpers, "{}", "        normalized_query = if bind_everywhere { inject_bindings_everywhere(&normalized_query, &bindings_clause) } else { inject_values_clause(&normalized_query, &bindings_clause) };").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    let query_str = if prefixes.trim().is_empty() { normalized_query.clone() } else { format!(\"{}\\n{}\", prefixes, normalized_query) };").unwrap();
    writeln!(helpers, "{}", "    if debug { eprintln!(\"SPARQL query:\\n{}\", query_str); }").unwrap();
    writeln!(helpers, "{}", "    let mut prepared = match SparqlEvaluator::new().parse_query(&query_str) {").unwrap();
    writeln!(helpers, "{}", "        Ok(prepared) => prepared,").unwrap();
    writeln!(helpers, "{}", "        Err(err) => { if debug { eprintln!(\"SPARQL parse error: {}\", err); } return Vec::new() },").unwrap();
    writeln!(helpers, "{}", "    };").unwrap();
    writeln!(helpers, "{}", "    if let Some(graph) = graph {").unwrap();
    writeln!(helpers, "{}", "        prepared.dataset_mut().set_default_graph(vec![graph.into_owned()]);").unwrap();
    writeln!(helpers, "{}", "    } else {").unwrap();
    writeln!(helpers, "{}", "        prepared.dataset_mut().set_default_graph_as_union();").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    let mut bound = prepared.on_store(store);").unwrap();
    writeln!(helpers, "{}", "    for (name, term) in remaining.iter() {").unwrap();
    writeln!(helpers, "{}", "        bound = bound.substitute_variable(Variable::new_unchecked(name.as_str()), term.clone());").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    let mut out: Vec<HashMap<String, Term>> = Vec::new();").unwrap();
    writeln!(helpers, "{}", "    match bound.execute() {").unwrap();
    writeln!(helpers, "{}", "        Ok(QueryResults::Solutions(solutions)) => {").unwrap();
    writeln!(helpers, "{}", "            for solution in solutions {").unwrap();
    writeln!(helpers, "{}", "                let solution = match solution { Ok(solution) => solution, Err(_) => continue };").unwrap();
    writeln!(helpers, "{}", "                let mut row: HashMap<String, Term> = HashMap::new();").unwrap();
    writeln!(helpers, "{}", "                for var in solution.variables() {").unwrap();
    writeln!(helpers, "{}", "                    if let Some(term) = solution.get(var) {").unwrap();
    writeln!(helpers, "{}", "                        row.insert(var.as_str().to_string(), term.clone());").unwrap();
    writeln!(helpers, "{}", "                    }").unwrap();
    writeln!(helpers, "{}", "                }").unwrap();
    writeln!(helpers, "{}", "                out.push(row);").unwrap();
    writeln!(helpers, "{}", "            }").unwrap();
    writeln!(helpers, "{}", "        }").unwrap();
    writeln!(helpers, "{}", "        Ok(_) => {},").unwrap();
    writeln!(helpers, "{}", "        Err(err) => { if debug { eprintln!(\"SPARQL execute error: {}\", err); } },").unwrap();
    writeln!(helpers, "{}", "    }").unwrap();
    writeln!(helpers, "{}", "    if debug { eprintln!(\"SPARQL solutions: {}\", out.len()); }").unwrap();
    writeln!(helpers, "{}", "    out").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn sparql_any_solution_lenient(query: &str, store: &Store, graph: Option<GraphNameRef<'_>>, selector: Option<&Term>, focus: Option<&Term>, value: Option<&Term>) -> bool {"
    )
    .unwrap();
    writeln!(helpers, "    let prefixes = match selector {{").unwrap();
    writeln!(
        helpers,
        "        Some(selector) => prefixes_for_selector(store, selector),"
    )
    .unwrap();
    writeln!(helpers, "        None => String::new(),").unwrap();
    writeln!(helpers, "    }};").unwrap();
    writeln!(
        helpers,
        "    sparql_any_solution_with_bindings(query, &prefixes, store, graph, focus, value, &[])"
    )
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(helpers, "{}", "pub fn data_graph_named() -> NamedNode {").unwrap();
    writeln!(helpers, "    NamedNode::new(DATA_GRAPH).unwrap()").unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();
    writeln!(
        helpers,
        "{}",
        "fn load_shape_ir() -> Result<ShapeIR, String> {"
    )
    .unwrap();
    writeln!(helpers, "{}", "    serde_json::from_str(include_str!(\"shape_ir.json\")).map_err(|e| format!(\"Failed to deserialize shape IR: {}\", e))")
    .unwrap();
    writeln!(helpers, "{}", "}").unwrap();
    writeln!(helpers, "").unwrap();

    emit_shape_and_component_maps(&mut helpers, plan)?;
    emit_validation_report_helpers(&mut helpers)?;

    let term_iri = |term_id: u64| term_iri(plan, term_id);
    let term_expr = |term_id: u64| term_expr_id(plan, term_id);
    let term_sparql = |term_id: u64| term_sparql_const(plan, term_id);

    emit_inference(&mut inference, plan, &term_expr, &term_iri)?;

    emit_path_functions(&mut paths, plan)?;
    emit_shape_triples(&mut shape_triples, &mut shape_graph_nt, plan)?;
    emit_subclass_edges(&mut helpers, plan)?;

    let component_lookup: HashMap<CompId, _> = plan.components.iter().map(|c| (c.id, c)).collect();
    let node_shape_lookup: HashMap<u64, _> = plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Node)
        .map(|s| (s.id, s))
        .collect();
    let property_shape_lookup: HashMap<u64, _> = plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Property)
        .map(|s| (s.id, s))
        .collect();

    let qualified_siblings = build_qualified_sibling_map(plan, &component_lookup);
    let allowed_predicate_map =
        build_allowed_predicate_map(plan, &component_lookup, &property_shape_lookup)?;

    // Property shape validators.
    for shape in plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Property)
    {
        if shape.deactivated {
            continue;
        }
        let path_id = shape
            .path
            .ok_or_else(|| format!("Property shape {} missing path", shape.id))?;
        let path_display = path_to_string(plan, path_id)?;

        let mut emission = PropertyEmission::default();
        for component_id in &shape.constraints {
            let component = component_lookup
                .get(component_id)
                .ok_or_else(|| format!("Missing component {}", component_id))?;
            let handler = registry::lookup(component.kind);
            let sibling_list = if component.kind == ComponentKind::QualifiedValueShape {
                Some(
                    qualified_siblings
                        .get(&component.id)
                        .map(|v| v.as_slice())
                        .unwrap_or(&[]),
                )
            } else {
                None
            };
            let ctx = EmitContext {
                shape_id: shape.id,
                component_id: component.id,
                kind: component.kind,
                path_id: Some(path_id),
                path_sparql: Some(&path_display),
                term_iri: &term_iri,
                term_expr: &term_expr,
                term_sparql: &term_sparql,
                qualified_siblings: sibling_list,
            };
            let component_emission = handler.emit_property(ctx, &component.params)?;
            emission.merge(component_emission);
        }

        writeln!(
            property_validators,
            "fn validate_property_shape_{}_for_focus(",
            shape.id
        )
        .unwrap();
        writeln!(property_validators, "    store: &Store,").unwrap();
        writeln!(property_validators, "    graph: Option<GraphNameRef<'_>>,").unwrap();
        writeln!(property_validators, "    focus: &Term,").unwrap();
        writeln!(property_validators, "    report: &mut Report,").unwrap();
        writeln!(property_validators, "{}", ") {").unwrap();
        writeln!(
            property_validators,
            "    let values = path_{}(store, graph, focus);",
            path_id
        )
        .unwrap();
        if let Some(predicate_iri) = simple_predicate_iri(plan, path_id)? {
            writeln!(
                property_validators,
                "    let values = canonicalize_values_for_predicate(store, graph, focus, \"{}\", values);",
                escape_rust_string(&predicate_iri)
            )
            .unwrap();
        }
        if emission.needs_count {
            writeln!(
                property_validators,
                "    let count: u64 = values.len() as u64;"
            )
            .unwrap();
        }
        for line in &emission.pre_loop_lines {
            writeln!(property_validators, "{}", line).unwrap();
        }
        if !emission.per_value_lines.is_empty() {
            writeln!(
                property_validators,
                "{}",
                "    for value in values.iter().cloned() {"
            )
            .unwrap();
            for line in &emission.per_value_lines {
                writeln!(property_validators, "{}", line).unwrap();
            }
            writeln!(property_validators, "{}", "    }").unwrap();
        }
        for line in &emission.post_loop_lines {
            writeln!(property_validators, "{}", line).unwrap();
        }
        writeln!(property_validators, "{}", "}").unwrap();
        writeln!(property_validators, "").unwrap();

        if !shape.targets.is_empty() {
            emit_target_collector(&mut targets, shape, &term_iri, &term_expr)?;
            writeln!(property_validators, "pub fn validate_property_shape_{}(store: &Store, graph: Option<GraphNameRef<'_>>, report: &mut Report) {{", shape.id).unwrap();
            writeln!(
                property_validators,
                "    let targets = collect_targets_prop_{}(store, graph);",
                shape.id
            )
            .unwrap();
            writeln!(property_validators, "{}", "    for focus in targets {").unwrap();
            writeln!(
                property_validators,
                "        validate_property_shape_{}_for_focus(store, graph, &focus, report);",
                shape.id
            )
            .unwrap();
            writeln!(property_validators, "{}", "    }").unwrap();
            writeln!(property_validators, "{}", "}").unwrap();
            writeln!(property_validators, "").unwrap();
        }
    }

    // Node shape validators.
    for shape in plan.shapes.iter().filter(|s| s.kind == PlanShapeKind::Node) {
        let has_closed = shape.constraints.iter().any(|comp_id| {
            component_lookup
                .get(comp_id)
                .map(|c| c.kind == ComponentKind::Closed)
                .unwrap_or(false)
        });
        if has_closed {
            let preds = allowed_predicate_map
                .get(&shape.id)
                .cloned()
                .unwrap_or_default();
            writeln!(
                allowed_predicates,
                "fn allowed_predicates_{}() -> HashSet<String> {{",
                shape.id
            )
            .unwrap();
            writeln!(
                allowed_predicates,
                "    let mut set: HashSet<String> = HashSet::new();"
            )
            .unwrap();
            for pred in preds {
                writeln!(
                    allowed_predicates,
                    "    set.insert(\"{}\".to_string());",
                    escape_rust_string(&pred)
                )
                .unwrap();
            }
            writeln!(allowed_predicates, "    set").unwrap();
            writeln!(allowed_predicates, "{}", "}").unwrap();
            writeln!(allowed_predicates, "").unwrap();
        }
    }

    // Node shape validators.
    for shape in plan.shapes.iter().filter(|s| s.kind == PlanShapeKind::Node) {
        if shape.deactivated {
            continue;
        }
        emit_target_collector(&mut targets, shape, &term_iri, &term_expr)?;

        writeln!(node_validators, "fn validate_node_shape_{}_for_focus(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term, report: &mut Report) {{", shape.id).unwrap();
        if shape.constraints.is_empty() {
            writeln!(
                node_validators,
                "    let _ = (store, graph, focus, report);"
            )
            .unwrap();
        } else {
            for component_id in &shape.constraints {
                let component = component_lookup
                    .get(component_id)
                    .ok_or_else(|| format!("Missing component {}", component_id))?;
                let handler = registry::lookup(component.kind);
                let ctx = EmitContext {
                    shape_id: shape.id,
                    component_id: component.id,
                    kind: component.kind,
                    path_id: None,
                    path_sparql: None,
                    term_iri: &term_iri,
                    term_expr: &term_expr,
                    term_sparql: &term_sparql,
                    qualified_siblings: None,
                };
                let emission = handler.emit_node(ctx, &component.params)?;
                for line in emission.lines {
                    writeln!(node_validators, "{}", line).unwrap();
                }
            }
        }
        writeln!(node_validators, "{}", "}").unwrap();
        writeln!(node_validators, "").unwrap();

        writeln!(node_validators, "fn node_shape_conforms_{}(store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term) -> bool {{", shape.id).unwrap();
        writeln!(node_validators, "    let mut report = Report::default();").unwrap();
        writeln!(
            node_validators,
            "    validate_node_shape_{}_for_focus(store, graph, focus, &mut report);",
            shape.id
        )
        .unwrap();
        writeln!(node_validators, "    report.violations.is_empty()").unwrap();
        writeln!(node_validators, "{}", "}").unwrap();
        writeln!(node_validators, "").unwrap();

        writeln!(node_validators, "pub fn validate_node_shape_{}(store: &Store, graph: Option<GraphNameRef<'_>>, report: &mut Report) {{", shape.id).unwrap();
        writeln!(
            node_validators,
            "    let targets = collect_targets_node_{}(store, graph);",
            shape.id
        )
        .unwrap();
        writeln!(node_validators, "{}", "    for focus in targets {").unwrap();
        writeln!(
            node_validators,
            "        validate_node_shape_{}_for_focus(store, graph, &focus, report);",
            shape.id
        )
        .unwrap();
        writeln!(node_validators, "{}", "    }").unwrap();
        writeln!(node_validators, "{}", "}").unwrap();
        writeln!(node_validators, "").unwrap();
    }

    writeln!(
        run,
        "{}",
        "type ValidateFn = for<'a> fn(&Store, Option<GraphNameRef<'a>>, &mut Report);"
    )
    .unwrap();
    writeln!(run, "{}", "struct ThreadState {").unwrap();
    writeln!(run, "    closure: Option<SubclassClosure>,").unwrap();
    writeln!(run, "    original_index: Option<OriginalValueIndex>,").unwrap();
    writeln!(run, "{}", "}").unwrap();
    writeln!(run, "").unwrap();
    writeln!(run, "{}", "const NODE_SHAPE_VALIDATORS: &[ValidateFn] = &[").unwrap();
    for shape_id in &plan.order.node_shapes {
        let shape = node_shape_lookup
            .get(shape_id)
            .ok_or_else(|| format!("Missing node shape {}", shape_id))?;
        if shape.deactivated {
            continue;
        }
        writeln!(run, "    validate_node_shape_{},", shape.id).unwrap();
    }
    writeln!(run, "];").unwrap();
    writeln!(
        run,
        "{}",
        "const PROPERTY_SHAPE_VALIDATORS: &[ValidateFn] = &["
    )
    .unwrap();
    for shape_id in &plan.order.property_shapes {
        let shape = property_shape_lookup
            .get(shape_id)
            .ok_or_else(|| format!("Missing property shape {}", shape_id))?;
        if shape.deactivated || shape.targets.is_empty() {
            continue;
        }
        writeln!(run, "    validate_property_shape_{},", shape.id).unwrap();
    }
    writeln!(run, "];").unwrap();
    writeln!(run, "").unwrap();
    writeln!(
        run,
        "{}",
        "pub fn run(store: &Store, data_graph: Option<&NamedNode>) -> Report {"
    )
    .unwrap();
    writeln!(run, "    let default_data_graph = data_graph_named();").unwrap();
    writeln!(
        run,
        "    let graph_node = data_graph.unwrap_or(&default_data_graph);"
    )
    .unwrap();
    writeln!(run, "    let graph = graph_ref(Some(graph_node));").unwrap();
    writeln!(run, "    let mut report = Report::default();").unwrap();
    writeln!(run, "    info!(\"Starting shape graph load\");").unwrap();
    writeln!(run, "    insert_shape_triples(store);").unwrap();
    writeln!(run, "    info!(\"Finished shape graph load\");").unwrap();
    writeln!(
        run,
        "    set_current_subclass_closure(subclass_closure_from_shape_edges());"
    )
    .unwrap();
    writeln!(
        run,
        "    extend_current_subclass_closure_from_store(store, Some(shape_graph_ref()));"
    )
    .unwrap();
    writeln!(
        run,
        "    extend_current_subclass_closure_from_store(store, Some(GraphNameRef::NamedNode(graph_node.as_ref())));"
    )
    .unwrap();
    writeln!(run, "    clear_target_class_caches();").unwrap();
    writeln!(run, "{}", "    info!(\"Starting inference\");").unwrap();
    writeln!(
        run,
        "{}",
        "    match run_inference(store, graph, graph_node) {"
    )
    .unwrap();
    writeln!(run, "{}", "        Ok(_) => info!(\"Finished inference\"),").unwrap();
    writeln!(run, "{}", "        Err(err) => {").unwrap();
    writeln!(
        run,
        "{}",
        "            eprintln!(\"Inference failed: {}\", err);"
    )
    .unwrap();
    writeln!(run, "{}", "            info!(\"Inference failed\");").unwrap();
    writeln!(run, "{}", "        }").unwrap();
    writeln!(run, "{}", "    }").unwrap();
    writeln!(
        run,
        "    extend_current_subclass_closure_from_store(store, Some(GraphNameRef::NamedNode(graph_node.as_ref())));"
    )
    .unwrap();
    writeln!(run, "{}", "    info!(\"Starting validation\");").unwrap();
    writeln!(
        run,
        "    let validation_closure = with_subclass_closure(|closure| closure.clone());"
    )
    .unwrap();
    writeln!(
        run,
        "    let original_index = with_original_value_index(|idx| idx.cloned());"
    )
    .unwrap();
    writeln!(run, "    let node_reports: Vec<Report> = NODE_SHAPE_VALIDATORS").unwrap();
    writeln!(run, "        .par_iter()").unwrap();
    writeln!(
        run,
        "{}",
        "        .map_init(|| ThreadState { closure: Some(validation_closure.clone()), original_index: original_index.clone() }, |state, validator| {"
    )
    .unwrap();
    writeln!(
        run,
        "{}",
        "            if let Some(closure) = state.closure.take() {"
    )
    .unwrap();
    writeln!(run, "                init_thread_state(closure);").unwrap();
    writeln!(run, "{}", "            }").unwrap();
    writeln!(
        run,
        "{}",
        "            if let Some(index) = state.original_index.take() {"
    )
    .unwrap();
    writeln!(run, "                set_original_value_index(Some(index));").unwrap();
    writeln!(run, "{}", "            }").unwrap();
    writeln!(run, "            let mut local = Report::default();").unwrap();
    writeln!(run, "            validator(store, graph, &mut local);").unwrap();
    writeln!(run, "            local").unwrap();
    writeln!(run, "{}", "        })").unwrap();
    writeln!(run, "        .collect();").unwrap();
    writeln!(run, "{}", "    for local in node_reports {").unwrap();
    writeln!(run, "        report.merge(local);").unwrap();
    writeln!(run, "{}", "    }").unwrap();
    writeln!(
        run,
        "    let prop_reports: Vec<Report> = PROPERTY_SHAPE_VALIDATORS"
    )
    .unwrap();
    writeln!(run, "        .par_iter()").unwrap();
    writeln!(
        run,
        "{}",
        "        .map_init(|| ThreadState { closure: Some(validation_closure.clone()), original_index: original_index.clone() }, |state, validator| {"
    )
    .unwrap();
    writeln!(
        run,
        "{}",
        "            if let Some(closure) = state.closure.take() {"
    )
    .unwrap();
    writeln!(run, "                init_thread_state(closure);").unwrap();
    writeln!(run, "{}", "            }").unwrap();
    writeln!(
        run,
        "{}",
        "            if let Some(index) = state.original_index.take() {"
    )
    .unwrap();
    writeln!(run, "                set_original_value_index(Some(index));").unwrap();
    writeln!(run, "{}", "            }").unwrap();
    writeln!(run, "            let mut local = Report::default();").unwrap();
    writeln!(run, "            validator(store, graph, &mut local);").unwrap();
    writeln!(run, "            local").unwrap();
    writeln!(run, "{}", "        })").unwrap();
    writeln!(run, "        .collect();").unwrap();
    writeln!(run, "{}", "    for local in prop_reports {").unwrap();
    writeln!(run, "        report.merge(local);").unwrap();
    writeln!(run, "{}", "    }").unwrap();
    writeln!(run, "{}", "    info!(\"Finished validation\");").unwrap();
    writeln!(run, "    report").unwrap();
    writeln!(run, "{}", "}").unwrap();
    writeln!(run, "").unwrap();
    Ok(Sections {
        prelude,
        helpers,
        paths,
        shape_triples,
        shape_graph_nt,
        targets,
        allowed_predicates,
        property_validators,
        node_validators,
        inference,
        run,
    })
}

fn emit_target_collector(
    out: &mut String,
    shape: &PlanShape,
    term_iri: &dyn Fn(u64) -> Result<String, String>,
    term_expr: &dyn Fn(u64) -> Result<String, String>,
) -> Result<(), String> {
    let func_prefix = match shape.kind {
        PlanShapeKind::Node => "node",
        PlanShapeKind::Property => "prop",
    };
    writeln!(
        out,
        "fn collect_targets_{}_{}(store: &Store, graph: Option<GraphNameRef<'_>>) -> Vec<Term> {{",
        func_prefix, shape.id
    )
    .unwrap();
    writeln!(out, "    let mut seen: HashSet<Term> = HashSet::new();").unwrap();
    writeln!(out, "    let mut out: Vec<Term> = Vec::new();").unwrap();
    for target in &shape.targets {
        match target {
            PlanTarget::Class(term_id) => {
                let class_iri = term_iri(*term_id)?;
                writeln!(
                    out,
                    "    for focus in targets_for_class(store, graph, \"{}\") {{",
                    class_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::Node(term_id) => {
                let node_expr = term_expr(*term_id)?;
                let shape_expr = term_expr(shape.term)?;
                writeln!(out, "{}", "    {").unwrap();
                writeln!(out, "        let focus: Term = {};", node_expr).unwrap();
                writeln!(
                    out,
                    "        let shape_term: Term = deskolemize_term({});",
                    shape_expr
                )
                .unwrap();
                writeln!(out, "        let mut nodes = vec![focus];").unwrap();
                writeln!(
                    out,
                    "        let nodes = canonicalize_values_for_predicate(store, Some(shape_graph_ref()), &shape_term, \"http://www.w3.org/ns/shacl#targetNode\", nodes);"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "        for node in nodes { if seen.insert(node.clone()) { out.push(node); } }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::SubjectsOf(term_id) => {
                let pred_iri = term_iri(*term_id)?;
                writeln!(
                    out,
                    "    let pred_ref = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "    for quad in store.quads_for_pattern(None, Some(pred_ref), None, graph) {"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "        let quad = match quad { Ok(quad) => quad, Err(_) => continue };"
                )
                .unwrap();
                writeln!(out, "        let focus: Term = quad.subject.into();").unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::ObjectsOf(term_id) => {
                let pred_iri = term_iri(*term_id)?;
                writeln!(
                    out,
                    "    let pred_ref = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "    for quad in store.quads_for_pattern(None, Some(pred_ref), None, graph) {"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "        let quad = match quad { Ok(quad) => quad, Err(_) => continue };"
                )
                .unwrap();
                writeln!(out, "        let focus: Term = quad.object;").unwrap();
                writeln!(
                    out,
                    "{}",
                    "        if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            PlanTarget::Advanced(term_id) => {
                let selector_expr = term_expr(*term_id)?;
                writeln!(out, "{}", "    {").unwrap();
                writeln!(out, "        let selector: Term = {};", selector_expr).unwrap();
                writeln!(
                    out,
                    "{}",
                    "        for focus in advanced_targets_for(store, graph, &selector) {"
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "            if seen.insert(focus.clone()) { out.push(focus); }"
                )
                .unwrap();
                writeln!(out, "{}", "        }").unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
        }
    }
    writeln!(out, "    out").unwrap();
    writeln!(out, "{}", "}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn term_iri(plan: &PlanIR, term_id: u64) -> Result<String, String> {
    let term = plan
        .terms
        .get(term_id as usize)
        .ok_or_else(|| format!("Unknown term id {}", term_id))?;
    match term {
        Term::NamedNode(node) => Ok(node.as_str().to_string()),
        _ => Err("Expected NamedNode term".to_string()),
    }
}

fn path_to_string(plan: &PlanIR, path_id: u64) -> Result<String, String> {
    path_to_string_inner(plan, path_id, false)
}

fn path_to_string_inner(plan: &PlanIR, path_id: u64, wrap: bool) -> Result<String, String> {
    let path = plan
        .paths
        .get(path_id as usize)
        .ok_or_else(|| format!("Unknown path id {}", path_id))?;
    let rendered = match path {
        PlanPath::Simple(term_id) => term_sparql_const(plan, *term_id)?,
        PlanPath::Inverse(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("^{}", inner_str)
        }
        PlanPath::Sequence(paths) => {
            let mut parts = Vec::with_capacity(paths.len());
            for id in paths {
                parts.push(path_to_string_inner(plan, *id, true)?);
            }
            parts.join("/")
        }
        PlanPath::Alternative(paths) => {
            let mut parts = Vec::with_capacity(paths.len());
            for id in paths {
                parts.push(path_to_string_inner(plan, *id, true)?);
            }
            parts.join("|")
        }
        PlanPath::ZeroOrMore(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("{}*", inner_str)
        }
        PlanPath::OneOrMore(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("{}+", inner_str)
        }
        PlanPath::ZeroOrOne(inner) => {
            let inner_str = path_to_string_inner(plan, *inner, true)?;
            format!("{}?", inner_str)
        }
    };
    if wrap && !matches!(path, PlanPath::Simple(_)) {
        Ok(format!("({})", rendered))
    } else {
        Ok(rendered)
    }
}

fn simple_predicate_iri(plan: &PlanIR, path_id: u64) -> Result<Option<String>, String> {
    let path = plan
        .paths
        .get(path_id as usize)
        .ok_or_else(|| format!("Missing path {}", path_id))?;
    match path {
        PlanPath::Simple(term_id) => Ok(Some(term_iri(plan, *term_id)?)),
        _ => Ok(None),
    }
}

fn simple_predicate(plan: &PlanIR, path_id: u64) -> Result<String, String> {
    let path = plan
        .paths
        .get(path_id as usize)
        .ok_or_else(|| format!("Unknown path id {}", path_id))?;
    match path {
        PlanPath::Simple(term_id) => term_iri(plan, *term_id),
        _ => Err("Only simple predicate paths are supported here".to_string()),
    }
}

fn emit_path_functions(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    if plan.paths.is_empty() {
        writeln!(
            out,
            "fn path_term(_path_id: u64, _graph: &mut Graph) -> Term {{ Term::BlankNode(BlankNode::default()) }}"
        )
        .unwrap();
        writeln!(out, "").unwrap();
        return Ok(());
    }
    for (id, path) in plan.paths.iter().enumerate() {
        emit_path_function(out, plan, id as u64, path, false)?;
        emit_path_function(out, plan, id as u64, path, true)?;
    }
    emit_path_term_functions(out, plan)?;
    Ok(())
}

fn emit_inference(
    out: &mut String,
    plan: &PlanIR,
    term_expr: &dyn Fn(u64) -> Result<String, String>,
    term_iri: &dyn Fn(u64) -> Result<String, String>,
) -> Result<(), String> {
    let mut property_shape_targets: HashSet<u64> = HashSet::new();
    for shape in plan
        .shapes
        .iter()
        .filter(|s| s.kind == PlanShapeKind::Property)
    {
        if !shape.targets.is_empty() {
            property_shape_targets.insert(shape.id);
        }
    }

    let mut rule_targets: HashMap<u64, (Vec<u64>, Vec<u64>)> = HashMap::new();
    for (shape_id, rule_ids) in &plan.node_shape_rules {
        for rule_id in rule_ids {
            let entry = rule_targets
                .entry(*rule_id)
                .or_insert_with(|| (Vec::new(), Vec::new()));
            entry.0.push(*shape_id);
        }
    }
    for (shape_id, rule_ids) in &plan.property_shape_rules {
        if !property_shape_targets.contains(shape_id) {
            continue;
        }
        for rule_id in rule_ids {
            let entry = rule_targets
                .entry(*rule_id)
                .or_insert_with(|| (Vec::new(), Vec::new()));
            entry.1.push(*shape_id);
        }
    }

    for (_, targets) in rule_targets.iter_mut() {
        targets.0.sort_unstable();
        targets.1.sort_unstable();
    }

    let rule_ids: Vec<u64> = plan.rules.iter().map(|rule| rule.id).collect();
    if rule_ids.is_empty() {
        writeln!(out, "const INFERENCE_MAX_ITERATIONS: usize = 32;").unwrap();
        writeln!(out, "const INFERENCE_RULE_IDS: [u64; 0] = [];").unwrap();
    } else {
        let list = rule_ids
            .iter()
            .map(|id| id.to_string())
            .collect::<Vec<_>>()
            .join(", ");
        writeln!(out, "const INFERENCE_MAX_ITERATIONS: usize = 32;").unwrap();
        writeln!(
            out,
            "const INFERENCE_RULE_IDS: [u64; {}] = [{}];",
            rule_ids.len(),
            list
        )
        .unwrap();
    }
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn run_inference(store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode) -> Result<(), String> {{"
    )
    .unwrap();
    writeln!(out, "    let mut iterations: usize = 0;").unwrap();
    writeln!(out, "    loop {{").unwrap();
    writeln!(
        out,
        "        info!(\"Starting inference iteration {{}}\", iterations);"
    )
    .unwrap();
    writeln!(
        out,
        "        let mut seen_new: HashSet<(Term, NamedNode, Term)> = HashSet::new();"
    )
    .unwrap();
    writeln!(
        out,
        "        let added = run_inference_iteration(store, graph, graph_node, &mut seen_new)?;"
    )
    .unwrap();
    writeln!(
        out,
        "        info!(\"Iteration {{}} added {{}} triples\", iterations, added);"
    )
    .unwrap();
    writeln!(
        out,
        "        if added == 0 || iterations >= INFERENCE_MAX_ITERATIONS {{"
    )
    .unwrap();
    writeln!(out, "            break;").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        iterations = iterations.saturating_add(1);").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    Ok(())").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn run_inference_iteration(store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode, seen_new: &mut HashSet<(Term, NamedNode, Term)>) -> Result<usize, String> {{"
    )
    .unwrap();
    writeln!(out, "    let mut added: usize = 0;").unwrap();
    writeln!(
        out,
        "    let mut node_target_cache: HashMap<u64, Vec<Term>> = HashMap::new();"
    )
    .unwrap();
    writeln!(
        out,
        "    let mut prop_target_cache: HashMap<u64, Vec<Term>> = HashMap::new();"
    )
    .unwrap();
    writeln!(out, "    for rule_id in INFERENCE_RULE_IDS {{").unwrap();
    writeln!(
        out,
        "        let focus_nodes = focus_nodes_for_rule(rule_id, store, graph, &mut node_target_cache, &mut prop_target_cache);"
    )
    .unwrap();
    writeln!(out, "        if focus_nodes.is_empty() {{").unwrap();
    writeln!(out, "            continue;").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(
            out,
            "        let delta = apply_inference_rule(rule_id, store, graph, graph_node, &focus_nodes, seen_new)?;"
        )
        .unwrap();
    writeln!(out, "        added += delta;").unwrap();
    writeln!(out, "{}", "        if delta > 0 {").unwrap();
    writeln!(out, "            node_target_cache.clear();").unwrap();
    writeln!(out, "            prop_target_cache.clear();").unwrap();
    writeln!(out, "            clear_target_class_caches();").unwrap();
    writeln!(out, "{}", "        }").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    Ok(added)").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn focus_nodes_for_rule(rule_id: u64, store: &Store, graph: Option<GraphNameRef<'_>>, node_target_cache: &mut HashMap<u64, Vec<Term>>, prop_target_cache: &mut HashMap<u64, Vec<Term>>) -> Vec<Term> {{"
    )
    .unwrap();
    writeln!(out, "    match rule_id {{").unwrap();
    for rule in &plan.rules {
        let targets = rule_targets.get(&rule.id);
        writeln!(out, "        {} => {{", rule.id).unwrap();
        writeln!(
            out,
            "            let mut seen: HashSet<Term> = HashSet::new();"
        )
        .unwrap();
        writeln!(out, "            let mut nodes: Vec<Term> = Vec::new();").unwrap();
        if let Some((node_shapes, prop_shapes)) = targets {
            for node_shape in node_shapes {
                writeln!(
                    out,
                    "            if !node_target_cache.contains_key(&{}) {{",
                    node_shape
                )
                .unwrap();
                writeln!(
                    out,
                    "                let targets = collect_targets_node_{}(store, graph);",
                    node_shape
                )
                .unwrap();
                writeln!(
                    out,
                    "                node_target_cache.insert({}, targets);",
                    node_shape
                )
                .unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(
                    out,
                    "            if let Some(targets) = node_target_cache.get(&{}) {{",
                    node_shape
                )
                .unwrap();
                writeln!(out, "{}", "                for focus in targets {").unwrap();
                writeln!(
                    out,
                    "                    if seen.insert(focus.clone()) {{ nodes.push(focus.clone()); }}"
                )
                .unwrap();
                writeln!(out, "                }}").unwrap();
                writeln!(out, "            }}").unwrap();
            }
            for prop_shape in prop_shapes {
                writeln!(
                    out,
                    "            if !prop_target_cache.contains_key(&{}) {{",
                    prop_shape
                )
                .unwrap();
                writeln!(
                    out,
                    "                let targets = collect_targets_prop_{}(store, graph);",
                    prop_shape
                )
                .unwrap();
                writeln!(
                    out,
                    "                prop_target_cache.insert({}, targets);",
                    prop_shape
                )
                .unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(
                    out,
                    "            if let Some(targets) = prop_target_cache.get(&{}) {{",
                    prop_shape
                )
                .unwrap();
                writeln!(out, "{}", "                for focus in targets {").unwrap();
                writeln!(
                    out,
                    "                    if seen.insert(focus.clone()) {{ nodes.push(focus.clone()); }}"
                )
                .unwrap();
                writeln!(out, "                }}").unwrap();
                writeln!(out, "            }}").unwrap();
            }
        }
        writeln!(out, "            nodes").unwrap();
        writeln!(out, "        }}").unwrap();
    }
    writeln!(out, "        _ => Vec::new(),").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn rule_conditions_satisfied(rule_id: u64, store: &Store, graph: Option<GraphNameRef<'_>>, focus: &Term) -> bool {{"
    )
    .unwrap();
    writeln!(out, "    match rule_id {{").unwrap();
    for rule in &plan.rules {
        if rule.conditions.is_empty() {
            continue;
        }
        writeln!(out, "        {} => {{", rule.id).unwrap();
        for shape in &rule.conditions {
            writeln!(
                out,
                "            if !node_shape_conforms_{}(store, graph, focus) {{",
                shape
            )
            .unwrap();
            writeln!(out, "                return false;").unwrap();
            writeln!(out, "            }}").unwrap();
        }
        writeln!(out, "            true").unwrap();
        writeln!(out, "        }}").unwrap();
    }
    writeln!(out, "        _ => true,").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn apply_inference_rule(rule_id: u64, store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode, focus_nodes: &[Term], seen_new: &mut HashSet<(Term, NamedNode, Term)>) -> Result<usize, String> {{"
    )
    .unwrap();
    writeln!(out, "    match rule_id {{").unwrap();
    for rule in &plan.rules {
        writeln!(
            out,
            "        {} => inference_rule_{}(store, graph, graph_node, focus_nodes, seen_new),",
            rule.id, rule.id
        )
        .unwrap();
    }
    writeln!(out, "        _ => Ok(0),").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    for rule in &plan.rules {
        match &rule.kind {
            PlanRuleKind::Triple {
                subject,
                predicate,
                object,
            } => {
                let predicate_expr = term_iri(*predicate)?;
                writeln!(
                    out,
                    "fn inference_rule_{}(store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode, focus_nodes: &[Term], seen_new: &mut HashSet<(Term, NamedNode, Term)>) -> Result<usize, String> {{",
                    rule.id
                )
                .unwrap();
                writeln!(
                    out,
                    "    let predicate = NamedNode::new(\"{}\").unwrap();",
                    escape_rust_string(&predicate_expr)
                )
                .unwrap();
                writeln!(out, "    let mut added: usize = 0;").unwrap();
                writeln!(out, "    for focus in focus_nodes {{").unwrap();
                writeln!(
                    out,
                    "        if !rule_conditions_satisfied({}, store, graph, focus) {{",
                    rule.id
                )
                .unwrap();
                writeln!(out, "            continue;").unwrap();
                writeln!(out, "        }}").unwrap();

                writeln!(out, "        let subjects = {{").unwrap();
                match subject {
                    crate::plan::PlanRuleTerm::This => {
                        writeln!(out, "            let mut values = Vec::new();").unwrap();
                        writeln!(out, "            values.push(focus.clone());").unwrap();
                        writeln!(out, "            values").unwrap();
                    }
                    crate::plan::PlanRuleTerm::Constant(term_id) => {
                        let term_expr = term_expr(*term_id)?;
                        writeln!(out, "            let mut values = Vec::new();").unwrap();
                        writeln!(out, "            values.push({});", term_expr).unwrap();
                        writeln!(out, "            values").unwrap();
                    }
                    crate::plan::PlanRuleTerm::Path(path_id) => {
                        writeln!(out, "            path_{}(store, graph, focus)", path_id).unwrap();
                    }
                }
                writeln!(out, "        }};").unwrap();

                writeln!(out, "        let objects = {{").unwrap();
                match object {
                    crate::plan::PlanRuleTerm::This => {
                        writeln!(out, "            let mut values = Vec::new();").unwrap();
                        writeln!(out, "            values.push(focus.clone());").unwrap();
                        writeln!(out, "            values").unwrap();
                    }
                    crate::plan::PlanRuleTerm::Constant(term_id) => {
                        let term_expr = term_expr(*term_id)?;
                        writeln!(out, "            let mut values = Vec::new();").unwrap();
                        writeln!(out, "            values.push({});", term_expr).unwrap();
                        writeln!(out, "            values").unwrap();
                    }
                    crate::plan::PlanRuleTerm::Path(path_id) => {
                        writeln!(out, "            path_{}(store, graph, focus)", path_id).unwrap();
                    }
                }
                writeln!(out, "        }};").unwrap();

                writeln!(out, "        for subject_term in &subjects {{").unwrap();
                writeln!(out, "            for object_term in &objects {{").unwrap();
                writeln!(
                    out,
                    "                if record_inferred_quad(store, graph_node, seen_new, subject_term.clone(), predicate.clone(), object_term.clone())? {{"
                )
                .unwrap();
                writeln!(out, "                    added += 1;").unwrap();
                writeln!(out, "                }}").unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(out, "        }}").unwrap();
                writeln!(out, "    }}").unwrap();
                writeln!(out, "    Ok(added)").unwrap();
                writeln!(out, "}}").unwrap();
                writeln!(out, "").unwrap();
            }
            PlanRuleKind::Sparql { query } => {
                let escaped_query = escape_rust_string(query);
                writeln!(
                    out,
                    "fn inference_rule_{}(store: &Store, graph: Option<GraphNameRef<'_>>, graph_node: &NamedNode, focus_nodes: &[Term], seen_new: &mut HashSet<(Term, NamedNode, Term)>) -> Result<usize, String> {{",
                    rule.id
                )
                .unwrap();
                writeln!(out, "    let base_query = \"{}\";", escaped_query).unwrap();
                writeln!(
                    out,
                    "    let mut prepared = SparqlEvaluator::new().parse_query(base_query).map_err(|e| format!(\"Failed to parse inference query {{}}: {{}}\", {}, e))?;",
                    rule.id
                )
                .unwrap();
                writeln!(out, "    if let Some(graph) = graph {{").unwrap();
                writeln!(
                    out,
                    "        prepared.dataset_mut().set_default_graph(vec![graph.into_owned()]);"
                )
                .unwrap();
                writeln!(out, "    }} else {{").unwrap();
                writeln!(
                    out,
                    "        prepared.dataset_mut().set_default_graph_as_union();"
                )
                .unwrap();
                writeln!(out, "    }}").unwrap();
                writeln!(
                    out,
                    "    let var_this = Variable::new(\"this\").map_err(|e| format!(\"Inference rule {{}} failed to build variable: {{}}\", {}, e))?;",
                    rule.id
                )
                .unwrap();
                writeln!(out, "    let mut added: usize = 0;").unwrap();
                writeln!(out, "    for focus in focus_nodes {{").unwrap();
                writeln!(
                    out,
                    "        if !rule_conditions_satisfied({}, store, graph, focus) {{",
                    rule.id
                )
                .unwrap();
                writeln!(out, "            continue;").unwrap();
                writeln!(out, "        }}").unwrap();
                writeln!(
                    out,
                    "        let mut prepared_query = if query_mentions_var(base_query, \"this\") {{"
                )
                .unwrap();
                writeln!(
                    out,
                    "            if let Some(ground) = term_to_sparql_ground(focus) {{"
                )
                .unwrap();
                writeln!(
                    out,
                    "                let bindings = format!(\"BIND({{}} AS ?this)\", ground);"
                )
                .unwrap();
                writeln!(
                    out,
                    "                let bound_query = inject_bindings_in_where(base_query, &bindings);"
                )
                .unwrap();
                writeln!(
                    out,
                    "                let mut parsed = SparqlEvaluator::new().parse_query(&bound_query).map_err(|e| format!(\"Failed to parse inference query {{}}: {{}}\", {}, e))?;",
                    rule.id
                )
                .unwrap();
                writeln!(out, "                if let Some(graph) = graph {{").unwrap();
                writeln!(
                    out,
                    "                    parsed.dataset_mut().set_default_graph(vec![graph.into_owned()]);"
                )
                .unwrap();
                writeln!(out, "                }} else {{").unwrap();
                writeln!(
                    out,
                    "                    parsed.dataset_mut().set_default_graph_as_union();"
                )
                .unwrap();
                writeln!(out, "                }}").unwrap();
                writeln!(out, "                parsed").unwrap();
                writeln!(out, "            }} else {{").unwrap();
                writeln!(out, "                prepared.clone()").unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(out, "        }} else {{").unwrap();
                writeln!(out, "            prepared.clone()").unwrap();
                writeln!(out, "        }};").unwrap();
                writeln!(out, "        if let Some(graph) = graph {{").unwrap();
                writeln!(
                    out,
                    "            prepared_query.dataset_mut().set_default_graph(vec![graph.into_owned()]);"
                )
                .unwrap();
                writeln!(out, "        }} else {{").unwrap();
                writeln!(
                    out,
                    "            prepared_query.dataset_mut().set_default_graph_as_union();"
                )
                .unwrap();
                writeln!(out, "        }}").unwrap();
                writeln!(out, "        let mut bound = prepared_query.on_store(store);").unwrap();
                writeln!(
                    out,
                    "        if query_mentions_var(base_query, \"this\") && term_to_sparql_ground(focus).is_none() {{"
                )
                .unwrap();
                writeln!(
                    out,
                    "            bound = bound.substitute_variable(var_this.clone(), focus.clone());"
                )
                .unwrap();
                writeln!(out, "        }}").unwrap();
                writeln!(out, "        match bound.execute() {{").unwrap();
                writeln!(
                    out,
                    "            Ok(QueryResults::Graph(mut triples)) => {{"
                )
                .unwrap();
                writeln!(out, "                for triple_res in &mut triples {{").unwrap();
                writeln!(
                    out,
                    "                    let triple = triple_res.map_err(|e| format!(\"Inference rule {{}} failed: {{}}\", {}, e))?;",
                    rule.id
                )
                .unwrap();
                writeln!(out, "                    let subject_term = named_or_blank_to_term(&triple.subject);").unwrap();
                writeln!(out, "                    let object_term = triple.object;").unwrap();
                writeln!(out, "                    let predicate = triple.predicate;").unwrap();
                writeln!(out, "                    if record_inferred_quad(store, graph_node, seen_new, subject_term.clone(), predicate.clone(), object_term.clone())? {{").unwrap();
                writeln!(out, "                        added += 1;").unwrap();
                writeln!(out, "                    }}").unwrap();
                writeln!(out, "                }}").unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(out, "            Ok(_) => {{").unwrap();
                writeln!(
                    out,
                    "                return Err(format!(\"Inference rule {{}} returned non-graph result\", {}));",
                    rule.id
                )
                .unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(out, "            Err(e) => {{").unwrap();
                writeln!(out, "                return Err(e.to_string());").unwrap();
                writeln!(out, "            }}").unwrap();
                writeln!(out, "        }}").unwrap();
                writeln!(out, "    }}").unwrap();
                writeln!(out, "    Ok(added)").unwrap();
                writeln!(out, "}}").unwrap();
                writeln!(out, "").unwrap();
            }
        }
    }

    writeln!(
        out,
        "fn record_inferred_quad(store: &Store, graph_node: &NamedNode, seen_new: &mut HashSet<(Term, NamedNode, Term)>, subject_term: Term, predicate: NamedNode, object_term: Term) -> Result<bool, String> {{"
    )
    .unwrap();
    writeln!(
        out,
        "    let key = (subject_term.clone(), predicate.clone(), object_term.clone());"
    )
    .unwrap();
    writeln!(out, "    if seen_new.contains(&key) {{").unwrap();
    writeln!(out, "        return Ok(false);").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(
        out,
        "    let subject = term_to_named_or_blank_inference(&subject_term)?;"
    )
    .unwrap();
    writeln!(
        out,
        "    let graph = GraphName::NamedNode(graph_node.clone());"
    )
    .unwrap();
    writeln!(
        out,
        "    let quad = Quad::new(subject.clone(), predicate.clone(), object_term.clone(), graph.clone());"
    )
    .unwrap();
    writeln!(
        out,
        "    if store.contains(&quad).map_err(|e| e.to_string())? {{"
    )
    .unwrap();
    writeln!(out, "        return Ok(false);").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(
        out,
        "    store.insert(quad.as_ref()).map_err(|e| e.to_string())?;"
    )
    .unwrap();
    writeln!(out, "    seen_new.insert(key);").unwrap();
    writeln!(out, "    Ok(true)").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn term_to_named_or_blank_inference(term: &Term) -> Result<NamedOrBlankNode, String> {{"
    )
    .unwrap();
    writeln!(out, "    match term {{").unwrap();
    writeln!(
        out,
        "        Term::NamedNode(node) => Ok(node.clone().into()),"
    )
    .unwrap();
    writeln!(out, "        Term::BlankNode(bn) => Ok(bn.clone().into()),").unwrap();
    writeln!(
        out,
        "        other => Err(format!(\"Inference subject must be IRI or blank node, found {{:?}}\", other)),"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn named_or_blank_to_term(value: &NamedOrBlankNode) -> Term {{"
    )
    .unwrap();
    writeln!(out, "    match value {{").unwrap();
    writeln!(
        out,
        "        NamedOrBlankNode::NamedNode(nn) => Term::NamedNode(nn.clone()),"
    )
    .unwrap();
    writeln!(
        out,
        "        NamedOrBlankNode::BlankNode(bn) => Term::BlankNode(bn.clone()),"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();

    Ok(())
}

fn emit_path_function(
    out: &mut String,
    plan: &PlanIR,
    path_id: u64,
    path: &PlanPath,
    reverse: bool,
) -> Result<(), String> {
    let func_name = if reverse {
        format!("path_{}_rev", path_id)
    } else {
        format!("path_{}", path_id)
    };
    writeln!(
        out,
        "fn {}(store: &Store, graph: Option<GraphNameRef<'_>>, start: &Term) -> Vec<Term> {{",
        func_name
    )
    .unwrap();
    match path {
        PlanPath::Simple(term_id) => {
            let pred_iri = term_iri(plan, *term_id)?;
            let pred_iri = escape_rust_string(&pred_iri);
            if reverse {
                writeln!(
                    out,
                    "    let predicate = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(out, "    let object = term_ref(start);").unwrap();
                writeln!(
                    out,
                    "{}",
                    "    store.quads_for_pattern(None, Some(predicate), Some(object), graph)"
                )
                .unwrap();
                writeln!(out, "        .filter_map(Result::ok)").unwrap();
                writeln!(out, "        .map(|q| q.subject.into())").unwrap();
                writeln!(out, "        .collect()").unwrap();
            } else {
                writeln!(out, "{}", "    let subject = match subject_ref(start) { Some(s) => s, None => return Vec::new() };").unwrap();
                writeln!(
                    out,
                    "    let predicate = NamedNodeRef::new(\"{}\").unwrap();",
                    pred_iri
                )
                .unwrap();
                writeln!(
                    out,
                    "{}",
                    "    store.quads_for_pattern(Some(subject), Some(predicate), None, graph)"
                )
                .unwrap();
                writeln!(out, "        .filter_map(Result::ok)").unwrap();
                writeln!(out, "        .map(|q| q.object)").unwrap();
                writeln!(out, "        .collect()").unwrap();
            }
        }
        PlanPath::Inverse(inner) => {
            if reverse {
                writeln!(out, "    path_{}(store, graph, start)", inner).unwrap();
            } else {
                writeln!(out, "    path_{}_rev(store, graph, start)", inner).unwrap();
            }
        }
        PlanPath::Sequence(paths) => {
            writeln!(
                out,
                "{}",
                "    let mut current: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(out, "    current.insert(start.clone());").unwrap();
            let ids: Vec<u64> = if reverse {
                paths.iter().rev().cloned().collect()
            } else {
                paths.clone()
            };
            for id in ids {
                writeln!(
                    out,
                    "{}",
                    "    let mut next: HashSet<Term> = HashSet::new();"
                )
                .unwrap();
                writeln!(out, "{}", "    for node in current {").unwrap();
                if reverse {
                    writeln!(
                        out,
                        "        for value in path_{}_rev(store, graph, &node) {{",
                        id
                    )
                    .unwrap();
                } else {
                    writeln!(
                        out,
                        "        for value in path_{}(store, graph, &node) {{",
                        id
                    )
                    .unwrap();
                }
                writeln!(out, "            next.insert(value);").unwrap();
                writeln!(out, "{}", "        }").unwrap();
                writeln!(out, "{}", "    }").unwrap();
                writeln!(out, "    current = next;").unwrap();
                writeln!(
                    out,
                    "{}",
                    "    if current.is_empty() { return Vec::new(); }"
                )
                .unwrap();
            }
            writeln!(out, "    current.into_iter().collect()").unwrap();
        }
        PlanPath::Alternative(paths) => {
            writeln!(
                out,
                "{}",
                "    let mut out_set: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            for id in paths {
                if reverse {
                    writeln!(
                        out,
                        "    for value in path_{}_rev(store, graph, start) {{",
                        id
                    )
                    .unwrap();
                } else {
                    writeln!(out, "    for value in path_{}(store, graph, start) {{", id).unwrap();
                }
                writeln!(out, "        out_set.insert(value);").unwrap();
                writeln!(out, "{}", "    }").unwrap();
            }
            writeln!(out, "    out_set.into_iter().collect()").unwrap();
        }
        PlanPath::ZeroOrMore(inner) => {
            writeln!(
                out,
                "{}",
                "    let mut seen: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(
                out,
                "{}",
                "    let mut queue: VecDeque<Term> = VecDeque::new();"
            )
            .unwrap();
            writeln!(out, "    seen.insert(start.clone());").unwrap();
            writeln!(out, "    queue.push_back(start.clone());").unwrap();
            writeln!(out, "{}", "    while let Some(node) = queue.pop_front() {").unwrap();
            if reverse {
                writeln!(
                    out,
                    "        for value in path_{}_rev(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "        for value in path_{}(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "{}", "            if seen.insert(value.clone()) {").unwrap();
            writeln!(out, "                queue.push_back(value);").unwrap();
            writeln!(out, "{}", "            }").unwrap();
            writeln!(out, "{}", "        }").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "    seen.into_iter().collect()").unwrap();
        }
        PlanPath::OneOrMore(inner) => {
            writeln!(
                out,
                "{}",
                "    let mut seen: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(
                out,
                "{}",
                "    let mut queue: VecDeque<Term> = VecDeque::new();"
            )
            .unwrap();
            if reverse {
                writeln!(
                    out,
                    "    for value in path_{}_rev(store, graph, start) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "    for value in path_{}(store, graph, start) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "{}", "        if seen.insert(value.clone()) {").unwrap();
            writeln!(out, "            queue.push_back(value);").unwrap();
            writeln!(out, "{}", "        }").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "{}", "    while let Some(node) = queue.pop_front() {").unwrap();
            if reverse {
                writeln!(
                    out,
                    "        for value in path_{}_rev(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "        for value in path_{}(store, graph, &node) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "{}", "            if seen.insert(value.clone()) {").unwrap();
            writeln!(out, "                queue.push_back(value);").unwrap();
            writeln!(out, "{}", "            }").unwrap();
            writeln!(out, "{}", "        }").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "    seen.into_iter().collect()").unwrap();
        }
        PlanPath::ZeroOrOne(inner) => {
            writeln!(
                out,
                "{}",
                "    let mut out_set: HashSet<Term> = HashSet::new();"
            )
            .unwrap();
            writeln!(out, "    out_set.insert(start.clone());").unwrap();
            if reverse {
                writeln!(
                    out,
                    "    for value in path_{}_rev(store, graph, start) {{",
                    inner
                )
                .unwrap();
            } else {
                writeln!(
                    out,
                    "    for value in path_{}(store, graph, start) {{",
                    inner
                )
                .unwrap();
            }
            writeln!(out, "        out_set.insert(value);").unwrap();
            writeln!(out, "{}", "    }").unwrap();
            writeln!(out, "    out_set.into_iter().collect()").unwrap();
        }
    }
    writeln!(out, "{}", "}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_path_term_functions(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    if plan.paths.is_empty() {
        return Ok(());
    }
    writeln!(out, "fn path_term(path_id: u64, graph: &mut Graph) -> Term {{").unwrap();
    writeln!(out, "    match path_id {{").unwrap();
    for (id, _) in plan.paths.iter().enumerate() {
        writeln!(out, "        {} => path_term_{}(graph),", id, id).unwrap();
    }
    writeln!(out, "        _ => rdf::NIL.into(),").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn build_rdf_list(items: Vec<Term>, graph: &mut Graph) -> Term {{"
    )
    .unwrap();
    writeln!(out, "    if items.is_empty() {{").unwrap();
    writeln!(out, "        return rdf::NIL.into();").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(
        out,
        "    let bnodes: Vec<NamedOrBlankNode> = (0..items.len()).map(|_| BlankNode::default().into()).collect();"
    )
    .unwrap();
    writeln!(out, "    let head: NamedOrBlankNode = bnodes[0].clone();").unwrap();
    writeln!(out, "    for (idx, item) in items.iter().enumerate() {{").unwrap();
    writeln!(out, "        let subject: NamedOrBlankNode = bnodes[idx].clone();").unwrap();
    writeln!(
        out,
        "        graph.insert(Triple::new(subject.clone(), rdf::FIRST, item.clone()).as_ref());"
    )
    .unwrap();
    writeln!(out, "        let rest: Term = if idx + 1 == items.len() {{").unwrap();
    writeln!(out, "            rdf::NIL.into()").unwrap();
    writeln!(out, "        }} else {{").unwrap();
    writeln!(out, "            bnodes[idx + 1].clone().into()").unwrap();
    writeln!(out, "        }};").unwrap();
    writeln!(
        out,
        "        graph.insert(Triple::new(subject, rdf::REST, rest).as_ref());"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    head.into()").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    for (id, path) in plan.paths.iter().enumerate() {
        emit_path_term_function(out, plan, id as u64, path)?;
    }
    Ok(())
}

fn emit_path_term_function(
    out: &mut String,
    plan: &PlanIR,
    path_id: u64,
    path: &PlanPath,
) -> Result<(), String> {
    writeln!(
        out,
        "fn path_term_{}(graph: &mut Graph) -> Term {{",
        path_id
    )
    .unwrap();
    match path {
        PlanPath::Simple(term_id) => {
            let term_expr = term_expr_id(plan, *term_id)?;
            writeln!(out, "    {}", term_expr).unwrap();
        }
        PlanPath::Inverse(inner) => {
            writeln!(out, "    let bn = BlankNode::default();").unwrap();
            writeln!(
                out,
                "    let subject: NamedOrBlankNode = bn.clone().into();"
            )
            .unwrap();
            writeln!(out, "    let inner = path_term_{}(graph);", inner).unwrap();
            writeln!(
                out,
                "    let pred = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#inversePath\");"
            )
            .unwrap();
            writeln!(
                out,
                "    graph.insert(Triple::new(subject.clone(), pred, inner).as_ref());"
            )
            .unwrap();
            writeln!(out, "    bn.into()").unwrap();
        }
        PlanPath::Sequence(paths) => {
            let items = paths
                .iter()
                .map(|id| format!("path_term_{}(graph)", id))
                .collect::<Vec<_>>()
                .join(", ");
            writeln!(out, "    let items: Vec<Term> = vec![{}];", items).unwrap();
            writeln!(out, "    build_rdf_list(items, graph)").unwrap();
        }
        PlanPath::Alternative(paths) => {
            let items = paths
                .iter()
                .map(|id| format!("path_term_{}(graph)", id))
                .collect::<Vec<_>>()
                .join(", ");
            writeln!(out, "    let bn = BlankNode::default();").unwrap();
            writeln!(
                out,
                "    let subject: NamedOrBlankNode = bn.clone().into();"
            )
            .unwrap();
            writeln!(out, "    let items: Vec<Term> = vec![{}];", items).unwrap();
            writeln!(out, "    let list_head = build_rdf_list(items, graph);").unwrap();
            writeln!(
                out,
                "    let pred = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#alternativePath\");"
            )
            .unwrap();
            writeln!(
                out,
                "    graph.insert(Triple::new(subject.clone(), pred, list_head).as_ref());"
            )
            .unwrap();
            writeln!(out, "    bn.into()").unwrap();
        }
        PlanPath::ZeroOrMore(inner) => {
            writeln!(out, "    let bn = BlankNode::default();").unwrap();
            writeln!(
                out,
                "    let subject: NamedOrBlankNode = bn.clone().into();"
            )
            .unwrap();
            writeln!(out, "    let inner = path_term_{}(graph);", inner).unwrap();
            writeln!(
                out,
                "    let pred = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#zeroOrMorePath\");"
            )
            .unwrap();
            writeln!(
                out,
                "    graph.insert(Triple::new(subject.clone(), pred, inner).as_ref());"
            )
            .unwrap();
            writeln!(out, "    bn.into()").unwrap();
        }
        PlanPath::OneOrMore(inner) => {
            writeln!(out, "    let bn = BlankNode::default();").unwrap();
            writeln!(
                out,
                "    let subject: NamedOrBlankNode = bn.clone().into();"
            )
            .unwrap();
            writeln!(out, "    let inner = path_term_{}(graph);", inner).unwrap();
            writeln!(
                out,
                "    let pred = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#oneOrMorePath\");"
            )
            .unwrap();
            writeln!(
                out,
                "    graph.insert(Triple::new(subject.clone(), pred, inner).as_ref());"
            )
            .unwrap();
            writeln!(out, "    bn.into()").unwrap();
        }
        PlanPath::ZeroOrOne(inner) => {
            writeln!(out, "    let bn = BlankNode::default();").unwrap();
            writeln!(
                out,
                "    let subject: NamedOrBlankNode = bn.clone().into();"
            )
            .unwrap();
            writeln!(out, "    let inner = path_term_{}(graph);", inner).unwrap();
            writeln!(
                out,
                "    let pred = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#zeroOrOnePath\");"
            )
            .unwrap();
            writeln!(
                out,
                "    graph.insert(Triple::new(subject.clone(), pred, inner).as_ref());"
            )
            .unwrap();
            writeln!(out, "    bn.into()").unwrap();
        }
    }
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_shape_triples(
    out: &mut String,
    shape_graph_nt: &mut String,
    plan: &PlanIR,
) -> Result<(), String> {
    let shape_graph_iri = term_iri(plan, plan.shape_graph)?;
    for triple in &plan.shape_triples {
        let subject_term = plan
            .terms
            .get(triple.subject as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.subject))?;
        let predicate_term = plan
            .terms
            .get(triple.predicate as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.predicate))?;
        let object_term = plan
            .terms
            .get(triple.object as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.object))?;
        let subj_nt = term_to_nt(subject_term)?;
        let pred_nt = term_to_nt(predicate_term)?;
        let obj_nt = term_to_nt(object_term)?;
        writeln!(shape_graph_nt, "{} {} {} .", subj_nt, pred_nt, obj_nt).unwrap();
    }

    writeln!(
        out,
        "{}",
        "const SHAPE_GRAPH_NT: &str = include_str!(\"shape_graph.nt\");"
    )
    .unwrap();
    writeln!(out, "{}", "fn insert_shape_triples(store: &Store) {").unwrap();
    writeln!(
        out,
        "    let shape_graph = GraphName::NamedNode(NamedNode::new(\"{}\").unwrap());",
        escape_rust_string(&shape_graph_iri)
    )
    .unwrap();
    writeln!(
        out,
        "    let parser = RdfParser::from_format(RdfFormat::NTriples).for_slice(SHAPE_GRAPH_NT.as_bytes());"
    )
    .unwrap();
    writeln!(out, "{}", "    for triple in parser {").unwrap();
    writeln!(
        out,
        "{}",
        "        let triple = match triple { Ok(t) => t, Err(_) => continue };"
    )
    .unwrap();
    writeln!(
        out,
        "        let quad = Quad::new(triple.subject, triple.predicate, triple.object, shape_graph.clone());"
    )
    .unwrap();
    writeln!(out, "        let _ = store.insert(quad.as_ref());").unwrap();
    writeln!(out, "{}", "    }").unwrap();
    writeln!(out, "{}", "}").unwrap();
    writeln!(out, "").unwrap();

    Ok(())
}

fn emit_subclass_edges(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    let edges = collect_subclass_edges(plan)?;
    writeln!(out, "const SHAPE_SUBCLASS_EDGES: &[(&str, &str)] = &[").unwrap();
    for (sub, sup) in edges {
        writeln!(
            out,
            "    (\"{}\", \"{}\"),",
            escape_rust_string(&sub),
            escape_rust_string(&sup)
        )
        .unwrap();
    }
    writeln!(out, "];").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn collect_subclass_edges(plan: &PlanIR) -> Result<Vec<(String, String)>, String> {
    let mut edges = Vec::new();
    for triple in &plan.shape_triples {
        let predicate_term = plan
            .terms
            .get(triple.predicate as usize)
            .ok_or_else(|| format!("Unknown term id {}", triple.predicate))?;
        if let Term::NamedNode(node) = predicate_term {
            if node.as_str() != "http://www.w3.org/2000/01/rdf-schema#subClassOf" {
                continue;
            }
        } else {
            continue;
        }

        let subject = match term_iri(plan, triple.subject) {
            Ok(value) => value,
            Err(_) => continue,
        };
        let object = match term_iri(plan, triple.object) {
            Ok(value) => value,
            Err(_) => continue,
        };
        edges.push((subject, object));
    }
    Ok(edges)
}

fn term_expr_id(plan: &PlanIR, term_id: u64) -> Result<String, String> {
    let term = plan
        .terms
        .get(term_id as usize)
        .ok_or_else(|| format!("Unknown term id {}", term_id))?;
    term_expr(term)
}

fn term_sparql_const(plan: &PlanIR, term_id: u64) -> Result<String, String> {
    let term = plan
        .terms
        .get(term_id as usize)
        .ok_or_else(|| format!("Unknown term id {}", term_id))?;
    Ok(term.to_string())
}

fn build_qualified_sibling_map(
    plan: &PlanIR,
    component_lookup: &HashMap<CompId, &crate::plan::PlanComponent>,
) -> HashMap<CompId, Vec<u64>> {
    let mut prop_shapes_by_node: HashMap<u64, Vec<u64>> = HashMap::new();
    for shape in &plan.shapes {
        if shape.kind != PlanShapeKind::Node {
            continue;
        }
        let mut props = Vec::new();
        for comp_id in &shape.constraints {
            if let Some(component) = component_lookup.get(comp_id) {
                if component.kind == ComponentKind::Property {
                    if let crate::plan::ComponentParams::Property { shape } = component.params {
                        props.push(shape);
                    }
                }
            }
        }
        prop_shapes_by_node.insert(shape.id, props);
    }

    let mut qualified_by_prop: HashMap<u64, Vec<(CompId, u64)>> = HashMap::new();
    for shape in &plan.shapes {
        if shape.kind != PlanShapeKind::Property {
            continue;
        }
        let mut comps = Vec::new();
        for comp_id in &shape.constraints {
            if let Some(component) = component_lookup.get(comp_id) {
                if component.kind == ComponentKind::QualifiedValueShape {
                    if let crate::plan::ComponentParams::QualifiedValueShape { shape, .. } =
                        component.params
                    {
                        comps.push((component.id, shape));
                    }
                }
            }
        }
        if !comps.is_empty() {
            qualified_by_prop.insert(shape.id, comps);
        }
    }

    let mut siblings: HashMap<CompId, Vec<u64>> = HashMap::new();
    for (_, props) in prop_shapes_by_node {
        let mut all: Vec<(CompId, u64)> = Vec::new();
        for prop_id in props {
            if let Some(list) = qualified_by_prop.get(&prop_id) {
                all.extend(list.iter().cloned());
            }
        }
        for (comp_id, _) in &all {
            let mut sibs = Vec::new();
            for (other_id, shape_id) in &all {
                if other_id == comp_id {
                    continue;
                }
                sibs.push(*shape_id);
            }
            siblings.insert(*comp_id, sibs);
        }
    }

    siblings
}

fn build_allowed_predicate_map(
    plan: &PlanIR,
    component_lookup: &HashMap<CompId, &crate::plan::PlanComponent>,
    property_shape_lookup: &HashMap<u64, &PlanShape>,
) -> Result<HashMap<u64, Vec<String>>, String> {
    let mut allowed: HashMap<u64, Vec<String>> = HashMap::new();
    for shape in plan.shapes.iter().filter(|s| s.kind == PlanShapeKind::Node) {
        let mut predicates = Vec::new();
        for comp_id in &shape.constraints {
            if let Some(component) = component_lookup.get(comp_id) {
                if component.kind == ComponentKind::Property {
                    if let crate::plan::ComponentParams::Property { shape: prop_id } =
                        component.params
                    {
                        if let Some(prop_shape) = property_shape_lookup.get(&prop_id) {
                            if let Some(path_id) = prop_shape.path {
                                if let Ok(iri) = simple_predicate(plan, path_id) {
                                    predicates.push(iri);
                                }
                            }
                        }
                    }
                }
            }
        }
        allowed.insert(shape.id, predicates);
    }
    Ok(allowed)
}

fn subject_expr(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!(
            "NamedOrBlankNode::NamedNode(NamedNode::new(\"{}\").unwrap())",
            escape_rust_string(node.as_str())
        )),
        Term::BlankNode(node) => Ok(format!(
            "NamedOrBlankNode::BlankNode(BlankNode::new_unchecked(\"{}\"))",
            escape_rust_string(node.as_str())
        )),
        _ => Err("Invalid subject term for shape triple".to_string()),
    }
}

fn named_node_expr(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!(
            "NamedNode::new(\"{}\").unwrap()",
            escape_rust_string(node.as_str())
        )),
        _ => Err("Invalid predicate term for shape triple".to_string()),
    }
}

fn term_expr(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!(
            "Term::NamedNode(NamedNode::new(\"{}\").unwrap())",
            escape_rust_string(node.as_str())
        )),
        Term::BlankNode(node) => Ok(format!(
            "Term::BlankNode(BlankNode::new_unchecked(\"{}\"))",
            escape_rust_string(node.as_str())
        )),
        Term::Literal(lit) => {
            if let Some(lang) = lit.language() {
                Ok(format!(
                    "Term::Literal(Literal::new_language_tagged_literal(\"{}\", \"{}\").unwrap())",
                    escape_rust_string(lit.value()),
                    escape_rust_string(lang)
                ))
            } else if lit.datatype().as_str() == "http://www.w3.org/2001/XMLSchema#string" {
                Ok(format!(
                    "Term::Literal(Literal::new_simple_literal(\"{}\"))",
                    escape_rust_string(lit.value())
                ))
            } else {
                Ok(format!(
                    "Term::Literal(Literal::new_typed_literal(\"{}\", NamedNode::new(\"{}\").unwrap()))",
                    escape_rust_string(lit.value()),
                    escape_rust_string(lit.datatype().as_str())
                ))
            }
        }
    }
}

fn term_to_nt(term: &Term) -> Result<String, String> {
    match term {
        Term::NamedNode(node) => Ok(format!("<{}>", escape_nt_iri(node.as_str()))),
        Term::BlankNode(node) => Ok(format!("_:{}", node.as_str())),
        Term::Literal(lit) => {
            let mut out = String::new();
            out.push('"');
            out.push_str(&escape_nt_string(lit.value()));
            out.push('"');
            if let Some(lang) = lit.language() {
                out.push('@');
                out.push_str(lang);
            } else {
                out.push_str("^^<");
                out.push_str(&escape_nt_iri(lit.datatype().as_str()));
                out.push('>');
            }
            Ok(out)
        }
    }
}

fn escape_nt_string(value: &str) -> String {
    let mut out = String::with_capacity(value.len());
    for ch in value.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '"' => out.push_str("\\\""),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            ch if ch <= '\u{1F}' || ch == '\u{7F}' => {
                out.push_str(&format!("\\u{:04X}", ch as u32))
            }
            ch => out.push(ch),
        }
    }
    out
}

fn escape_nt_iri(value: &str) -> String {
    let mut out = String::with_capacity(value.len());
    for ch in value.chars() {
        match ch {
            '<' | '>' | '"' | '{' | '}' | '|' | '^' | '`' | '\\' => {
                out.push_str(&format!("\\u{:04X}", ch as u32))
            }
            ch if ch <= '\u{1F}' || ch == '\u{7F}' => {
                out.push_str(&format!("\\u{:04X}", ch as u32))
            }
            ch => out.push(ch),
        }
    }
    out
}

fn escape_rust_string(value: &str) -> String {
    value
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn severity_to_iri_string(severity: &Severity) -> Result<String, String> {
    match severity {
        Severity::Info => Ok("http://www.w3.org/ns/shacl#Info".to_string()),
        Severity::Warning => Ok("http://www.w3.org/ns/shacl#Warning".to_string()),
        Severity::Violation => Ok("http://www.w3.org/ns/shacl#Violation".to_string()),
        Severity::Custom(term) => Ok(term.as_str().to_string()),
    }
}

fn emit_shape_and_component_maps(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    emit_shape_iri_map(out, plan)?;
    emit_component_iri_map(out, plan)?;
    emit_component_source_constraint_map(out, plan)?;
    emit_severity_map(out, plan)?;
    Ok(())
}

fn emit_shape_iri_map(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    writeln!(out, "fn shape_iri(shape_id: u64) -> &'static str {{").unwrap();
    writeln!(out, "    match shape_id {{").unwrap();
    for shape in &plan.shapes {
        let iri = term_iri(plan, shape.term)?;
        writeln!(
            out,
            "        {} => \"{}\",",
            shape.id,
            escape_rust_string(&iri)
        )
        .unwrap();
    }
    writeln!(out, "        _ => \"\",").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_component_iri_map(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    writeln!(
        out,
        "fn component_iri(component_id: u64) -> &'static str {{"
    )
    .unwrap();
    writeln!(out, "    match component_id {{").unwrap();
    for component in &plan.components {
        let component_iri = match component.kind {
            ComponentKind::Custom => match &component.params {
                ComponentParams::Custom { iri, .. } => term_iri(plan, *iri)?,
                _ => "http://www.w3.org/ns/shacl#ConstraintComponent".to_string(),
            },
            _ => constraint_component_iri(component).to_string(),
        };
        writeln!(
            out,
            "        {} => \"{}\",",
            component.id,
            escape_rust_string(&component_iri)
        )
        .unwrap();
    }
    writeln!(
        out,
        "        _ => \"http://www.w3.org/ns/shacl#ConstraintComponent\","
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_component_source_constraint_map(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    writeln!(
        out,
        "fn component_source_constraint(component_id: u64) -> Option<Term> {{"
    )
    .unwrap();
    writeln!(out, "    match component_id {{").unwrap();
    for component in &plan.components {
        if let ComponentParams::Sparql { constraint_node, .. } = &component.params {
            let term_expr = term_expr_id(plan, *constraint_node)?;
            writeln!(
                out,
                "        {} => Some({}),",
                component.id, term_expr
            )
            .unwrap();
        }
    }
    writeln!(out, "        _ => None,").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn emit_severity_map(out: &mut String, plan: &PlanIR) -> Result<(), String> {
    writeln!(out, "fn severity_term(shape_id: u64) -> &'static str {{").unwrap();
    writeln!(out, "    match shape_id {{").unwrap();
    for shape in &plan.shapes {
        let severity_str = severity_to_iri_string(&shape.severity)?;
        writeln!(
            out,
            "        {} => \"{}\",",
            shape.id,
            escape_rust_string(&severity_str)
        )
        .unwrap();
    }
    writeln!(
        out,
        "        _ => \"http://www.w3.org/ns/shacl#Violation\","
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}

fn constraint_component_iri(component: &PlanComponent) -> &'static str {
    match component.kind {
        ComponentKind::Node => "http://www.w3.org/ns/shacl#NodeConstraintComponent",
        ComponentKind::Property => "http://www.w3.org/ns/shacl#PropertyShapeComponent",
        ComponentKind::QualifiedValueShape => match &component.params {
            ComponentParams::QualifiedValueShape { min_count, .. } => {
                if min_count.is_some() {
                    "http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent"
                } else {
                    "http://www.w3.org/ns/shacl#QualifiedMaxCountConstraintComponent"
                }
            }
            _ => "http://www.w3.org/ns/shacl#QualifiedMinCountConstraintComponent",
        },
        ComponentKind::Class => "http://www.w3.org/ns/shacl#ClassConstraintComponent",
        ComponentKind::Datatype => "http://www.w3.org/ns/shacl#DatatypeConstraintComponent",
        ComponentKind::NodeKind => "http://www.w3.org/ns/shacl#NodeKindConstraintComponent",
        ComponentKind::MinCount => "http://www.w3.org/ns/shacl#MinCountConstraintComponent",
        ComponentKind::MaxCount => "http://www.w3.org/ns/shacl#MaxCountConstraintComponent",
        ComponentKind::MinExclusive => "http://www.w3.org/ns/shacl#MinExclusiveConstraintComponent",
        ComponentKind::MinInclusive => "http://www.w3.org/ns/shacl#MinInclusiveConstraintComponent",
        ComponentKind::MaxExclusive => "http://www.w3.org/ns/shacl#MaxExclusiveConstraintComponent",
        ComponentKind::MaxInclusive => "http://www.w3.org/ns/shacl#MaxInclusiveConstraintComponent",
        ComponentKind::MinLength => "http://www.w3.org/ns/shacl#MinLengthConstraintComponent",
        ComponentKind::MaxLength => "http://www.w3.org/ns/shacl#MaxLengthConstraintComponent",
        ComponentKind::Pattern => "http://www.w3.org/ns/shacl#PatternConstraintComponent",
        ComponentKind::LanguageIn => "http://www.w3.org/ns/shacl#LanguageInConstraintComponent",
        ComponentKind::UniqueLang => "http://www.w3.org/ns/shacl#UniqueLangConstraintComponent",
        ComponentKind::Equals => "http://www.w3.org/ns/shacl#EqualsConstraintComponent",
        ComponentKind::Disjoint => "http://www.w3.org/ns/shacl#DisjointConstraintComponent",
        ComponentKind::LessThan => "http://www.w3.org/ns/shacl#LessThanConstraintComponent",
        ComponentKind::LessThanOrEquals => {
            "http://www.w3.org/ns/shacl#LessThanOrEqualsConstraintComponent"
        }
        ComponentKind::Not => "http://www.w3.org/ns/shacl#NotConstraintComponent",
        ComponentKind::And => "http://www.w3.org/ns/shacl#AndConstraintComponent",
        ComponentKind::Or => "http://www.w3.org/ns/shacl#OrConstraintComponent",
        ComponentKind::Xone => "http://www.w3.org/ns/shacl#XoneConstraintComponent",
        ComponentKind::Closed => "http://www.w3.org/ns/shacl#ClosedConstraintComponent",
        ComponentKind::HasValue => "http://www.w3.org/ns/shacl#HasValueConstraintComponent",
        ComponentKind::In => "http://www.w3.org/ns/shacl#InConstraintComponent",
        ComponentKind::Sparql => "http://www.w3.org/ns/shacl#SPARQLConstraintComponent",
        ComponentKind::Custom => "http://www.w3.org/ns/shacl#ConstraintComponent",
    }
}

fn emit_validation_report_helpers(out: &mut String) -> Result<(), String> {
    writeln!(
        out,
        "const SHACL_VALIDATION_REPORT: &str = \"http://www.w3.org/ns/shacl#ValidationReport\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_VALIDATION_RESULT: &str = \"http://www.w3.org/ns/shacl#ValidationResult\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_RESULT: &str = \"http://www.w3.org/ns/shacl#result\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_FOCUS_NODE: &str = \"http://www.w3.org/ns/shacl#focusNode\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_SOURCE_SHAPE: &str = \"http://www.w3.org/ns/shacl#sourceShape\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_SOURCE_CONSTRAINT_COMPONENT: &str = \"http://www.w3.org/ns/shacl#sourceConstraintComponent\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_VALUE: &str = \"http://www.w3.org/ns/shacl#value\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_MESSAGE: &str = \"http://www.w3.org/ns/shacl#message\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_RESULT_SEVERITY: &str = \"http://www.w3.org/ns/shacl#resultSeverity\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_VIOLATION: &str = \"http://www.w3.org/ns/shacl#Violation\";"
    )
    .unwrap();
    writeln!(
        out,
        "const SHACL_CONFORMS: &str = \"http://www.w3.org/ns/shacl#conforms\";"
    )
    .unwrap();
    writeln!(
        out,
        "const XSD_BOOLEAN: &str = \"http://www.w3.org/2001/XMLSchema#boolean\";"
    )
    .unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn bool_literal(value: bool) -> &'static str {{").unwrap();
    writeln!(out, "    if value {{").unwrap();
    writeln!(
        out,
        "        \"\\\"true\\\"^^<http://www.w3.org/2001/XMLSchema#boolean>\""
    )
    .unwrap();
    writeln!(out, "    }} else {{").unwrap();
    writeln!(
        out,
        "        \"\\\"false\\\"^^<http://www.w3.org/2001/XMLSchema#boolean>\""
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn term_to_turtle_value(term: &Term) -> String {{").unwrap();
    writeln!(out, "    match term {{").unwrap();
    writeln!(
        out,
        "        Term::NamedNode(node) => format!(\"<{{}}>\", escape_iri(node.as_str())),"
    )
    .unwrap();
    writeln!(
        out,
        "        Term::BlankNode(node) => format!(\"_:{{}}\", node.as_str()),"
    )
    .unwrap();
    writeln!(out, "        Term::Literal(lit) => {{").unwrap();
    writeln!(out, "            let mut out = String::new();").unwrap();
    writeln!(out, "            let lex = lit.value().to_string();").unwrap();
    writeln!(out, "            out.push('\\\"');").unwrap();
    writeln!(out, "            out.push_str(&escape_literal(&lex));").unwrap();
    writeln!(out, "            out.push('\\\"');").unwrap();
    writeln!(out, "            if let Some(lang) = lit.language() {{").unwrap();
    writeln!(out, "                out.push('@');").unwrap();
    writeln!(out, "                out.push_str(lang);").unwrap();
    writeln!(
        out,
        "            }} else if lit.datatype().as_str() != \"http://www.w3.org/2001/XMLSchema#string\" {{"
    )
    .unwrap();
    writeln!(out, "                out.push_str(\"^^<\");").unwrap();
    writeln!(
        out,
        "                out.push_str(&escape_iri(lit.datatype().as_str()));"
    )
    .unwrap();
    writeln!(out, "                out.push('>');").unwrap();
    writeln!(out, "            }}").unwrap();
    writeln!(out, "            out").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn literal_string(value: &str) -> String {{").unwrap();
    writeln!(
        out,
        "    format!(\"\\\"{{}}\\\"^^<http://www.w3.org/2001/XMLSchema#string>\", escape_literal(value))"
    )
    .unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(out, "fn escape_literal(value: &str) -> String {{").unwrap();
    writeln!(out, "    let mut escaped = String::new();").unwrap();
    writeln!(out, "    for ch in value.chars() {{").unwrap();
    writeln!(out, "        match ch {{").unwrap();
    writeln!(out, "            '\\\\' => escaped.push_str(\"\\\\\\\\\"),").unwrap();
    writeln!(out, "            '\"' => escaped.push_str(\"\\\\\\\"\"),").unwrap();
    writeln!(out, "            '\\n' => escaped.push_str(\"\\\\n\"),").unwrap();
    writeln!(out, "            '\\r' => escaped.push_str(\"\\\\r\"),").unwrap();
    writeln!(out, "            '\\t' => escaped.push_str(\"\\\\t\"),").unwrap();
    writeln!(
        out,
        "            ch if (ch as u32) < 0x20 => escaped.push_str(&format!(\"\\\\u{{:04X}}\", ch as u32)),"
    )
    .unwrap();
    writeln!(out, "            ch => escaped.push(ch),").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    escaped").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn is_plain_decimal_integer(value: &str) -> bool {{").unwrap();
    writeln!(out, "    let mut chars = value.chars();").unwrap();
    writeln!(out, "    let first = match chars.next() {{").unwrap();
    writeln!(out, "        Some(ch) => ch,").unwrap();
    writeln!(out, "        None => return false,").unwrap();
    writeln!(out, "    }};").unwrap();
    writeln!(out, "    let mut has_digit = false;").unwrap();
    writeln!(out, "    if first.is_ascii_digit() {{").unwrap();
    writeln!(out, "        has_digit = true;").unwrap();
    writeln!(out, "    }} else if first != '+' && first != '-' {{").unwrap();
    writeln!(out, "        return false;").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    for ch in chars {{").unwrap();
    writeln!(out, "        if !ch.is_ascii_digit() {{").unwrap();
    writeln!(out, "            return false;").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        has_digit = true;").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    has_digit").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn normalize_decimal_literal(value: &str) -> String {{").unwrap();
    writeln!(out, "    if is_plain_decimal_integer(value) {{").unwrap();
    writeln!(out, "        format!(\"{{}}.0\", value)").unwrap();
    writeln!(out, "    }} else {{").unwrap();
    writeln!(out, "        value.to_string()").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(out, "fn escape_iri(value: &str) -> String {{").unwrap();
    writeln!(out, "    let mut out = String::with_capacity(value.len());").unwrap();
    writeln!(out, "    for ch in value.chars() {{").unwrap();
    writeln!(out, "        match ch {{").unwrap();
    writeln!(
        out,
        "            '<' | '>' | '\\\"' | '{{' | '}}' | '|' | '^' | '`' | '\\\\' => {{"
    )
    .unwrap();
    writeln!(
        out,
        "                out.push_str(&format!(\"\\\\u{{:04X}}\", ch as u32));"
    )
    .unwrap();
    writeln!(out, "            }}").unwrap();
    writeln!(
        out,
        "            ch if (ch as u32) < 0x20 || (ch as u32) == 0x7F => {{"
    )
    .unwrap();
    writeln!(
        out,
        "                out.push_str(&format!(\"\\\\u{{:04X}}\", ch as u32));"
    )
    .unwrap();
    writeln!(out, "            }}").unwrap();
    writeln!(out, "            ch => out.push(ch),").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    out").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn message_terms_for_subject(store: &Store, subject_iri: &str) -> Vec<Term> {{"
    )
    .unwrap();
    writeln!(out, "    let mut out = Vec::new();").unwrap();
    writeln!(
        out,
        "    let subject = match NamedNode::new(subject_iri) {{ Ok(node) => node, Err(_) => return out }};"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_message = NamedNodeRef::new(SHACL_MESSAGE).unwrap();"
    )
    .unwrap();
    writeln!(out, "    let shape_graph = shape_graph_ref();").unwrap();
    writeln!(
        out,
        "    for quad in store.quads_for_pattern(Some(NamedOrBlankNodeRef::NamedNode(subject.as_ref())), Some(sh_message), None, Some(shape_graph)) {{"
    )
    .unwrap();
    writeln!(out, "        if let Ok(quad) = quad {{").unwrap();
    writeln!(out, "            out.push(quad.object);").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    out").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn message_terms_for_term(store: &Store, term: &Term) -> Vec<Term> {{"
    )
    .unwrap();
    writeln!(out, "    let mut out = Vec::new();").unwrap();
    writeln!(
        out,
        "    let subject = match term {{"
    )
    .unwrap();
    writeln!(
        out,
        "        Term::NamedNode(node) => NamedOrBlankNodeRef::NamedNode(node.as_ref()),"
    )
    .unwrap();
    writeln!(
        out,
        "        Term::BlankNode(node) => NamedOrBlankNodeRef::BlankNode(node.as_ref()),"
    )
    .unwrap();
    writeln!(out, "        _ => return out,").unwrap();
    writeln!(out, "    }};").unwrap();
    writeln!(
        out,
        "    let sh_message = NamedNodeRef::new(SHACL_MESSAGE).unwrap();"
    )
    .unwrap();
    writeln!(out, "    let shape_graph = shape_graph_ref();").unwrap();
    writeln!(
        out,
        "    for quad in store.quads_for_pattern(Some(subject), Some(sh_message), None, Some(shape_graph)) {{"
    )
    .unwrap();
    writeln!(out, "        if let Ok(quad) = quad {{").unwrap();
    writeln!(out, "            out.push(quad.object);").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    out").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn collect_message_terms(store: &Store, shape_iri: &str, component_iri: &str, constraint_term: Option<&Term>) -> Vec<Term> {{"
    )
    .unwrap();
    writeln!(
        out,
        "    let mut messages = message_terms_for_subject(store, shape_iri);"
    )
    .unwrap();
    writeln!(out, "    if messages.is_empty() {{").unwrap();
    writeln!(
        out,
        "        if let Some(term) = constraint_term {{"
    )
    .unwrap();
    writeln!(
        out,
        "            messages = message_terms_for_term(store, term);"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    if messages.is_empty() {{").unwrap();
    writeln!(
        out,
        "        messages = message_terms_for_subject(store, component_iri);"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    messages").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(out, "fn deskolemize_term(term: Term) -> Term {{").unwrap();
    writeln!(out, "    if let Term::NamedNode(node) = &term {{").unwrap();
    writeln!(out, "        if let Some(idx) = node.as_str().find(\"/.sk/\") {{").unwrap();
    writeln!(out, "            let suffix = &node.as_str()[idx + 5..];").unwrap();
    writeln!(
        out,
        "            return Term::BlankNode(BlankNode::new_unchecked(suffix));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    term").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();

    writeln!(
        out,
        "fn format_validation_report(report: &Report, store: &Store) -> String {{"
    )
    .unwrap();
    writeln!(out, "    let graph = validation_report_graph(report, store);").unwrap();
    writeln!(out, "    graph_to_turtle(&graph)").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(
        out,
        "fn validation_report_graph(report: &Report, store: &Store) -> Graph {{"
    )
    .unwrap();
    writeln!(out, "    let mut graph = Graph::new();").unwrap();
    writeln!(
        out,
        "    let report_node: NamedOrBlankNode = BlankNode::default().into();"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_validation_report = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#ValidationReport\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_validation_result = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#ValidationResult\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_conforms = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#conforms\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_result = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#result\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_focus_node = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#focusNode\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_source_shape = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#sourceShape\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_source_constraint_component = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#sourceConstraintComponent\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_source_constraint = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#sourceConstraint\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_value = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#value\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_result_path = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#resultPath\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_result_severity = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#resultSeverity\");"
    )
    .unwrap();
    writeln!(
        out,
        "    let sh_result_message = NamedNode::new_unchecked(\"http://www.w3.org/ns/shacl#resultMessage\");"
    )
    .unwrap();
    writeln!(
        out,
        "    graph.insert(Triple::new(report_node.clone(), rdf::TYPE, Term::from(sh_validation_report.clone())).as_ref());"
    )
    .unwrap();
    writeln!(
        out,
        "    graph.insert(Triple::new(report_node.clone(), sh_conforms.clone(), Term::from(Literal::from(report.violations.is_empty()))).as_ref());"
    )
    .unwrap();
    writeln!(out, "    for violation in report.violations.iter() {{").unwrap();
    writeln!(
        out,
        "        let result_node: NamedOrBlankNode = BlankNode::default().into();"
    )
    .unwrap();
    writeln!(
        out,
        "        graph.insert(Triple::new(report_node.clone(), sh_result.clone(), Term::from(result_node.clone())).as_ref());"
    )
    .unwrap();
    writeln!(
        out,
        "        graph.insert(Triple::new(result_node.clone(), rdf::TYPE, Term::from(sh_validation_result.clone())).as_ref());"
    )
    .unwrap();
    writeln!(out, "        let focus_term = deskolemize_term(violation.focus.clone());")
        .unwrap();
    writeln!(
        out,
        "        graph.insert(Triple::new(result_node.clone(), sh_focus_node.clone(), focus_term).as_ref());"
    )
    .unwrap();
    writeln!(out, "        let shape_iri_str = shape_iri(violation.shape_id);").unwrap();
    writeln!(
        out,
        "        let shape_term = deskolemize_term(Term::from(NamedNode::new_unchecked(shape_iri_str)));"
    )
    .unwrap();
    writeln!(
        out,
        "        graph.insert(Triple::new(result_node.clone(), sh_source_shape.clone(), shape_term).as_ref());"
    )
    .unwrap();
    writeln!(
        out,
        "        let component_term = component_iri(violation.component_id);"
    )
    .unwrap();
    writeln!(
        out,
        "        let component_node = NamedNode::new_unchecked(component_term);"
    )
    .unwrap();
    writeln!(
        out,
        "        graph.insert(Triple::new(result_node.clone(), sh_source_constraint_component.clone(), Term::from(component_node)).as_ref());"
    )
    .unwrap();
    writeln!(
        out,
        "        let source_constraint = component_source_constraint(violation.component_id);"
    )
    .unwrap();
    writeln!(out, "        if let Some(source_constraint_term) = source_constraint.as_ref() {{").unwrap();
    writeln!(
        out,
        "            let source_constraint = deskolemize_term(source_constraint_term.clone());"
    )
    .unwrap();
    writeln!(
        out,
        "            graph.insert(Triple::new(result_node.clone(), sh_source_constraint.clone(), source_constraint).as_ref());"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        if let Some(value) = &violation.value {{").unwrap();
    writeln!(
        out,
        "            let value_term = deskolemize_term(value.clone());"
    )
    .unwrap();
    writeln!(
        out,
        "            graph.insert(Triple::new(result_node.clone(), sh_value.clone(), value_term).as_ref());"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        if let Some(path) = &violation.path {{").unwrap();
    writeln!(
        out,
        "            let path_term = match path {{"
    )
    .unwrap();
    writeln!(
        out,
        "                ResultPath::PathId(id) => path_term(*id, &mut graph),"
    )
    .unwrap();
    writeln!(
        out,
        "                ResultPath::Term(term) => term.clone(),"
    )
    .unwrap();
    writeln!(out, "            }};").unwrap();
    writeln!(
        out,
        "            let path_term = deskolemize_term(path_term);"
    )
    .unwrap();
    writeln!(
        out,
        "            graph.insert(Triple::new(result_node.clone(), sh_result_path.clone(), path_term).as_ref());"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(
        out,
        "        let severity_node = NamedNode::new_unchecked(severity_term(violation.shape_id));"
    )
    .unwrap();
    writeln!(
        out,
        "        graph.insert(Triple::new(result_node.clone(), sh_result_severity.clone(), Term::from(severity_node)).as_ref());"
    )
    .unwrap();
    writeln!(
        out,
        "        let message_terms = collect_message_terms(store, shape_iri_str, component_term, source_constraint.as_ref());"
    )
    .unwrap();
    writeln!(out, "        for message in message_terms {{").unwrap();
    writeln!(
        out,
        "            graph.insert(Triple::new(result_node.clone(), sh_result_message.clone(), message).as_ref());"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    graph").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(out, "fn subject_to_turtle(subject: &NamedOrBlankNodeRef<'_>) -> String {{").unwrap();
    writeln!(out, "    match subject {{").unwrap();
    writeln!(
        out,
        "        NamedOrBlankNodeRef::NamedNode(node) => format!(\"<{{}}>\", escape_iri(node.as_str())),"
    )
    .unwrap();
    writeln!(
        out,
        "        NamedOrBlankNodeRef::BlankNode(node) => format!(\"_:{{}}\", node.as_str()),"
    )
    .unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(out, "fn predicate_to_turtle(predicate: &NamedNodeRef<'_>) -> String {{").unwrap();
    writeln!(
        out,
        "    format!(\"<{{}}>\", escape_iri(predicate.as_str()))"
    )
    .unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(out, "fn term_ref_to_turtle_value(term: &TermRef<'_>) -> String {{").unwrap();
    writeln!(out, "    match term {{").unwrap();
    writeln!(
        out,
        "        TermRef::NamedNode(node) => format!(\"<{{}}>\", escape_iri(node.as_str())),"
    )
    .unwrap();
    writeln!(
        out,
        "        TermRef::BlankNode(node) => format!(\"_:{{}}\", node.as_str()),"
    )
    .unwrap();
    writeln!(out, "        TermRef::Literal(lit) => {{").unwrap();
    writeln!(out, "            let mut out = String::new();").unwrap();
    writeln!(out, "            let lex = lit.value().to_string();").unwrap();
    writeln!(out, "            out.push('\\\"');").unwrap();
    writeln!(out, "            out.push_str(&escape_literal(&lex));").unwrap();
    writeln!(out, "            out.push('\\\"');").unwrap();
    writeln!(out, "            if let Some(lang) = lit.language() {{").unwrap();
    writeln!(out, "                out.push('@');").unwrap();
    writeln!(out, "                out.push_str(lang);").unwrap();
    writeln!(
        out,
        "            }} else if lit.datatype().as_str() != \"http://www.w3.org/2001/XMLSchema#string\" {{"
    )
    .unwrap();
    writeln!(out, "                out.push_str(\"^^<\");").unwrap();
    writeln!(
        out,
        "                out.push_str(&escape_iri(lit.datatype().as_str()));"
    )
    .unwrap();
    writeln!(out, "                out.push('>');").unwrap();
    writeln!(out, "            }}").unwrap();
    writeln!(out, "            out").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(out, "fn graph_to_turtle(graph: &Graph) -> String {{").unwrap();
    writeln!(out, "    let mut out = String::new();").unwrap();
    writeln!(out, "    for triple in graph.iter() {{").unwrap();
    writeln!(out, "        let subject = subject_to_turtle(&triple.subject);").unwrap();
    writeln!(out, "        let predicate = predicate_to_turtle(&triple.predicate);").unwrap();
    writeln!(out, "        let object = term_ref_to_turtle_value(&triple.object);").unwrap();
    writeln!(out, "        out.push_str(&subject);").unwrap();
    writeln!(out, "        out.push(' ');").unwrap();
    writeln!(out, "        out.push_str(&predicate);").unwrap();
    writeln!(out, "        out.push(' ');").unwrap();
    writeln!(out, "        out.push_str(&object);").unwrap();
    writeln!(out, "        out.push_str(\" .\\n\");").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    if out.is_empty() {{").unwrap();
    writeln!(out, "        out.push_str(\"\\n.\");").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    out").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(
        out,
        "fn follow_validation_bnodes(graph: &mut Graph, store: &Store) {{"
    )
    .unwrap();
    writeln!(out, "    let mut queue: VecDeque<Term> = VecDeque::new();").unwrap();
    writeln!(out, "    let mut seen: HashSet<Term> = HashSet::new();").unwrap();
    writeln!(out, "    for triple in graph.iter() {{").unwrap();
    writeln!(
        out,
        "        if let NamedOrBlankNodeRef::BlankNode(bn) = triple.subject {{"
    )
    .unwrap();
    writeln!(
        out,
        "            queue.push_back(Term::BlankNode(bn.into_owned()));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(
        out,
        "        if let TermRef::BlankNode(bn) = triple.object {{"
    )
    .unwrap();
    writeln!(
        out,
        "            queue.push_back(Term::BlankNode(bn.into_owned()));"
    )
    .unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    while let Some(term) = queue.pop_front() {{").unwrap();
    writeln!(out, "        if !seen.insert(term.clone()) {{").unwrap();
    writeln!(out, "            continue;").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "        let subject = match subject_ref(&term) {{").unwrap();
    writeln!(out, "            Some(subject) => subject,").unwrap();
    writeln!(out, "            None => continue,").unwrap();
    writeln!(out, "        }};").unwrap();
    writeln!(
        out,
        "        for quad in store.quads_for_pattern(Some(subject), None, None, None) {{"
    )
    .unwrap();
    writeln!(out, "            if let Ok(quad) = quad {{").unwrap();
    writeln!(out, "                let object = quad.object.clone();").unwrap();
    writeln!(out, "                let triple = Triple::new(quad.subject.clone(), quad.predicate.clone(), object.clone());").unwrap();
    writeln!(out, "                graph.insert(triple.as_ref());").unwrap();
    writeln!(
        out,
        "                if let Term::BlankNode(bn) = object {{"
    )
    .unwrap();
    writeln!(
        out,
        "                    queue.push_back(Term::BlankNode(bn));"
    )
    .unwrap();
    writeln!(out, "                }}").unwrap();
    writeln!(out, "            }}").unwrap();
    writeln!(out, "        }}").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    writeln!(
        out,
        "pub fn render_report(report: &Report, store: &Store, follow_bnodes: bool) -> String {{"
    )
    .unwrap();
    writeln!(
        out,
        "    let mut graph = validation_report_graph(report, store);"
    )
    .unwrap();
    writeln!(out, "    if follow_bnodes {{").unwrap();
    writeln!(out, "        follow_validation_bnodes(&mut graph, store);").unwrap();
    writeln!(out, "    }}").unwrap();
    writeln!(out, "    graph_to_turtle(&graph)").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out, "").unwrap();
    Ok(())
}
